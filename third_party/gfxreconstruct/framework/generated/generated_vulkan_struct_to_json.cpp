/*
** Copyright (c) 2018-2023 Valve Corporation
** Copyright (c) 2018-2023 LunarG, Inc.
** Copyright (c) 2023 Advanced Micro Devices, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "generated_vulkan_struct_to_json.h"
#include "generated_vulkan_enum_to_json.h"
#include "util/to_string.h"

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)
using util::JsonOptions;
using util::to_hex_variable_width;
using util::uuid_to_string;


template<typename T>
struct FieldToJsonStruct{
    static void invoke(nlohmann::ordered_json& jdata, const T* data, const JsonOptions& options);
};
template<typename T>
void FieldToJsonResolve(nlohmann::ordered_json& jdata, const T& data, const JsonOptions& options) {
    if constexpr (IsFieldToJsonStruct<std::remove_const_t<std::remove_pointer_t<T>>>::value) {
        FieldToJsonStruct<std::remove_const_t<std::remove_pointer_t<T>>>::invoke(jdata, data, options);
    } else {
        FieldToJson(jdata, data, options);
    }
}


template<>
void FieldToJsonStruct<Decoded_StdVideoH264SpsVuiFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SpsVuiFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SpsVuiFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SpsVuiFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["aspect_ratio_info_present_flag"], decoded_value.aspect_ratio_info_present_flag, options);
        FieldToJsonResolve(jdata["overscan_info_present_flag"], decoded_value.overscan_info_present_flag, options);
        FieldToJsonResolve(jdata["overscan_appropriate_flag"], decoded_value.overscan_appropriate_flag, options);
        FieldToJsonResolve(jdata["video_signal_type_present_flag"], decoded_value.video_signal_type_present_flag, options);
        FieldToJsonResolve(jdata["video_full_range_flag"], decoded_value.video_full_range_flag, options);
        FieldToJsonResolve(jdata["color_description_present_flag"], decoded_value.color_description_present_flag, options);
        FieldToJsonResolve(jdata["chroma_loc_info_present_flag"], decoded_value.chroma_loc_info_present_flag, options);
        FieldToJsonResolve(jdata["timing_info_present_flag"], decoded_value.timing_info_present_flag, options);
        FieldToJsonResolve(jdata["fixed_frame_rate_flag"], decoded_value.fixed_frame_rate_flag, options);
        FieldToJsonResolve(jdata["bitstream_restriction_flag"], decoded_value.bitstream_restriction_flag, options);
        FieldToJsonResolve(jdata["nal_hrd_parameters_present_flag"], decoded_value.nal_hrd_parameters_present_flag, options);
        FieldToJsonResolve(jdata["vcl_hrd_parameters_present_flag"], decoded_value.vcl_hrd_parameters_present_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SpsVuiFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264SpsVuiFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264HrdParameters>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264HrdParameters* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264HrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264HrdParameters& meta_struct = *data;

        FieldToJsonResolve(jdata["cpb_cnt_minus1"], decoded_value.cpb_cnt_minus1, options);
        FieldToJsonResolve(jdata["bit_rate_scale"], decoded_value.bit_rate_scale, options);
        FieldToJsonResolve(jdata["cpb_size_scale"], decoded_value.cpb_size_scale, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["bit_rate_value_minus1"], &meta_struct.bit_rate_value_minus1, options);
        FieldToJsonResolve(jdata["cpb_size_value_minus1"], &meta_struct.cpb_size_value_minus1, options);
        FieldToJsonResolve(jdata["cbr_flag"], &meta_struct.cbr_flag, options);
        FieldToJsonResolve(jdata["initial_cpb_removal_delay_length_minus1"], decoded_value.initial_cpb_removal_delay_length_minus1, options);
        FieldToJsonResolve(jdata["cpb_removal_delay_length_minus1"], decoded_value.cpb_removal_delay_length_minus1, options);
        FieldToJsonResolve(jdata["dpb_output_delay_length_minus1"], decoded_value.dpb_output_delay_length_minus1, options);
        FieldToJsonResolve(jdata["time_offset_length"], decoded_value.time_offset_length, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264HrdParameters* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264HrdParameters>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264SequenceParameterSetVui>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SequenceParameterSetVui* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SequenceParameterSetVui& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SequenceParameterSetVui& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["aspect_ratio_idc"], decoded_value.aspect_ratio_idc, options);
        FieldToJsonResolve(jdata["sar_width"], decoded_value.sar_width, options);
        FieldToJsonResolve(jdata["sar_height"], decoded_value.sar_height, options);
        FieldToJsonResolve(jdata["video_format"], decoded_value.video_format, options);
        FieldToJsonResolve(jdata["colour_primaries"], decoded_value.colour_primaries, options);
        FieldToJsonResolve(jdata["transfer_characteristics"], decoded_value.transfer_characteristics, options);
        FieldToJsonResolve(jdata["matrix_coefficients"], decoded_value.matrix_coefficients, options);
        FieldToJsonResolve(jdata["num_units_in_tick"], decoded_value.num_units_in_tick, options);
        FieldToJsonResolve(jdata["time_scale"], decoded_value.time_scale, options);
        FieldToJsonResolve(jdata["max_num_reorder_frames"], decoded_value.max_num_reorder_frames, options);
        FieldToJsonResolve(jdata["max_dec_frame_buffering"], decoded_value.max_dec_frame_buffering, options);
        FieldToJsonResolve(jdata["chroma_sample_loc_type_top_field"], decoded_value.chroma_sample_loc_type_top_field, options);
        FieldToJsonResolve(jdata["chroma_sample_loc_type_bottom_field"], decoded_value.chroma_sample_loc_type_bottom_field, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["pHrdParameters"], meta_struct.pHrdParameters, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SequenceParameterSetVui* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264SequenceParameterSetVui>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264SpsFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SpsFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SpsFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["constraint_set0_flag"], decoded_value.constraint_set0_flag, options);
        FieldToJsonResolve(jdata["constraint_set1_flag"], decoded_value.constraint_set1_flag, options);
        FieldToJsonResolve(jdata["constraint_set2_flag"], decoded_value.constraint_set2_flag, options);
        FieldToJsonResolve(jdata["constraint_set3_flag"], decoded_value.constraint_set3_flag, options);
        FieldToJsonResolve(jdata["constraint_set4_flag"], decoded_value.constraint_set4_flag, options);
        FieldToJsonResolve(jdata["constraint_set5_flag"], decoded_value.constraint_set5_flag, options);
        FieldToJsonResolve(jdata["direct_8x8_inference_flag"], decoded_value.direct_8x8_inference_flag, options);
        FieldToJsonResolve(jdata["mb_adaptive_frame_field_flag"], decoded_value.mb_adaptive_frame_field_flag, options);
        FieldToJsonResolve(jdata["frame_mbs_only_flag"], decoded_value.frame_mbs_only_flag, options);
        FieldToJsonResolve(jdata["delta_pic_order_always_zero_flag"], decoded_value.delta_pic_order_always_zero_flag, options);
        FieldToJsonResolve(jdata["separate_colour_plane_flag"], decoded_value.separate_colour_plane_flag, options);
        FieldToJsonResolve(jdata["gaps_in_frame_num_value_allowed_flag"], decoded_value.gaps_in_frame_num_value_allowed_flag, options);
        FieldToJsonResolve(jdata["qpprime_y_zero_transform_bypass_flag"], decoded_value.qpprime_y_zero_transform_bypass_flag, options);
        FieldToJsonResolve(jdata["frame_cropping_flag"], decoded_value.frame_cropping_flag, options);
        FieldToJsonResolve(jdata["seq_scaling_matrix_present_flag"], decoded_value.seq_scaling_matrix_present_flag, options);
        FieldToJsonResolve(jdata["vui_parameters_present_flag"], decoded_value.vui_parameters_present_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SpsFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264SpsFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264ScalingLists>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264ScalingLists* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264ScalingLists& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264ScalingLists& meta_struct = *data;

        FieldToJsonResolve(jdata["scaling_list_present_mask"], decoded_value.scaling_list_present_mask, options);
        FieldToJsonResolve(jdata["use_default_scaling_matrix_mask"], decoded_value.use_default_scaling_matrix_mask, options);
        FieldToJsonResolve(jdata["ScalingList4x4"], &meta_struct.ScalingList4x4, options);
        FieldToJsonResolve(jdata["ScalingList8x8"], &meta_struct.ScalingList8x8, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264ScalingLists* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264ScalingLists>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264SequenceParameterSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SequenceParameterSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264SequenceParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264SequenceParameterSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["profile_idc"], decoded_value.profile_idc, options);
        FieldToJsonResolve(jdata["level_idc"], decoded_value.level_idc, options);
        FieldToJsonResolve(jdata["chroma_format_idc"], decoded_value.chroma_format_idc, options);
        FieldToJsonResolve(jdata["seq_parameter_set_id"], decoded_value.seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["bit_depth_luma_minus8"], decoded_value.bit_depth_luma_minus8, options);
        FieldToJsonResolve(jdata["bit_depth_chroma_minus8"], decoded_value.bit_depth_chroma_minus8, options);
        FieldToJsonResolve(jdata["log2_max_frame_num_minus4"], decoded_value.log2_max_frame_num_minus4, options);
        FieldToJsonResolve(jdata["pic_order_cnt_type"], decoded_value.pic_order_cnt_type, options);
        FieldToJsonResolve(jdata["offset_for_non_ref_pic"], decoded_value.offset_for_non_ref_pic, options);
        FieldToJsonResolve(jdata["offset_for_top_to_bottom_field"], decoded_value.offset_for_top_to_bottom_field, options);
        FieldToJsonResolve(jdata["log2_max_pic_order_cnt_lsb_minus4"], decoded_value.log2_max_pic_order_cnt_lsb_minus4, options);
        FieldToJsonResolve(jdata["num_ref_frames_in_pic_order_cnt_cycle"], decoded_value.num_ref_frames_in_pic_order_cnt_cycle, options);
        FieldToJsonResolve(jdata["max_num_ref_frames"], decoded_value.max_num_ref_frames, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["pic_width_in_mbs_minus1"], decoded_value.pic_width_in_mbs_minus1, options);
        FieldToJsonResolve(jdata["pic_height_in_map_units_minus1"], decoded_value.pic_height_in_map_units_minus1, options);
        FieldToJsonResolve(jdata["frame_crop_left_offset"], decoded_value.frame_crop_left_offset, options);
        FieldToJsonResolve(jdata["frame_crop_right_offset"], decoded_value.frame_crop_right_offset, options);
        FieldToJsonResolve(jdata["frame_crop_top_offset"], decoded_value.frame_crop_top_offset, options);
        FieldToJsonResolve(jdata["frame_crop_bottom_offset"], decoded_value.frame_crop_bottom_offset, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["pOffsetForRefFrame"], meta_struct.pOffsetForRefFrame, options);
        FieldToJsonResolve(jdata["pScalingLists"], meta_struct.pScalingLists, options);
        FieldToJsonResolve(jdata["pSequenceParameterSetVui"], meta_struct.pSequenceParameterSetVui, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264SequenceParameterSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264SequenceParameterSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264PpsFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264PpsFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264PpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264PpsFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["transform_8x8_mode_flag"], decoded_value.transform_8x8_mode_flag, options);
        FieldToJsonResolve(jdata["redundant_pic_cnt_present_flag"], decoded_value.redundant_pic_cnt_present_flag, options);
        FieldToJsonResolve(jdata["constrained_intra_pred_flag"], decoded_value.constrained_intra_pred_flag, options);
        FieldToJsonResolve(jdata["deblocking_filter_control_present_flag"], decoded_value.deblocking_filter_control_present_flag, options);
        FieldToJsonResolve(jdata["weighted_pred_flag"], decoded_value.weighted_pred_flag, options);
        FieldToJsonResolve(jdata["bottom_field_pic_order_in_frame_present_flag"], decoded_value.bottom_field_pic_order_in_frame_present_flag, options);
        FieldToJsonResolve(jdata["entropy_coding_mode_flag"], decoded_value.entropy_coding_mode_flag, options);
        FieldToJsonResolve(jdata["pic_scaling_matrix_present_flag"], decoded_value.pic_scaling_matrix_present_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264PpsFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264PpsFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH264PictureParameterSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264PictureParameterSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH264PictureParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH264PictureParameterSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["seq_parameter_set_id"], decoded_value.seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["pic_parameter_set_id"], decoded_value.pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["num_ref_idx_l0_default_active_minus1"], decoded_value.num_ref_idx_l0_default_active_minus1, options);
        FieldToJsonResolve(jdata["num_ref_idx_l1_default_active_minus1"], decoded_value.num_ref_idx_l1_default_active_minus1, options);
        FieldToJsonResolve(jdata["weighted_bipred_idc"], decoded_value.weighted_bipred_idc, options);
        FieldToJsonResolve(jdata["pic_init_qp_minus26"], decoded_value.pic_init_qp_minus26, options);
        FieldToJsonResolve(jdata["pic_init_qs_minus26"], decoded_value.pic_init_qs_minus26, options);
        FieldToJsonResolve(jdata["chroma_qp_index_offset"], decoded_value.chroma_qp_index_offset, options);
        FieldToJsonResolve(jdata["second_chroma_qp_index_offset"], decoded_value.second_chroma_qp_index_offset, options);
        FieldToJsonResolve(jdata["pScalingLists"], meta_struct.pScalingLists, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH264PictureParameterSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH264PictureParameterSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH264PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["field_pic_flag"], decoded_value.field_pic_flag, options);
        FieldToJsonResolve(jdata["is_intra"], decoded_value.is_intra, options);
        FieldToJsonResolve(jdata["IdrPicFlag"], decoded_value.IdrPicFlag, options);
        FieldToJsonResolve(jdata["bottom_field_flag"], decoded_value.bottom_field_flag, options);
        FieldToJsonResolve(jdata["is_reference"], decoded_value.is_reference, options);
        FieldToJsonResolve(jdata["complementary_field_pair"], decoded_value.complementary_field_pair, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH264PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH264PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["seq_parameter_set_id"], decoded_value.seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["pic_parameter_set_id"], decoded_value.pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["frame_num"], decoded_value.frame_num, options);
        FieldToJsonResolve(jdata["idr_pic_id"], decoded_value.idr_pic_id, options);
        FieldToJsonResolve(jdata["PicOrderCnt"], &meta_struct.PicOrderCnt, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH264PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH264ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["top_field_flag"], decoded_value.top_field_flag, options);
        FieldToJsonResolve(jdata["bottom_field_flag"], decoded_value.bottom_field_flag, options);
        FieldToJsonResolve(jdata["used_for_long_term_reference"], decoded_value.used_for_long_term_reference, options);
        FieldToJsonResolve(jdata["is_non_existing"], decoded_value.is_non_existing, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH264ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH264ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH264ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH264ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["FrameNum"], decoded_value.FrameNum, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
        FieldToJsonResolve(jdata["PicOrderCnt"], &meta_struct.PicOrderCnt, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH264ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH264ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264WeightTableFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264WeightTableFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264WeightTableFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264WeightTableFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["luma_weight_l0_flag"], decoded_value.luma_weight_l0_flag, options);
        FieldToJsonResolve(jdata["chroma_weight_l0_flag"], decoded_value.chroma_weight_l0_flag, options);
        FieldToJsonResolve(jdata["luma_weight_l1_flag"], decoded_value.luma_weight_l1_flag, options);
        FieldToJsonResolve(jdata["chroma_weight_l1_flag"], decoded_value.chroma_weight_l1_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264WeightTableFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264WeightTableFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264WeightTable>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264WeightTable* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264WeightTable& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264WeightTable& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["luma_log2_weight_denom"], decoded_value.luma_log2_weight_denom, options);
        FieldToJsonResolve(jdata["chroma_log2_weight_denom"], decoded_value.chroma_log2_weight_denom, options);
        FieldToJsonResolve(jdata["luma_weight_l0"], &meta_struct.luma_weight_l0, options);
        FieldToJsonResolve(jdata["luma_offset_l0"], &meta_struct.luma_offset_l0, options);
        FieldToJsonResolve(jdata["chroma_weight_l0"], &meta_struct.chroma_weight_l0, options);
        FieldToJsonResolve(jdata["chroma_offset_l0"], &meta_struct.chroma_offset_l0, options);
        FieldToJsonResolve(jdata["luma_weight_l1"], &meta_struct.luma_weight_l1, options);
        FieldToJsonResolve(jdata["luma_offset_l1"], &meta_struct.luma_offset_l1, options);
        FieldToJsonResolve(jdata["chroma_weight_l1"], &meta_struct.chroma_weight_l1, options);
        FieldToJsonResolve(jdata["chroma_offset_l1"], &meta_struct.chroma_offset_l1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264WeightTable* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264WeightTable>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264SliceHeaderFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264SliceHeaderFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264SliceHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264SliceHeaderFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["direct_spatial_mv_pred_flag"], decoded_value.direct_spatial_mv_pred_flag, options);
        FieldToJsonResolve(jdata["num_ref_idx_active_override_flag"], decoded_value.num_ref_idx_active_override_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264SliceHeaderFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264SliceHeaderFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["IdrPicFlag"], decoded_value.IdrPicFlag, options);
        FieldToJsonResolve(jdata["is_reference"], decoded_value.is_reference, options);
        FieldToJsonResolve(jdata["no_output_of_prior_pics_flag"], decoded_value.no_output_of_prior_pics_flag, options);
        FieldToJsonResolve(jdata["long_term_reference_flag"], decoded_value.long_term_reference_flag, options);
        FieldToJsonResolve(jdata["adaptive_ref_pic_marking_mode_flag"], decoded_value.adaptive_ref_pic_marking_mode_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["used_for_long_term_reference"], decoded_value.used_for_long_term_reference, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceListsInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceListsInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceListsInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["ref_pic_list_modification_flag_l0"], decoded_value.ref_pic_list_modification_flag_l0, options);
        FieldToJsonResolve(jdata["ref_pic_list_modification_flag_l1"], decoded_value.ref_pic_list_modification_flag_l1, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceListsInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264RefListModEntry>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264RefListModEntry* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264RefListModEntry& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264RefListModEntry& meta_struct = *data;

        FieldToJsonResolve(jdata["modification_of_pic_nums_idc"], decoded_value.modification_of_pic_nums_idc, options);
        FieldToJsonResolve(jdata["abs_diff_pic_num_minus1"], decoded_value.abs_diff_pic_num_minus1, options);
        FieldToJsonResolve(jdata["long_term_pic_num"], decoded_value.long_term_pic_num, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264RefListModEntry* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264RefListModEntry>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264RefPicMarkingEntry>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264RefPicMarkingEntry* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264RefPicMarkingEntry& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264RefPicMarkingEntry& meta_struct = *data;

        FieldToJsonResolve(jdata["memory_management_control_operation"], decoded_value.memory_management_control_operation, options);
        FieldToJsonResolve(jdata["difference_of_pic_nums_minus1"], decoded_value.difference_of_pic_nums_minus1, options);
        FieldToJsonResolve(jdata["long_term_pic_num"], decoded_value.long_term_pic_num, options);
        FieldToJsonResolve(jdata["long_term_frame_idx"], decoded_value.long_term_frame_idx, options);
        FieldToJsonResolve(jdata["max_long_term_frame_idx_plus1"], decoded_value.max_long_term_frame_idx_plus1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264RefPicMarkingEntry* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264RefPicMarkingEntry>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceListsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceListsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceListsInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceListsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["num_ref_idx_l0_active_minus1"], decoded_value.num_ref_idx_l0_active_minus1, options);
        FieldToJsonResolve(jdata["num_ref_idx_l1_active_minus1"], decoded_value.num_ref_idx_l1_active_minus1, options);
        FieldToJsonResolve(jdata["RefPicList0"], &meta_struct.RefPicList0, options);
        FieldToJsonResolve(jdata["RefPicList1"], &meta_struct.RefPicList1, options);
        FieldToJsonResolve(jdata["refList0ModOpCount"], decoded_value.refList0ModOpCount, options);
        FieldToJsonResolve(jdata["refList1ModOpCount"], decoded_value.refList1ModOpCount, options);
        FieldToJsonResolve(jdata["refPicMarkingOpCount"], decoded_value.refPicMarkingOpCount, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pRefList0ModOperations"], meta_struct.pRefList0ModOperations, options);
        FieldToJsonResolve(jdata["pRefList1ModOperations"], meta_struct.pRefList1ModOperations, options);
        FieldToJsonResolve(jdata["pRefPicMarkingOperations"], meta_struct.pRefPicMarkingOperations, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceListsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceListsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["seq_parameter_set_id"], decoded_value.seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["pic_parameter_set_id"], decoded_value.pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["idr_pic_id"], decoded_value.idr_pic_id, options);
        FieldToJsonResolve(jdata["primary_pic_type"], decoded_value.primary_pic_type, options);
        FieldToJsonResolve(jdata["frame_num"], decoded_value.frame_num, options);
        FieldToJsonResolve(jdata["PicOrderCnt"], decoded_value.PicOrderCnt, options);
        FieldToJsonResolve(jdata["temporal_id"], decoded_value.temporal_id, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pRefLists"], meta_struct.pRefLists, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["primary_pic_type"], decoded_value.primary_pic_type, options);
        FieldToJsonResolve(jdata["FrameNum"], decoded_value.FrameNum, options);
        FieldToJsonResolve(jdata["PicOrderCnt"], decoded_value.PicOrderCnt, options);
        FieldToJsonResolve(jdata["long_term_pic_num"], decoded_value.long_term_pic_num, options);
        FieldToJsonResolve(jdata["long_term_frame_idx"], decoded_value.long_term_frame_idx, options);
        FieldToJsonResolve(jdata["temporal_id"], decoded_value.temporal_id, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH264SliceHeader>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264SliceHeader* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH264SliceHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH264SliceHeader& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["first_mb_in_slice"], decoded_value.first_mb_in_slice, options);
        FieldToJsonResolve(jdata["slice_type"], decoded_value.slice_type, options);
        FieldToJsonResolve(jdata["slice_alpha_c0_offset_div2"], decoded_value.slice_alpha_c0_offset_div2, options);
        FieldToJsonResolve(jdata["slice_beta_offset_div2"], decoded_value.slice_beta_offset_div2, options);
        FieldToJsonResolve(jdata["slice_qp_delta"], decoded_value.slice_qp_delta, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["cabac_init_idc"], decoded_value.cabac_init_idc, options);
        FieldToJsonResolve(jdata["disable_deblocking_filter_idc"], decoded_value.disable_deblocking_filter_idc, options);
        FieldToJsonResolve(jdata["pWeightTable"], meta_struct.pWeightTable, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH264SliceHeader* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH264SliceHeader>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265ProfileTierLevelFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ProfileTierLevelFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ProfileTierLevelFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ProfileTierLevelFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["general_tier_flag"], decoded_value.general_tier_flag, options);
        FieldToJsonResolve(jdata["general_progressive_source_flag"], decoded_value.general_progressive_source_flag, options);
        FieldToJsonResolve(jdata["general_interlaced_source_flag"], decoded_value.general_interlaced_source_flag, options);
        FieldToJsonResolve(jdata["general_non_packed_constraint_flag"], decoded_value.general_non_packed_constraint_flag, options);
        FieldToJsonResolve(jdata["general_frame_only_constraint_flag"], decoded_value.general_frame_only_constraint_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ProfileTierLevelFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265ProfileTierLevelFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265ProfileTierLevel>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ProfileTierLevel* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ProfileTierLevel& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ProfileTierLevel& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["general_profile_idc"], decoded_value.general_profile_idc, options);
        FieldToJsonResolve(jdata["general_level_idc"], decoded_value.general_level_idc, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ProfileTierLevel* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265ProfileTierLevel>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265DecPicBufMgr>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265DecPicBufMgr* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265DecPicBufMgr& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265DecPicBufMgr& meta_struct = *data;

        FieldToJsonResolve(jdata["max_latency_increase_plus1"], &meta_struct.max_latency_increase_plus1, options);
        FieldToJsonResolve(jdata["max_dec_pic_buffering_minus1"], &meta_struct.max_dec_pic_buffering_minus1, options);
        FieldToJsonResolve(jdata["max_num_reorder_pics"], &meta_struct.max_num_reorder_pics, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265DecPicBufMgr* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265DecPicBufMgr>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265SubLayerHrdParameters>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SubLayerHrdParameters* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SubLayerHrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SubLayerHrdParameters& meta_struct = *data;

        FieldToJsonResolve(jdata["bit_rate_value_minus1"], &meta_struct.bit_rate_value_minus1, options);
        FieldToJsonResolve(jdata["cpb_size_value_minus1"], &meta_struct.cpb_size_value_minus1, options);
        FieldToJsonResolve(jdata["cpb_size_du_value_minus1"], &meta_struct.cpb_size_du_value_minus1, options);
        FieldToJsonResolve(jdata["bit_rate_du_value_minus1"], &meta_struct.bit_rate_du_value_minus1, options);
        FieldToJsonResolve(jdata["cbr_flag"], decoded_value.cbr_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SubLayerHrdParameters* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265SubLayerHrdParameters>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265HrdFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265HrdFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265HrdFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265HrdFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["nal_hrd_parameters_present_flag"], decoded_value.nal_hrd_parameters_present_flag, options);
        FieldToJsonResolve(jdata["vcl_hrd_parameters_present_flag"], decoded_value.vcl_hrd_parameters_present_flag, options);
        FieldToJsonResolve(jdata["sub_pic_hrd_params_present_flag"], decoded_value.sub_pic_hrd_params_present_flag, options);
        FieldToJsonResolve(jdata["sub_pic_cpb_params_in_pic_timing_sei_flag"], decoded_value.sub_pic_cpb_params_in_pic_timing_sei_flag, options);
        FieldToJsonResolve(jdata["fixed_pic_rate_general_flag"], decoded_value.fixed_pic_rate_general_flag, options);
        FieldToJsonResolve(jdata["fixed_pic_rate_within_cvs_flag"], decoded_value.fixed_pic_rate_within_cvs_flag, options);
        FieldToJsonResolve(jdata["low_delay_hrd_flag"], decoded_value.low_delay_hrd_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265HrdFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265HrdFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265HrdParameters>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265HrdParameters* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265HrdParameters& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265HrdParameters& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["tick_divisor_minus2"], decoded_value.tick_divisor_minus2, options);
        FieldToJsonResolve(jdata["du_cpb_removal_delay_increment_length_minus1"], decoded_value.du_cpb_removal_delay_increment_length_minus1, options);
        FieldToJsonResolve(jdata["dpb_output_delay_du_length_minus1"], decoded_value.dpb_output_delay_du_length_minus1, options);
        FieldToJsonResolve(jdata["bit_rate_scale"], decoded_value.bit_rate_scale, options);
        FieldToJsonResolve(jdata["cpb_size_scale"], decoded_value.cpb_size_scale, options);
        FieldToJsonResolve(jdata["cpb_size_du_scale"], decoded_value.cpb_size_du_scale, options);
        FieldToJsonResolve(jdata["initial_cpb_removal_delay_length_minus1"], decoded_value.initial_cpb_removal_delay_length_minus1, options);
        FieldToJsonResolve(jdata["au_cpb_removal_delay_length_minus1"], decoded_value.au_cpb_removal_delay_length_minus1, options);
        FieldToJsonResolve(jdata["dpb_output_delay_length_minus1"], decoded_value.dpb_output_delay_length_minus1, options);
        FieldToJsonResolve(jdata["cpb_cnt_minus1"], &meta_struct.cpb_cnt_minus1, options);
        FieldToJsonResolve(jdata["elemental_duration_in_tc_minus1"], &meta_struct.elemental_duration_in_tc_minus1, options);
        FieldToJsonResolve(jdata["reserved"], &meta_struct.reserved, options);
        FieldToJsonResolve(jdata["pSubLayerHrdParametersNal"], meta_struct.pSubLayerHrdParametersNal, options);
        FieldToJsonResolve(jdata["pSubLayerHrdParametersVcl"], meta_struct.pSubLayerHrdParametersVcl, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265HrdParameters* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265HrdParameters>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265VpsFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265VpsFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265VpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265VpsFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["vps_temporal_id_nesting_flag"], decoded_value.vps_temporal_id_nesting_flag, options);
        FieldToJsonResolve(jdata["vps_sub_layer_ordering_info_present_flag"], decoded_value.vps_sub_layer_ordering_info_present_flag, options);
        FieldToJsonResolve(jdata["vps_timing_info_present_flag"], decoded_value.vps_timing_info_present_flag, options);
        FieldToJsonResolve(jdata["vps_poc_proportional_to_timing_flag"], decoded_value.vps_poc_proportional_to_timing_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265VpsFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265VpsFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265VideoParameterSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265VideoParameterSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265VideoParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265VideoParameterSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["vps_video_parameter_set_id"], decoded_value.vps_video_parameter_set_id, options);
        FieldToJsonResolve(jdata["vps_max_sub_layers_minus1"], decoded_value.vps_max_sub_layers_minus1, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["vps_num_units_in_tick"], decoded_value.vps_num_units_in_tick, options);
        FieldToJsonResolve(jdata["vps_time_scale"], decoded_value.vps_time_scale, options);
        FieldToJsonResolve(jdata["vps_num_ticks_poc_diff_one_minus1"], decoded_value.vps_num_ticks_poc_diff_one_minus1, options);
        FieldToJsonResolve(jdata["reserved3"], decoded_value.reserved3, options);
        FieldToJsonResolve(jdata["pDecPicBufMgr"], meta_struct.pDecPicBufMgr, options);
        FieldToJsonResolve(jdata["pHrdParameters"], meta_struct.pHrdParameters, options);
        FieldToJsonResolve(jdata["pProfileTierLevel"], meta_struct.pProfileTierLevel, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265VideoParameterSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265VideoParameterSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265ScalingLists>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ScalingLists* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ScalingLists& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ScalingLists& meta_struct = *data;

        FieldToJsonResolve(jdata["ScalingList4x4"], &meta_struct.ScalingList4x4, options);
        FieldToJsonResolve(jdata["ScalingList8x8"], &meta_struct.ScalingList8x8, options);
        FieldToJsonResolve(jdata["ScalingList16x16"], &meta_struct.ScalingList16x16, options);
        FieldToJsonResolve(jdata["ScalingList32x32"], &meta_struct.ScalingList32x32, options);
        FieldToJsonResolve(jdata["ScalingListDCCoef16x16"], &meta_struct.ScalingListDCCoef16x16, options);
        FieldToJsonResolve(jdata["ScalingListDCCoef32x32"], &meta_struct.ScalingListDCCoef32x32, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ScalingLists* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265ScalingLists>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265ShortTermRefPicSetFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ShortTermRefPicSetFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ShortTermRefPicSetFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ShortTermRefPicSetFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["inter_ref_pic_set_prediction_flag"], decoded_value.inter_ref_pic_set_prediction_flag, options);
        FieldToJsonResolve(jdata["delta_rps_sign"], decoded_value.delta_rps_sign, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ShortTermRefPicSetFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265ShortTermRefPicSetFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265ShortTermRefPicSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ShortTermRefPicSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265ShortTermRefPicSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265ShortTermRefPicSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["delta_idx_minus1"], decoded_value.delta_idx_minus1, options);
        FieldToJsonResolve(jdata["use_delta_flag"], decoded_value.use_delta_flag, options);
        FieldToJsonResolve(jdata["abs_delta_rps_minus1"], decoded_value.abs_delta_rps_minus1, options);
        FieldToJsonResolve(jdata["used_by_curr_pic_flag"], decoded_value.used_by_curr_pic_flag, options);
        FieldToJsonResolve(jdata["used_by_curr_pic_s0_flag"], decoded_value.used_by_curr_pic_s0_flag, options);
        FieldToJsonResolve(jdata["used_by_curr_pic_s1_flag"], decoded_value.used_by_curr_pic_s1_flag, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["reserved3"], decoded_value.reserved3, options);
        FieldToJsonResolve(jdata["num_negative_pics"], decoded_value.num_negative_pics, options);
        FieldToJsonResolve(jdata["num_positive_pics"], decoded_value.num_positive_pics, options);
        FieldToJsonResolve(jdata["delta_poc_s0_minus1"], &meta_struct.delta_poc_s0_minus1, options);
        FieldToJsonResolve(jdata["delta_poc_s1_minus1"], &meta_struct.delta_poc_s1_minus1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265ShortTermRefPicSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265ShortTermRefPicSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265LongTermRefPicsSps>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265LongTermRefPicsSps* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265LongTermRefPicsSps& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265LongTermRefPicsSps& meta_struct = *data;

        FieldToJsonResolve(jdata["used_by_curr_pic_lt_sps_flag"], decoded_value.used_by_curr_pic_lt_sps_flag, options);
        FieldToJsonResolve(jdata["lt_ref_pic_poc_lsb_sps"], &meta_struct.lt_ref_pic_poc_lsb_sps, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265LongTermRefPicsSps* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265LongTermRefPicsSps>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265SpsVuiFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SpsVuiFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SpsVuiFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SpsVuiFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["aspect_ratio_info_present_flag"], decoded_value.aspect_ratio_info_present_flag, options);
        FieldToJsonResolve(jdata["overscan_info_present_flag"], decoded_value.overscan_info_present_flag, options);
        FieldToJsonResolve(jdata["overscan_appropriate_flag"], decoded_value.overscan_appropriate_flag, options);
        FieldToJsonResolve(jdata["video_signal_type_present_flag"], decoded_value.video_signal_type_present_flag, options);
        FieldToJsonResolve(jdata["video_full_range_flag"], decoded_value.video_full_range_flag, options);
        FieldToJsonResolve(jdata["colour_description_present_flag"], decoded_value.colour_description_present_flag, options);
        FieldToJsonResolve(jdata["chroma_loc_info_present_flag"], decoded_value.chroma_loc_info_present_flag, options);
        FieldToJsonResolve(jdata["neutral_chroma_indication_flag"], decoded_value.neutral_chroma_indication_flag, options);
        FieldToJsonResolve(jdata["field_seq_flag"], decoded_value.field_seq_flag, options);
        FieldToJsonResolve(jdata["frame_field_info_present_flag"], decoded_value.frame_field_info_present_flag, options);
        FieldToJsonResolve(jdata["default_display_window_flag"], decoded_value.default_display_window_flag, options);
        FieldToJsonResolve(jdata["vui_timing_info_present_flag"], decoded_value.vui_timing_info_present_flag, options);
        FieldToJsonResolve(jdata["vui_poc_proportional_to_timing_flag"], decoded_value.vui_poc_proportional_to_timing_flag, options);
        FieldToJsonResolve(jdata["vui_hrd_parameters_present_flag"], decoded_value.vui_hrd_parameters_present_flag, options);
        FieldToJsonResolve(jdata["bitstream_restriction_flag"], decoded_value.bitstream_restriction_flag, options);
        FieldToJsonResolve(jdata["tiles_fixed_structure_flag"], decoded_value.tiles_fixed_structure_flag, options);
        FieldToJsonResolve(jdata["motion_vectors_over_pic_boundaries_flag"], decoded_value.motion_vectors_over_pic_boundaries_flag, options);
        FieldToJsonResolve(jdata["restricted_ref_pic_lists_flag"], decoded_value.restricted_ref_pic_lists_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SpsVuiFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265SpsVuiFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265SequenceParameterSetVui>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SequenceParameterSetVui* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SequenceParameterSetVui& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SequenceParameterSetVui& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["aspect_ratio_idc"], decoded_value.aspect_ratio_idc, options);
        FieldToJsonResolve(jdata["sar_width"], decoded_value.sar_width, options);
        FieldToJsonResolve(jdata["sar_height"], decoded_value.sar_height, options);
        FieldToJsonResolve(jdata["video_format"], decoded_value.video_format, options);
        FieldToJsonResolve(jdata["colour_primaries"], decoded_value.colour_primaries, options);
        FieldToJsonResolve(jdata["transfer_characteristics"], decoded_value.transfer_characteristics, options);
        FieldToJsonResolve(jdata["matrix_coeffs"], decoded_value.matrix_coeffs, options);
        FieldToJsonResolve(jdata["chroma_sample_loc_type_top_field"], decoded_value.chroma_sample_loc_type_top_field, options);
        FieldToJsonResolve(jdata["chroma_sample_loc_type_bottom_field"], decoded_value.chroma_sample_loc_type_bottom_field, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["def_disp_win_left_offset"], decoded_value.def_disp_win_left_offset, options);
        FieldToJsonResolve(jdata["def_disp_win_right_offset"], decoded_value.def_disp_win_right_offset, options);
        FieldToJsonResolve(jdata["def_disp_win_top_offset"], decoded_value.def_disp_win_top_offset, options);
        FieldToJsonResolve(jdata["def_disp_win_bottom_offset"], decoded_value.def_disp_win_bottom_offset, options);
        FieldToJsonResolve(jdata["vui_num_units_in_tick"], decoded_value.vui_num_units_in_tick, options);
        FieldToJsonResolve(jdata["vui_time_scale"], decoded_value.vui_time_scale, options);
        FieldToJsonResolve(jdata["vui_num_ticks_poc_diff_one_minus1"], decoded_value.vui_num_ticks_poc_diff_one_minus1, options);
        FieldToJsonResolve(jdata["min_spatial_segmentation_idc"], decoded_value.min_spatial_segmentation_idc, options);
        FieldToJsonResolve(jdata["reserved3"], decoded_value.reserved3, options);
        FieldToJsonResolve(jdata["max_bytes_per_pic_denom"], decoded_value.max_bytes_per_pic_denom, options);
        FieldToJsonResolve(jdata["max_bits_per_min_cu_denom"], decoded_value.max_bits_per_min_cu_denom, options);
        FieldToJsonResolve(jdata["log2_max_mv_length_horizontal"], decoded_value.log2_max_mv_length_horizontal, options);
        FieldToJsonResolve(jdata["log2_max_mv_length_vertical"], decoded_value.log2_max_mv_length_vertical, options);
        FieldToJsonResolve(jdata["pHrdParameters"], meta_struct.pHrdParameters, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SequenceParameterSetVui* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265SequenceParameterSetVui>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265PredictorPaletteEntries>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PredictorPaletteEntries* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PredictorPaletteEntries& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PredictorPaletteEntries& meta_struct = *data;

        FieldToJsonResolve(jdata["PredictorPaletteEntries"], &meta_struct.PredictorPaletteEntries, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PredictorPaletteEntries* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265PredictorPaletteEntries>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265SpsFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SpsFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SpsFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["sps_temporal_id_nesting_flag"], decoded_value.sps_temporal_id_nesting_flag, options);
        FieldToJsonResolve(jdata["separate_colour_plane_flag"], decoded_value.separate_colour_plane_flag, options);
        FieldToJsonResolve(jdata["conformance_window_flag"], decoded_value.conformance_window_flag, options);
        FieldToJsonResolve(jdata["sps_sub_layer_ordering_info_present_flag"], decoded_value.sps_sub_layer_ordering_info_present_flag, options);
        FieldToJsonResolve(jdata["scaling_list_enabled_flag"], decoded_value.scaling_list_enabled_flag, options);
        FieldToJsonResolve(jdata["sps_scaling_list_data_present_flag"], decoded_value.sps_scaling_list_data_present_flag, options);
        FieldToJsonResolve(jdata["amp_enabled_flag"], decoded_value.amp_enabled_flag, options);
        FieldToJsonResolve(jdata["sample_adaptive_offset_enabled_flag"], decoded_value.sample_adaptive_offset_enabled_flag, options);
        FieldToJsonResolve(jdata["pcm_enabled_flag"], decoded_value.pcm_enabled_flag, options);
        FieldToJsonResolve(jdata["pcm_loop_filter_disabled_flag"], decoded_value.pcm_loop_filter_disabled_flag, options);
        FieldToJsonResolve(jdata["long_term_ref_pics_present_flag"], decoded_value.long_term_ref_pics_present_flag, options);
        FieldToJsonResolve(jdata["sps_temporal_mvp_enabled_flag"], decoded_value.sps_temporal_mvp_enabled_flag, options);
        FieldToJsonResolve(jdata["strong_intra_smoothing_enabled_flag"], decoded_value.strong_intra_smoothing_enabled_flag, options);
        FieldToJsonResolve(jdata["vui_parameters_present_flag"], decoded_value.vui_parameters_present_flag, options);
        FieldToJsonResolve(jdata["sps_extension_present_flag"], decoded_value.sps_extension_present_flag, options);
        FieldToJsonResolve(jdata["sps_range_extension_flag"], decoded_value.sps_range_extension_flag, options);
        FieldToJsonResolve(jdata["transform_skip_rotation_enabled_flag"], decoded_value.transform_skip_rotation_enabled_flag, options);
        FieldToJsonResolve(jdata["transform_skip_context_enabled_flag"], decoded_value.transform_skip_context_enabled_flag, options);
        FieldToJsonResolve(jdata["implicit_rdpcm_enabled_flag"], decoded_value.implicit_rdpcm_enabled_flag, options);
        FieldToJsonResolve(jdata["explicit_rdpcm_enabled_flag"], decoded_value.explicit_rdpcm_enabled_flag, options);
        FieldToJsonResolve(jdata["extended_precision_processing_flag"], decoded_value.extended_precision_processing_flag, options);
        FieldToJsonResolve(jdata["intra_smoothing_disabled_flag"], decoded_value.intra_smoothing_disabled_flag, options);
        FieldToJsonResolve(jdata["high_precision_offsets_enabled_flag"], decoded_value.high_precision_offsets_enabled_flag, options);
        FieldToJsonResolve(jdata["persistent_rice_adaptation_enabled_flag"], decoded_value.persistent_rice_adaptation_enabled_flag, options);
        FieldToJsonResolve(jdata["cabac_bypass_alignment_enabled_flag"], decoded_value.cabac_bypass_alignment_enabled_flag, options);
        FieldToJsonResolve(jdata["sps_scc_extension_flag"], decoded_value.sps_scc_extension_flag, options);
        FieldToJsonResolve(jdata["sps_curr_pic_ref_enabled_flag"], decoded_value.sps_curr_pic_ref_enabled_flag, options);
        FieldToJsonResolve(jdata["palette_mode_enabled_flag"], decoded_value.palette_mode_enabled_flag, options);
        FieldToJsonResolve(jdata["sps_palette_predictor_initializers_present_flag"], decoded_value.sps_palette_predictor_initializers_present_flag, options);
        FieldToJsonResolve(jdata["intra_boundary_filtering_disabled_flag"], decoded_value.intra_boundary_filtering_disabled_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SpsFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265SpsFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265SequenceParameterSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SequenceParameterSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265SequenceParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265SequenceParameterSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["chroma_format_idc"], decoded_value.chroma_format_idc, options);
        FieldToJsonResolve(jdata["pic_width_in_luma_samples"], decoded_value.pic_width_in_luma_samples, options);
        FieldToJsonResolve(jdata["pic_height_in_luma_samples"], decoded_value.pic_height_in_luma_samples, options);
        FieldToJsonResolve(jdata["sps_video_parameter_set_id"], decoded_value.sps_video_parameter_set_id, options);
        FieldToJsonResolve(jdata["sps_max_sub_layers_minus1"], decoded_value.sps_max_sub_layers_minus1, options);
        FieldToJsonResolve(jdata["sps_seq_parameter_set_id"], decoded_value.sps_seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["bit_depth_luma_minus8"], decoded_value.bit_depth_luma_minus8, options);
        FieldToJsonResolve(jdata["bit_depth_chroma_minus8"], decoded_value.bit_depth_chroma_minus8, options);
        FieldToJsonResolve(jdata["log2_max_pic_order_cnt_lsb_minus4"], decoded_value.log2_max_pic_order_cnt_lsb_minus4, options);
        FieldToJsonResolve(jdata["log2_min_luma_coding_block_size_minus3"], decoded_value.log2_min_luma_coding_block_size_minus3, options);
        FieldToJsonResolve(jdata["log2_diff_max_min_luma_coding_block_size"], decoded_value.log2_diff_max_min_luma_coding_block_size, options);
        FieldToJsonResolve(jdata["log2_min_luma_transform_block_size_minus2"], decoded_value.log2_min_luma_transform_block_size_minus2, options);
        FieldToJsonResolve(jdata["log2_diff_max_min_luma_transform_block_size"], decoded_value.log2_diff_max_min_luma_transform_block_size, options);
        FieldToJsonResolve(jdata["max_transform_hierarchy_depth_inter"], decoded_value.max_transform_hierarchy_depth_inter, options);
        FieldToJsonResolve(jdata["max_transform_hierarchy_depth_intra"], decoded_value.max_transform_hierarchy_depth_intra, options);
        FieldToJsonResolve(jdata["num_short_term_ref_pic_sets"], decoded_value.num_short_term_ref_pic_sets, options);
        FieldToJsonResolve(jdata["num_long_term_ref_pics_sps"], decoded_value.num_long_term_ref_pics_sps, options);
        FieldToJsonResolve(jdata["pcm_sample_bit_depth_luma_minus1"], decoded_value.pcm_sample_bit_depth_luma_minus1, options);
        FieldToJsonResolve(jdata["pcm_sample_bit_depth_chroma_minus1"], decoded_value.pcm_sample_bit_depth_chroma_minus1, options);
        FieldToJsonResolve(jdata["log2_min_pcm_luma_coding_block_size_minus3"], decoded_value.log2_min_pcm_luma_coding_block_size_minus3, options);
        FieldToJsonResolve(jdata["log2_diff_max_min_pcm_luma_coding_block_size"], decoded_value.log2_diff_max_min_pcm_luma_coding_block_size, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["palette_max_size"], decoded_value.palette_max_size, options);
        FieldToJsonResolve(jdata["delta_palette_max_predictor_size"], decoded_value.delta_palette_max_predictor_size, options);
        FieldToJsonResolve(jdata["motion_vector_resolution_control_idc"], decoded_value.motion_vector_resolution_control_idc, options);
        FieldToJsonResolve(jdata["sps_num_palette_predictor_initializers_minus1"], decoded_value.sps_num_palette_predictor_initializers_minus1, options);
        FieldToJsonResolve(jdata["conf_win_left_offset"], decoded_value.conf_win_left_offset, options);
        FieldToJsonResolve(jdata["conf_win_right_offset"], decoded_value.conf_win_right_offset, options);
        FieldToJsonResolve(jdata["conf_win_top_offset"], decoded_value.conf_win_top_offset, options);
        FieldToJsonResolve(jdata["conf_win_bottom_offset"], decoded_value.conf_win_bottom_offset, options);
        FieldToJsonResolve(jdata["pProfileTierLevel"], meta_struct.pProfileTierLevel, options);
        FieldToJsonResolve(jdata["pDecPicBufMgr"], meta_struct.pDecPicBufMgr, options);
        FieldToJsonResolve(jdata["pScalingLists"], meta_struct.pScalingLists, options);
        FieldToJsonResolve(jdata["pShortTermRefPicSet"], meta_struct.pShortTermRefPicSet, options);
        FieldToJsonResolve(jdata["pLongTermRefPicsSps"], meta_struct.pLongTermRefPicsSps, options);
        FieldToJsonResolve(jdata["pSequenceParameterSetVui"], meta_struct.pSequenceParameterSetVui, options);
        FieldToJsonResolve(jdata["pPredictorPaletteEntries"], meta_struct.pPredictorPaletteEntries, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265SequenceParameterSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265SequenceParameterSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265PpsFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PpsFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PpsFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PpsFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["dependent_slice_segments_enabled_flag"], decoded_value.dependent_slice_segments_enabled_flag, options);
        FieldToJsonResolve(jdata["output_flag_present_flag"], decoded_value.output_flag_present_flag, options);
        FieldToJsonResolve(jdata["sign_data_hiding_enabled_flag"], decoded_value.sign_data_hiding_enabled_flag, options);
        FieldToJsonResolve(jdata["cabac_init_present_flag"], decoded_value.cabac_init_present_flag, options);
        FieldToJsonResolve(jdata["constrained_intra_pred_flag"], decoded_value.constrained_intra_pred_flag, options);
        FieldToJsonResolve(jdata["transform_skip_enabled_flag"], decoded_value.transform_skip_enabled_flag, options);
        FieldToJsonResolve(jdata["cu_qp_delta_enabled_flag"], decoded_value.cu_qp_delta_enabled_flag, options);
        FieldToJsonResolve(jdata["pps_slice_chroma_qp_offsets_present_flag"], decoded_value.pps_slice_chroma_qp_offsets_present_flag, options);
        FieldToJsonResolve(jdata["weighted_pred_flag"], decoded_value.weighted_pred_flag, options);
        FieldToJsonResolve(jdata["weighted_bipred_flag"], decoded_value.weighted_bipred_flag, options);
        FieldToJsonResolve(jdata["transquant_bypass_enabled_flag"], decoded_value.transquant_bypass_enabled_flag, options);
        FieldToJsonResolve(jdata["tiles_enabled_flag"], decoded_value.tiles_enabled_flag, options);
        FieldToJsonResolve(jdata["entropy_coding_sync_enabled_flag"], decoded_value.entropy_coding_sync_enabled_flag, options);
        FieldToJsonResolve(jdata["uniform_spacing_flag"], decoded_value.uniform_spacing_flag, options);
        FieldToJsonResolve(jdata["loop_filter_across_tiles_enabled_flag"], decoded_value.loop_filter_across_tiles_enabled_flag, options);
        FieldToJsonResolve(jdata["pps_loop_filter_across_slices_enabled_flag"], decoded_value.pps_loop_filter_across_slices_enabled_flag, options);
        FieldToJsonResolve(jdata["deblocking_filter_control_present_flag"], decoded_value.deblocking_filter_control_present_flag, options);
        FieldToJsonResolve(jdata["deblocking_filter_override_enabled_flag"], decoded_value.deblocking_filter_override_enabled_flag, options);
        FieldToJsonResolve(jdata["pps_deblocking_filter_disabled_flag"], decoded_value.pps_deblocking_filter_disabled_flag, options);
        FieldToJsonResolve(jdata["pps_scaling_list_data_present_flag"], decoded_value.pps_scaling_list_data_present_flag, options);
        FieldToJsonResolve(jdata["lists_modification_present_flag"], decoded_value.lists_modification_present_flag, options);
        FieldToJsonResolve(jdata["slice_segment_header_extension_present_flag"], decoded_value.slice_segment_header_extension_present_flag, options);
        FieldToJsonResolve(jdata["pps_extension_present_flag"], decoded_value.pps_extension_present_flag, options);
        FieldToJsonResolve(jdata["cross_component_prediction_enabled_flag"], decoded_value.cross_component_prediction_enabled_flag, options);
        FieldToJsonResolve(jdata["chroma_qp_offset_list_enabled_flag"], decoded_value.chroma_qp_offset_list_enabled_flag, options);
        FieldToJsonResolve(jdata["pps_curr_pic_ref_enabled_flag"], decoded_value.pps_curr_pic_ref_enabled_flag, options);
        FieldToJsonResolve(jdata["residual_adaptive_colour_transform_enabled_flag"], decoded_value.residual_adaptive_colour_transform_enabled_flag, options);
        FieldToJsonResolve(jdata["pps_slice_act_qp_offsets_present_flag"], decoded_value.pps_slice_act_qp_offsets_present_flag, options);
        FieldToJsonResolve(jdata["pps_palette_predictor_initializers_present_flag"], decoded_value.pps_palette_predictor_initializers_present_flag, options);
        FieldToJsonResolve(jdata["monochrome_palette_flag"], decoded_value.monochrome_palette_flag, options);
        FieldToJsonResolve(jdata["pps_range_extension_flag"], decoded_value.pps_range_extension_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PpsFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265PpsFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoH265PictureParameterSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PictureParameterSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoH265PictureParameterSet& decoded_value = *data->decoded_value;
        const Decoded_StdVideoH265PictureParameterSet& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["pps_pic_parameter_set_id"], decoded_value.pps_pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["pps_seq_parameter_set_id"], decoded_value.pps_seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["sps_video_parameter_set_id"], decoded_value.sps_video_parameter_set_id, options);
        FieldToJsonResolve(jdata["num_extra_slice_header_bits"], decoded_value.num_extra_slice_header_bits, options);
        FieldToJsonResolve(jdata["num_ref_idx_l0_default_active_minus1"], decoded_value.num_ref_idx_l0_default_active_minus1, options);
        FieldToJsonResolve(jdata["num_ref_idx_l1_default_active_minus1"], decoded_value.num_ref_idx_l1_default_active_minus1, options);
        FieldToJsonResolve(jdata["init_qp_minus26"], decoded_value.init_qp_minus26, options);
        FieldToJsonResolve(jdata["diff_cu_qp_delta_depth"], decoded_value.diff_cu_qp_delta_depth, options);
        FieldToJsonResolve(jdata["pps_cb_qp_offset"], decoded_value.pps_cb_qp_offset, options);
        FieldToJsonResolve(jdata["pps_cr_qp_offset"], decoded_value.pps_cr_qp_offset, options);
        FieldToJsonResolve(jdata["pps_beta_offset_div2"], decoded_value.pps_beta_offset_div2, options);
        FieldToJsonResolve(jdata["pps_tc_offset_div2"], decoded_value.pps_tc_offset_div2, options);
        FieldToJsonResolve(jdata["log2_parallel_merge_level_minus2"], decoded_value.log2_parallel_merge_level_minus2, options);
        FieldToJsonResolve(jdata["log2_max_transform_skip_block_size_minus2"], decoded_value.log2_max_transform_skip_block_size_minus2, options);
        FieldToJsonResolve(jdata["diff_cu_chroma_qp_offset_depth"], decoded_value.diff_cu_chroma_qp_offset_depth, options);
        FieldToJsonResolve(jdata["chroma_qp_offset_list_len_minus1"], decoded_value.chroma_qp_offset_list_len_minus1, options);
        FieldToJsonResolve(jdata["cb_qp_offset_list"], &meta_struct.cb_qp_offset_list, options);
        FieldToJsonResolve(jdata["cr_qp_offset_list"], &meta_struct.cr_qp_offset_list, options);
        FieldToJsonResolve(jdata["log2_sao_offset_scale_luma"], decoded_value.log2_sao_offset_scale_luma, options);
        FieldToJsonResolve(jdata["log2_sao_offset_scale_chroma"], decoded_value.log2_sao_offset_scale_chroma, options);
        FieldToJsonResolve(jdata["pps_act_y_qp_offset_plus5"], decoded_value.pps_act_y_qp_offset_plus5, options);
        FieldToJsonResolve(jdata["pps_act_cb_qp_offset_plus5"], decoded_value.pps_act_cb_qp_offset_plus5, options);
        FieldToJsonResolve(jdata["pps_act_cr_qp_offset_plus3"], decoded_value.pps_act_cr_qp_offset_plus3, options);
        FieldToJsonResolve(jdata["pps_num_palette_predictor_initializers"], decoded_value.pps_num_palette_predictor_initializers, options);
        FieldToJsonResolve(jdata["luma_bit_depth_entry_minus8"], decoded_value.luma_bit_depth_entry_minus8, options);
        FieldToJsonResolve(jdata["chroma_bit_depth_entry_minus8"], decoded_value.chroma_bit_depth_entry_minus8, options);
        FieldToJsonResolve(jdata["num_tile_columns_minus1"], decoded_value.num_tile_columns_minus1, options);
        FieldToJsonResolve(jdata["num_tile_rows_minus1"], decoded_value.num_tile_rows_minus1, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["reserved2"], decoded_value.reserved2, options);
        FieldToJsonResolve(jdata["column_width_minus1"], &meta_struct.column_width_minus1, options);
        FieldToJsonResolve(jdata["row_height_minus1"], &meta_struct.row_height_minus1, options);
        FieldToJsonResolve(jdata["reserved3"], decoded_value.reserved3, options);
        FieldToJsonResolve(jdata["pScalingLists"], meta_struct.pScalingLists, options);
        FieldToJsonResolve(jdata["pPredictorPaletteEntries"], meta_struct.pPredictorPaletteEntries, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoH265PictureParameterSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoH265PictureParameterSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH265PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["IrapPicFlag"], decoded_value.IrapPicFlag, options);
        FieldToJsonResolve(jdata["IdrPicFlag"], decoded_value.IdrPicFlag, options);
        FieldToJsonResolve(jdata["IsReference"], decoded_value.IsReference, options);
        FieldToJsonResolve(jdata["short_term_ref_pic_set_sps_flag"], decoded_value.short_term_ref_pic_set_sps_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH265PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH265PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["sps_video_parameter_set_id"], decoded_value.sps_video_parameter_set_id, options);
        FieldToJsonResolve(jdata["pps_seq_parameter_set_id"], decoded_value.pps_seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["pps_pic_parameter_set_id"], decoded_value.pps_pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["NumDeltaPocsOfRefRpsIdx"], decoded_value.NumDeltaPocsOfRefRpsIdx, options);
        FieldToJsonResolve(jdata["PicOrderCntVal"], decoded_value.PicOrderCntVal, options);
        FieldToJsonResolve(jdata["NumBitsForSTRefPicSetInSlice"], decoded_value.NumBitsForSTRefPicSetInSlice, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
        FieldToJsonResolve(jdata["RefPicSetStCurrBefore"], &meta_struct.RefPicSetStCurrBefore, options);
        FieldToJsonResolve(jdata["RefPicSetStCurrAfter"], &meta_struct.RefPicSetStCurrAfter, options);
        FieldToJsonResolve(jdata["RefPicSetLtCurr"], &meta_struct.RefPicSetLtCurr, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH265PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH265ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["used_for_long_term_reference"], decoded_value.used_for_long_term_reference, options);
        FieldToJsonResolve(jdata["unused_for_reference"], decoded_value.unused_for_reference, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH265ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeH265ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeH265ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeH265ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["PicOrderCntVal"], decoded_value.PicOrderCntVal, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeH265ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeH265ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265WeightTableFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265WeightTableFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265WeightTableFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265WeightTableFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["luma_weight_l0_flag"], decoded_value.luma_weight_l0_flag, options);
        FieldToJsonResolve(jdata["chroma_weight_l0_flag"], decoded_value.chroma_weight_l0_flag, options);
        FieldToJsonResolve(jdata["luma_weight_l1_flag"], decoded_value.luma_weight_l1_flag, options);
        FieldToJsonResolve(jdata["chroma_weight_l1_flag"], decoded_value.chroma_weight_l1_flag, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265WeightTableFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265WeightTableFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265WeightTable>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265WeightTable* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265WeightTable& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265WeightTable& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["luma_log2_weight_denom"], decoded_value.luma_log2_weight_denom, options);
        FieldToJsonResolve(jdata["delta_chroma_log2_weight_denom"], decoded_value.delta_chroma_log2_weight_denom, options);
        FieldToJsonResolve(jdata["delta_luma_weight_l0"], &meta_struct.delta_luma_weight_l0, options);
        FieldToJsonResolve(jdata["luma_offset_l0"], &meta_struct.luma_offset_l0, options);
        FieldToJsonResolve(jdata["delta_chroma_weight_l0"], &meta_struct.delta_chroma_weight_l0, options);
        FieldToJsonResolve(jdata["delta_chroma_offset_l0"], &meta_struct.delta_chroma_offset_l0, options);
        FieldToJsonResolve(jdata["delta_luma_weight_l1"], &meta_struct.delta_luma_weight_l1, options);
        FieldToJsonResolve(jdata["luma_offset_l1"], &meta_struct.luma_offset_l1, options);
        FieldToJsonResolve(jdata["delta_chroma_weight_l1"], &meta_struct.delta_chroma_weight_l1, options);
        FieldToJsonResolve(jdata["delta_chroma_offset_l1"], &meta_struct.delta_chroma_offset_l1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265WeightTable* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265WeightTable>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265LongTermRefPics>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265LongTermRefPics* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265LongTermRefPics& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265LongTermRefPics& meta_struct = *data;

        FieldToJsonResolve(jdata["num_long_term_sps"], decoded_value.num_long_term_sps, options);
        FieldToJsonResolve(jdata["num_long_term_pics"], decoded_value.num_long_term_pics, options);
        FieldToJsonResolve(jdata["lt_idx_sps"], &meta_struct.lt_idx_sps, options);
        FieldToJsonResolve(jdata["poc_lsb_lt"], &meta_struct.poc_lsb_lt, options);
        FieldToJsonResolve(jdata["used_by_curr_pic_lt_flag"], decoded_value.used_by_curr_pic_lt_flag, options);
        FieldToJsonResolve(jdata["delta_poc_msb_present_flag"], &meta_struct.delta_poc_msb_present_flag, options);
        FieldToJsonResolve(jdata["delta_poc_msb_cycle_lt"], &meta_struct.delta_poc_msb_cycle_lt, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265LongTermRefPics* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265LongTermRefPics>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265SliceSegmentHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["first_slice_segment_in_pic_flag"], decoded_value.first_slice_segment_in_pic_flag, options);
        FieldToJsonResolve(jdata["dependent_slice_segment_flag"], decoded_value.dependent_slice_segment_flag, options);
        FieldToJsonResolve(jdata["slice_sao_luma_flag"], decoded_value.slice_sao_luma_flag, options);
        FieldToJsonResolve(jdata["slice_sao_chroma_flag"], decoded_value.slice_sao_chroma_flag, options);
        FieldToJsonResolve(jdata["num_ref_idx_active_override_flag"], decoded_value.num_ref_idx_active_override_flag, options);
        FieldToJsonResolve(jdata["mvd_l1_zero_flag"], decoded_value.mvd_l1_zero_flag, options);
        FieldToJsonResolve(jdata["cabac_init_flag"], decoded_value.cabac_init_flag, options);
        FieldToJsonResolve(jdata["cu_chroma_qp_offset_enabled_flag"], decoded_value.cu_chroma_qp_offset_enabled_flag, options);
        FieldToJsonResolve(jdata["deblocking_filter_override_flag"], decoded_value.deblocking_filter_override_flag, options);
        FieldToJsonResolve(jdata["slice_deblocking_filter_disabled_flag"], decoded_value.slice_deblocking_filter_disabled_flag, options);
        FieldToJsonResolve(jdata["collocated_from_l0_flag"], decoded_value.collocated_from_l0_flag, options);
        FieldToJsonResolve(jdata["slice_loop_filter_across_slices_enabled_flag"], decoded_value.slice_loop_filter_across_slices_enabled_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265SliceSegmentHeader>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265SliceSegmentHeader* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265SliceSegmentHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265SliceSegmentHeader& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["slice_type"], decoded_value.slice_type, options);
        FieldToJsonResolve(jdata["slice_segment_address"], decoded_value.slice_segment_address, options);
        FieldToJsonResolve(jdata["collocated_ref_idx"], decoded_value.collocated_ref_idx, options);
        FieldToJsonResolve(jdata["MaxNumMergeCand"], decoded_value.MaxNumMergeCand, options);
        FieldToJsonResolve(jdata["slice_cb_qp_offset"], decoded_value.slice_cb_qp_offset, options);
        FieldToJsonResolve(jdata["slice_cr_qp_offset"], decoded_value.slice_cr_qp_offset, options);
        FieldToJsonResolve(jdata["slice_beta_offset_div2"], decoded_value.slice_beta_offset_div2, options);
        FieldToJsonResolve(jdata["slice_tc_offset_div2"], decoded_value.slice_tc_offset_div2, options);
        FieldToJsonResolve(jdata["slice_act_y_qp_offset"], decoded_value.slice_act_y_qp_offset, options);
        FieldToJsonResolve(jdata["slice_act_cb_qp_offset"], decoded_value.slice_act_cb_qp_offset, options);
        FieldToJsonResolve(jdata["slice_act_cr_qp_offset"], decoded_value.slice_act_cr_qp_offset, options);
        FieldToJsonResolve(jdata["slice_qp_delta"], decoded_value.slice_qp_delta, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["pWeightTable"], meta_struct.pWeightTable, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265SliceSegmentHeader* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265SliceSegmentHeader>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceListsInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceListsInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceListsInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceListsInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["ref_pic_list_modification_flag_l0"], decoded_value.ref_pic_list_modification_flag_l0, options);
        FieldToJsonResolve(jdata["ref_pic_list_modification_flag_l1"], decoded_value.ref_pic_list_modification_flag_l1, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceListsInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceListsInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceListsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceListsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceListsInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceListsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["num_ref_idx_l0_active_minus1"], decoded_value.num_ref_idx_l0_active_minus1, options);
        FieldToJsonResolve(jdata["num_ref_idx_l1_active_minus1"], decoded_value.num_ref_idx_l1_active_minus1, options);
        FieldToJsonResolve(jdata["RefPicList0"], &meta_struct.RefPicList0, options);
        FieldToJsonResolve(jdata["RefPicList1"], &meta_struct.RefPicList1, options);
        FieldToJsonResolve(jdata["list_entry_l0"], &meta_struct.list_entry_l0, options);
        FieldToJsonResolve(jdata["list_entry_l1"], &meta_struct.list_entry_l1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceListsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceListsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["is_reference"], decoded_value.is_reference, options);
        FieldToJsonResolve(jdata["IrapPicFlag"], decoded_value.IrapPicFlag, options);
        FieldToJsonResolve(jdata["used_for_long_term_reference"], decoded_value.used_for_long_term_reference, options);
        FieldToJsonResolve(jdata["discardable_flag"], decoded_value.discardable_flag, options);
        FieldToJsonResolve(jdata["cross_layer_bla_flag"], decoded_value.cross_layer_bla_flag, options);
        FieldToJsonResolve(jdata["pic_output_flag"], decoded_value.pic_output_flag, options);
        FieldToJsonResolve(jdata["no_output_of_prior_pics_flag"], decoded_value.no_output_of_prior_pics_flag, options);
        FieldToJsonResolve(jdata["short_term_ref_pic_set_sps_flag"], decoded_value.short_term_ref_pic_set_sps_flag, options);
        FieldToJsonResolve(jdata["slice_temporal_mvp_enabled_flag"], decoded_value.slice_temporal_mvp_enabled_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["pic_type"], decoded_value.pic_type, options);
        FieldToJsonResolve(jdata["sps_video_parameter_set_id"], decoded_value.sps_video_parameter_set_id, options);
        FieldToJsonResolve(jdata["pps_seq_parameter_set_id"], decoded_value.pps_seq_parameter_set_id, options);
        FieldToJsonResolve(jdata["pps_pic_parameter_set_id"], decoded_value.pps_pic_parameter_set_id, options);
        FieldToJsonResolve(jdata["short_term_ref_pic_set_idx"], decoded_value.short_term_ref_pic_set_idx, options);
        FieldToJsonResolve(jdata["PicOrderCntVal"], decoded_value.PicOrderCntVal, options);
        FieldToJsonResolve(jdata["TemporalId"], decoded_value.TemporalId, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pRefLists"], meta_struct.pRefLists, options);
        FieldToJsonResolve(jdata["pShortTermRefPicSet"], meta_struct.pShortTermRefPicSet, options);
        FieldToJsonResolve(jdata["pLongTermRefPics"], meta_struct.pLongTermRefPics, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["used_for_long_term_reference"], decoded_value.used_for_long_term_reference, options);
        FieldToJsonResolve(jdata["unused_for_reference"], decoded_value.unused_for_reference, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeH265ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeH265ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["pic_type"], decoded_value.pic_type, options);
        FieldToJsonResolve(jdata["PicOrderCntVal"], decoded_value.PicOrderCntVal, options);
        FieldToJsonResolve(jdata["TemporalId"], decoded_value.TemporalId, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeH265ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeH265ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9ColorConfigFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9ColorConfigFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9ColorConfigFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9ColorConfigFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["color_range"], decoded_value.color_range, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9ColorConfigFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9ColorConfigFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9ColorConfig>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9ColorConfig* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9ColorConfig& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9ColorConfig& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["BitDepth"], decoded_value.BitDepth, options);
        FieldToJsonResolve(jdata["subsampling_x"], decoded_value.subsampling_x, options);
        FieldToJsonResolve(jdata["subsampling_y"], decoded_value.subsampling_y, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["color_space"], decoded_value.color_space, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9ColorConfig* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9ColorConfig>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9LoopFilterFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9LoopFilterFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9LoopFilterFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9LoopFilterFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["loop_filter_delta_enabled"], decoded_value.loop_filter_delta_enabled, options);
        FieldToJsonResolve(jdata["loop_filter_delta_update"], decoded_value.loop_filter_delta_update, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9LoopFilterFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9LoopFilterFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9LoopFilter>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9LoopFilter* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9LoopFilter& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9LoopFilter& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["loop_filter_level"], decoded_value.loop_filter_level, options);
        FieldToJsonResolve(jdata["loop_filter_sharpness"], decoded_value.loop_filter_sharpness, options);
        FieldToJsonResolve(jdata["update_ref_delta"], decoded_value.update_ref_delta, options);
        FieldToJsonResolve(jdata["loop_filter_ref_deltas"], &meta_struct.loop_filter_ref_deltas, options);
        FieldToJsonResolve(jdata["update_mode_delta"], decoded_value.update_mode_delta, options);
        FieldToJsonResolve(jdata["loop_filter_mode_deltas"], &meta_struct.loop_filter_mode_deltas, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9LoopFilter* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9LoopFilter>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9SegmentationFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9SegmentationFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9SegmentationFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9SegmentationFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["segmentation_update_map"], decoded_value.segmentation_update_map, options);
        FieldToJsonResolve(jdata["segmentation_temporal_update"], decoded_value.segmentation_temporal_update, options);
        FieldToJsonResolve(jdata["segmentation_update_data"], decoded_value.segmentation_update_data, options);
        FieldToJsonResolve(jdata["segmentation_abs_or_delta_update"], decoded_value.segmentation_abs_or_delta_update, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9SegmentationFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9SegmentationFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoVP9Segmentation>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9Segmentation* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoVP9Segmentation& decoded_value = *data->decoded_value;
        const Decoded_StdVideoVP9Segmentation& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["segmentation_tree_probs"], &meta_struct.segmentation_tree_probs, options);
        FieldToJsonResolve(jdata["segmentation_pred_prob"], &meta_struct.segmentation_pred_prob, options);
        FieldToJsonResolve(jdata["FeatureEnabled"], &meta_struct.FeatureEnabled, options);
        FieldToJsonResolve(jdata["FeatureData"], &meta_struct.FeatureData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoVP9Segmentation* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoVP9Segmentation>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeVP9PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeVP9PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeVP9PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeVP9PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["error_resilient_mode"], decoded_value.error_resilient_mode, options);
        FieldToJsonResolve(jdata["intra_only"], decoded_value.intra_only, options);
        FieldToJsonResolve(jdata["allow_high_precision_mv"], decoded_value.allow_high_precision_mv, options);
        FieldToJsonResolve(jdata["refresh_frame_context"], decoded_value.refresh_frame_context, options);
        FieldToJsonResolve(jdata["frame_parallel_decoding_mode"], decoded_value.frame_parallel_decoding_mode, options);
        FieldToJsonResolve(jdata["segmentation_enabled"], decoded_value.segmentation_enabled, options);
        FieldToJsonResolve(jdata["show_frame"], decoded_value.show_frame, options);
        FieldToJsonResolve(jdata["UsePrevFrameMvs"], decoded_value.UsePrevFrameMvs, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeVP9PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeVP9PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeVP9PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeVP9PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeVP9PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeVP9PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["profile"], decoded_value.profile, options);
        FieldToJsonResolve(jdata["frame_type"], decoded_value.frame_type, options);
        FieldToJsonResolve(jdata["frame_context_idx"], decoded_value.frame_context_idx, options);
        FieldToJsonResolve(jdata["reset_frame_context"], decoded_value.reset_frame_context, options);
        FieldToJsonResolve(jdata["refresh_frame_flags"], decoded_value.refresh_frame_flags, options);
        FieldToJsonResolve(jdata["ref_frame_sign_bias_mask"], decoded_value.ref_frame_sign_bias_mask, options);
        FieldToJsonResolve(jdata["interpolation_filter"], decoded_value.interpolation_filter, options);
        FieldToJsonResolve(jdata["base_q_idx"], decoded_value.base_q_idx, options);
        FieldToJsonResolve(jdata["delta_q_y_dc"], decoded_value.delta_q_y_dc, options);
        FieldToJsonResolve(jdata["delta_q_uv_dc"], decoded_value.delta_q_uv_dc, options);
        FieldToJsonResolve(jdata["delta_q_uv_ac"], decoded_value.delta_q_uv_ac, options);
        FieldToJsonResolve(jdata["tile_cols_log2"], decoded_value.tile_cols_log2, options);
        FieldToJsonResolve(jdata["tile_rows_log2"], decoded_value.tile_rows_log2, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pColorConfig"], meta_struct.pColorConfig, options);
        FieldToJsonResolve(jdata["pLoopFilter"], meta_struct.pLoopFilter, options);
        FieldToJsonResolve(jdata["pSegmentation"], meta_struct.pSegmentation, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeVP9PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeVP9PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1ColorConfigFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1ColorConfigFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1ColorConfigFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1ColorConfigFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["mono_chrome"], decoded_value.mono_chrome, options);
        FieldToJsonResolve(jdata["color_range"], decoded_value.color_range, options);
        FieldToJsonResolve(jdata["separate_uv_delta_q"], decoded_value.separate_uv_delta_q, options);
        FieldToJsonResolve(jdata["color_description_present_flag"], decoded_value.color_description_present_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1ColorConfigFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1ColorConfigFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1ColorConfig>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1ColorConfig* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1ColorConfig& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1ColorConfig& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["BitDepth"], decoded_value.BitDepth, options);
        FieldToJsonResolve(jdata["subsampling_x"], decoded_value.subsampling_x, options);
        FieldToJsonResolve(jdata["subsampling_y"], decoded_value.subsampling_y, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["color_primaries"], decoded_value.color_primaries, options);
        FieldToJsonResolve(jdata["transfer_characteristics"], decoded_value.transfer_characteristics, options);
        FieldToJsonResolve(jdata["matrix_coefficients"], decoded_value.matrix_coefficients, options);
        FieldToJsonResolve(jdata["chroma_sample_position"], decoded_value.chroma_sample_position, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1ColorConfig* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1ColorConfig>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1TimingInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TimingInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TimingInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TimingInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["equal_picture_interval"], decoded_value.equal_picture_interval, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TimingInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1TimingInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1TimingInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TimingInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TimingInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TimingInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["num_units_in_display_tick"], decoded_value.num_units_in_display_tick, options);
        FieldToJsonResolve(jdata["time_scale"], decoded_value.time_scale, options);
        FieldToJsonResolve(jdata["num_ticks_per_picture_minus_1"], decoded_value.num_ticks_per_picture_minus_1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TimingInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1TimingInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1SequenceHeaderFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1SequenceHeaderFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1SequenceHeaderFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1SequenceHeaderFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["still_picture"], decoded_value.still_picture, options);
        FieldToJsonResolve(jdata["reduced_still_picture_header"], decoded_value.reduced_still_picture_header, options);
        FieldToJsonResolve(jdata["use_128x128_superblock"], decoded_value.use_128x128_superblock, options);
        FieldToJsonResolve(jdata["enable_filter_intra"], decoded_value.enable_filter_intra, options);
        FieldToJsonResolve(jdata["enable_intra_edge_filter"], decoded_value.enable_intra_edge_filter, options);
        FieldToJsonResolve(jdata["enable_interintra_compound"], decoded_value.enable_interintra_compound, options);
        FieldToJsonResolve(jdata["enable_masked_compound"], decoded_value.enable_masked_compound, options);
        FieldToJsonResolve(jdata["enable_warped_motion"], decoded_value.enable_warped_motion, options);
        FieldToJsonResolve(jdata["enable_dual_filter"], decoded_value.enable_dual_filter, options);
        FieldToJsonResolve(jdata["enable_order_hint"], decoded_value.enable_order_hint, options);
        FieldToJsonResolve(jdata["enable_jnt_comp"], decoded_value.enable_jnt_comp, options);
        FieldToJsonResolve(jdata["enable_ref_frame_mvs"], decoded_value.enable_ref_frame_mvs, options);
        FieldToJsonResolve(jdata["frame_id_numbers_present_flag"], decoded_value.frame_id_numbers_present_flag, options);
        FieldToJsonResolve(jdata["enable_superres"], decoded_value.enable_superres, options);
        FieldToJsonResolve(jdata["enable_cdef"], decoded_value.enable_cdef, options);
        FieldToJsonResolve(jdata["enable_restoration"], decoded_value.enable_restoration, options);
        FieldToJsonResolve(jdata["film_grain_params_present"], decoded_value.film_grain_params_present, options);
        FieldToJsonResolve(jdata["timing_info_present_flag"], decoded_value.timing_info_present_flag, options);
        FieldToJsonResolve(jdata["initial_display_delay_present_flag"], decoded_value.initial_display_delay_present_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1SequenceHeaderFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1SequenceHeaderFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1SequenceHeader>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1SequenceHeader* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1SequenceHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1SequenceHeader& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["seq_profile"], decoded_value.seq_profile, options);
        FieldToJsonResolve(jdata["frame_width_bits_minus_1"], decoded_value.frame_width_bits_minus_1, options);
        FieldToJsonResolve(jdata["frame_height_bits_minus_1"], decoded_value.frame_height_bits_minus_1, options);
        FieldToJsonResolve(jdata["max_frame_width_minus_1"], decoded_value.max_frame_width_minus_1, options);
        FieldToJsonResolve(jdata["max_frame_height_minus_1"], decoded_value.max_frame_height_minus_1, options);
        FieldToJsonResolve(jdata["delta_frame_id_length_minus_2"], decoded_value.delta_frame_id_length_minus_2, options);
        FieldToJsonResolve(jdata["additional_frame_id_length_minus_1"], decoded_value.additional_frame_id_length_minus_1, options);
        FieldToJsonResolve(jdata["order_hint_bits_minus_1"], decoded_value.order_hint_bits_minus_1, options);
        FieldToJsonResolve(jdata["seq_force_integer_mv"], decoded_value.seq_force_integer_mv, options);
        FieldToJsonResolve(jdata["seq_force_screen_content_tools"], decoded_value.seq_force_screen_content_tools, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pColorConfig"], meta_struct.pColorConfig, options);
        FieldToJsonResolve(jdata["pTimingInfo"], meta_struct.pTimingInfo, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1SequenceHeader* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1SequenceHeader>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1LoopFilterFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopFilterFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopFilterFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopFilterFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["loop_filter_delta_enabled"], decoded_value.loop_filter_delta_enabled, options);
        FieldToJsonResolve(jdata["loop_filter_delta_update"], decoded_value.loop_filter_delta_update, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopFilterFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1LoopFilterFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1LoopFilter>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopFilter* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopFilter& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopFilter& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["loop_filter_level"], &meta_struct.loop_filter_level, options);
        FieldToJsonResolve(jdata["loop_filter_sharpness"], decoded_value.loop_filter_sharpness, options);
        FieldToJsonResolve(jdata["update_ref_delta"], decoded_value.update_ref_delta, options);
        FieldToJsonResolve(jdata["loop_filter_ref_deltas"], &meta_struct.loop_filter_ref_deltas, options);
        FieldToJsonResolve(jdata["update_mode_delta"], decoded_value.update_mode_delta, options);
        FieldToJsonResolve(jdata["loop_filter_mode_deltas"], &meta_struct.loop_filter_mode_deltas, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopFilter* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1LoopFilter>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1QuantizationFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1QuantizationFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1QuantizationFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1QuantizationFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["using_qmatrix"], decoded_value.using_qmatrix, options);
        FieldToJsonResolve(jdata["diff_uv_delta"], decoded_value.diff_uv_delta, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1QuantizationFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1QuantizationFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1Quantization>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1Quantization* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1Quantization& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1Quantization& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["base_q_idx"], decoded_value.base_q_idx, options);
        FieldToJsonResolve(jdata["DeltaQYDc"], decoded_value.DeltaQYDc, options);
        FieldToJsonResolve(jdata["DeltaQUDc"], decoded_value.DeltaQUDc, options);
        FieldToJsonResolve(jdata["DeltaQUAc"], decoded_value.DeltaQUAc, options);
        FieldToJsonResolve(jdata["DeltaQVDc"], decoded_value.DeltaQVDc, options);
        FieldToJsonResolve(jdata["DeltaQVAc"], decoded_value.DeltaQVAc, options);
        FieldToJsonResolve(jdata["qm_y"], decoded_value.qm_y, options);
        FieldToJsonResolve(jdata["qm_u"], decoded_value.qm_u, options);
        FieldToJsonResolve(jdata["qm_v"], decoded_value.qm_v, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1Quantization* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1Quantization>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1Segmentation>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1Segmentation* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1Segmentation& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1Segmentation& meta_struct = *data;

        FieldToJsonResolve(jdata["FeatureEnabled"], &meta_struct.FeatureEnabled, options);
        FieldToJsonResolve(jdata["FeatureData"], &meta_struct.FeatureData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1Segmentation* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1Segmentation>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1TileInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TileInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TileInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TileInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["uniform_tile_spacing_flag"], decoded_value.uniform_tile_spacing_flag, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TileInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1TileInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1TileInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TileInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1TileInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1TileInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["TileCols"], decoded_value.TileCols, options);
        FieldToJsonResolve(jdata["TileRows"], decoded_value.TileRows, options);
        FieldToJsonResolve(jdata["context_update_tile_id"], decoded_value.context_update_tile_id, options);
        FieldToJsonResolve(jdata["tile_size_bytes_minus_1"], decoded_value.tile_size_bytes_minus_1, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pMiColStarts"], meta_struct.pMiColStarts, options);
        FieldToJsonResolve(jdata["pMiRowStarts"], meta_struct.pMiRowStarts, options);
        FieldToJsonResolve(jdata["pWidthInSbsMinus1"], meta_struct.pWidthInSbsMinus1, options);
        FieldToJsonResolve(jdata["pHeightInSbsMinus1"], meta_struct.pHeightInSbsMinus1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1TileInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1TileInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1CDEF>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1CDEF* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1CDEF& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1CDEF& meta_struct = *data;

        FieldToJsonResolve(jdata["cdef_damping_minus_3"], decoded_value.cdef_damping_minus_3, options);
        FieldToJsonResolve(jdata["cdef_bits"], decoded_value.cdef_bits, options);
        FieldToJsonResolve(jdata["cdef_y_pri_strength"], &meta_struct.cdef_y_pri_strength, options);
        FieldToJsonResolve(jdata["cdef_y_sec_strength"], &meta_struct.cdef_y_sec_strength, options);
        FieldToJsonResolve(jdata["cdef_uv_pri_strength"], &meta_struct.cdef_uv_pri_strength, options);
        FieldToJsonResolve(jdata["cdef_uv_sec_strength"], &meta_struct.cdef_uv_sec_strength, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1CDEF* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1CDEF>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1LoopRestoration>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopRestoration* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1LoopRestoration& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1LoopRestoration& meta_struct = *data;

        FieldToJsonResolve(jdata["FrameRestorationType"], &meta_struct.FrameRestorationType, options);
        FieldToJsonResolve(jdata["LoopRestorationSize"], &meta_struct.LoopRestorationSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1LoopRestoration* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1LoopRestoration>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1GlobalMotion>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1GlobalMotion* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1GlobalMotion& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1GlobalMotion& meta_struct = *data;

        FieldToJsonResolve(jdata["GmType"], &meta_struct.GmType, options);
        FieldToJsonResolve(jdata["gm_params"], &meta_struct.gm_params, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1GlobalMotion* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1GlobalMotion>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1FilmGrainFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1FilmGrainFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1FilmGrainFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1FilmGrainFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["chroma_scaling_from_luma"], decoded_value.chroma_scaling_from_luma, options);
        FieldToJsonResolve(jdata["overlap_flag"], decoded_value.overlap_flag, options);
        FieldToJsonResolve(jdata["clip_to_restricted_range"], decoded_value.clip_to_restricted_range, options);
        FieldToJsonResolve(jdata["update_grain"], decoded_value.update_grain, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1FilmGrainFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1FilmGrainFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoAV1FilmGrain>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1FilmGrain* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoAV1FilmGrain& decoded_value = *data->decoded_value;
        const Decoded_StdVideoAV1FilmGrain& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["grain_scaling_minus_8"], decoded_value.grain_scaling_minus_8, options);
        FieldToJsonResolve(jdata["ar_coeff_lag"], decoded_value.ar_coeff_lag, options);
        FieldToJsonResolve(jdata["ar_coeff_shift_minus_6"], decoded_value.ar_coeff_shift_minus_6, options);
        FieldToJsonResolve(jdata["grain_scale_shift"], decoded_value.grain_scale_shift, options);
        FieldToJsonResolve(jdata["grain_seed"], decoded_value.grain_seed, options);
        FieldToJsonResolve(jdata["film_grain_params_ref_idx"], decoded_value.film_grain_params_ref_idx, options);
        FieldToJsonResolve(jdata["num_y_points"], decoded_value.num_y_points, options);
        FieldToJsonResolve(jdata["point_y_value"], &meta_struct.point_y_value, options);
        FieldToJsonResolve(jdata["point_y_scaling"], &meta_struct.point_y_scaling, options);
        FieldToJsonResolve(jdata["num_cb_points"], decoded_value.num_cb_points, options);
        FieldToJsonResolve(jdata["point_cb_value"], &meta_struct.point_cb_value, options);
        FieldToJsonResolve(jdata["point_cb_scaling"], &meta_struct.point_cb_scaling, options);
        FieldToJsonResolve(jdata["num_cr_points"], decoded_value.num_cr_points, options);
        FieldToJsonResolve(jdata["point_cr_value"], &meta_struct.point_cr_value, options);
        FieldToJsonResolve(jdata["point_cr_scaling"], &meta_struct.point_cr_scaling, options);
        FieldToJsonResolve(jdata["ar_coeffs_y_plus_128"], &meta_struct.ar_coeffs_y_plus_128, options);
        FieldToJsonResolve(jdata["ar_coeffs_cb_plus_128"], &meta_struct.ar_coeffs_cb_plus_128, options);
        FieldToJsonResolve(jdata["ar_coeffs_cr_plus_128"], &meta_struct.ar_coeffs_cr_plus_128, options);
        FieldToJsonResolve(jdata["cb_mult"], decoded_value.cb_mult, options);
        FieldToJsonResolve(jdata["cb_luma_mult"], decoded_value.cb_luma_mult, options);
        FieldToJsonResolve(jdata["cb_offset"], decoded_value.cb_offset, options);
        FieldToJsonResolve(jdata["cr_mult"], decoded_value.cr_mult, options);
        FieldToJsonResolve(jdata["cr_luma_mult"], decoded_value.cr_luma_mult, options);
        FieldToJsonResolve(jdata["cr_offset"], decoded_value.cr_offset, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoAV1FilmGrain* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoAV1FilmGrain>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeAV1PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["error_resilient_mode"], decoded_value.error_resilient_mode, options);
        FieldToJsonResolve(jdata["disable_cdf_update"], decoded_value.disable_cdf_update, options);
        FieldToJsonResolve(jdata["use_superres"], decoded_value.use_superres, options);
        FieldToJsonResolve(jdata["render_and_frame_size_different"], decoded_value.render_and_frame_size_different, options);
        FieldToJsonResolve(jdata["allow_screen_content_tools"], decoded_value.allow_screen_content_tools, options);
        FieldToJsonResolve(jdata["is_filter_switchable"], decoded_value.is_filter_switchable, options);
        FieldToJsonResolve(jdata["force_integer_mv"], decoded_value.force_integer_mv, options);
        FieldToJsonResolve(jdata["frame_size_override_flag"], decoded_value.frame_size_override_flag, options);
        FieldToJsonResolve(jdata["buffer_removal_time_present_flag"], decoded_value.buffer_removal_time_present_flag, options);
        FieldToJsonResolve(jdata["allow_intrabc"], decoded_value.allow_intrabc, options);
        FieldToJsonResolve(jdata["frame_refs_short_signaling"], decoded_value.frame_refs_short_signaling, options);
        FieldToJsonResolve(jdata["allow_high_precision_mv"], decoded_value.allow_high_precision_mv, options);
        FieldToJsonResolve(jdata["is_motion_mode_switchable"], decoded_value.is_motion_mode_switchable, options);
        FieldToJsonResolve(jdata["use_ref_frame_mvs"], decoded_value.use_ref_frame_mvs, options);
        FieldToJsonResolve(jdata["disable_frame_end_update_cdf"], decoded_value.disable_frame_end_update_cdf, options);
        FieldToJsonResolve(jdata["allow_warped_motion"], decoded_value.allow_warped_motion, options);
        FieldToJsonResolve(jdata["reduced_tx_set"], decoded_value.reduced_tx_set, options);
        FieldToJsonResolve(jdata["reference_select"], decoded_value.reference_select, options);
        FieldToJsonResolve(jdata["skip_mode_present"], decoded_value.skip_mode_present, options);
        FieldToJsonResolve(jdata["delta_q_present"], decoded_value.delta_q_present, options);
        FieldToJsonResolve(jdata["delta_lf_present"], decoded_value.delta_lf_present, options);
        FieldToJsonResolve(jdata["delta_lf_multi"], decoded_value.delta_lf_multi, options);
        FieldToJsonResolve(jdata["segmentation_enabled"], decoded_value.segmentation_enabled, options);
        FieldToJsonResolve(jdata["segmentation_update_map"], decoded_value.segmentation_update_map, options);
        FieldToJsonResolve(jdata["segmentation_temporal_update"], decoded_value.segmentation_temporal_update, options);
        FieldToJsonResolve(jdata["segmentation_update_data"], decoded_value.segmentation_update_data, options);
        FieldToJsonResolve(jdata["UsesLr"], decoded_value.UsesLr, options);
        FieldToJsonResolve(jdata["usesChromaLr"], decoded_value.usesChromaLr, options);
        FieldToJsonResolve(jdata["apply_grain"], decoded_value.apply_grain, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeAV1PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeAV1PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["frame_type"], decoded_value.frame_type, options);
        FieldToJsonResolve(jdata["current_frame_id"], decoded_value.current_frame_id, options);
        FieldToJsonResolve(jdata["OrderHint"], decoded_value.OrderHint, options);
        FieldToJsonResolve(jdata["primary_ref_frame"], decoded_value.primary_ref_frame, options);
        FieldToJsonResolve(jdata["refresh_frame_flags"], decoded_value.refresh_frame_flags, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["interpolation_filter"], decoded_value.interpolation_filter, options);
        FieldToJsonResolve(jdata["TxMode"], decoded_value.TxMode, options);
        FieldToJsonResolve(jdata["delta_q_res"], decoded_value.delta_q_res, options);
        FieldToJsonResolve(jdata["delta_lf_res"], decoded_value.delta_lf_res, options);
        FieldToJsonResolve(jdata["SkipModeFrame"], &meta_struct.SkipModeFrame, options);
        FieldToJsonResolve(jdata["coded_denom"], decoded_value.coded_denom, options);
        FieldToJsonResolve(jdata["reserved2"], &meta_struct.reserved2, options);
        FieldToJsonResolve(jdata["OrderHints"], &meta_struct.OrderHints, options);
        FieldToJsonResolve(jdata["expectedFrameId"], &meta_struct.expectedFrameId, options);
        FieldToJsonResolve(jdata["pTileInfo"], meta_struct.pTileInfo, options);
        FieldToJsonResolve(jdata["pQuantization"], meta_struct.pQuantization, options);
        FieldToJsonResolve(jdata["pSegmentation"], meta_struct.pSegmentation, options);
        FieldToJsonResolve(jdata["pLoopFilter"], meta_struct.pLoopFilter, options);
        FieldToJsonResolve(jdata["pCDEF"], meta_struct.pCDEF, options);
        FieldToJsonResolve(jdata["pLoopRestoration"], meta_struct.pLoopRestoration, options);
        FieldToJsonResolve(jdata["pGlobalMotion"], meta_struct.pGlobalMotion, options);
        FieldToJsonResolve(jdata["pFilmGrain"], meta_struct.pFilmGrain, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeAV1PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeAV1ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["disable_frame_end_update_cdf"], decoded_value.disable_frame_end_update_cdf, options);
        FieldToJsonResolve(jdata["segmentation_enabled"], decoded_value.segmentation_enabled, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeAV1ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoDecodeAV1ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoDecodeAV1ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoDecodeAV1ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["frame_type"], decoded_value.frame_type, options);
        FieldToJsonResolve(jdata["RefFrameSignBias"], decoded_value.RefFrameSignBias, options);
        FieldToJsonResolve(jdata["OrderHint"], decoded_value.OrderHint, options);
        FieldToJsonResolve(jdata["SavedOrderHints"], &meta_struct.SavedOrderHints, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoDecodeAV1ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoDecodeAV1ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1ExtensionHeader>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ExtensionHeader* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ExtensionHeader& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ExtensionHeader& meta_struct = *data;

        FieldToJsonResolve(jdata["temporal_id"], decoded_value.temporal_id, options);
        FieldToJsonResolve(jdata["spatial_id"], decoded_value.spatial_id, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ExtensionHeader* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1ExtensionHeader>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1DecoderModelInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1DecoderModelInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1DecoderModelInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1DecoderModelInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["buffer_delay_length_minus_1"], decoded_value.buffer_delay_length_minus_1, options);
        FieldToJsonResolve(jdata["buffer_removal_time_length_minus_1"], decoded_value.buffer_removal_time_length_minus_1, options);
        FieldToJsonResolve(jdata["frame_presentation_time_length_minus_1"], decoded_value.frame_presentation_time_length_minus_1, options);
        FieldToJsonResolve(jdata["reserved1"], decoded_value.reserved1, options);
        FieldToJsonResolve(jdata["num_units_in_decoding_tick"], decoded_value.num_units_in_decoding_tick, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1DecoderModelInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1DecoderModelInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1OperatingPointInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1OperatingPointInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1OperatingPointInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1OperatingPointInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["decoder_model_present_for_this_op"], decoded_value.decoder_model_present_for_this_op, options);
        FieldToJsonResolve(jdata["low_delay_mode_flag"], decoded_value.low_delay_mode_flag, options);
        FieldToJsonResolve(jdata["initial_display_delay_present_for_this_op"], decoded_value.initial_display_delay_present_for_this_op, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1OperatingPointInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1OperatingPointInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1OperatingPointInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1OperatingPointInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1OperatingPointInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1OperatingPointInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["operating_point_idc"], decoded_value.operating_point_idc, options);
        FieldToJsonResolve(jdata["seq_level_idx"], decoded_value.seq_level_idx, options);
        FieldToJsonResolve(jdata["seq_tier"], decoded_value.seq_tier, options);
        FieldToJsonResolve(jdata["decoder_buffer_delay"], decoded_value.decoder_buffer_delay, options);
        FieldToJsonResolve(jdata["encoder_buffer_delay"], decoded_value.encoder_buffer_delay, options);
        FieldToJsonResolve(jdata["initial_display_delay_minus_1"], decoded_value.initial_display_delay_minus_1, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1OperatingPointInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1OperatingPointInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1PictureInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1PictureInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1PictureInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1PictureInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["error_resilient_mode"], decoded_value.error_resilient_mode, options);
        FieldToJsonResolve(jdata["disable_cdf_update"], decoded_value.disable_cdf_update, options);
        FieldToJsonResolve(jdata["use_superres"], decoded_value.use_superres, options);
        FieldToJsonResolve(jdata["render_and_frame_size_different"], decoded_value.render_and_frame_size_different, options);
        FieldToJsonResolve(jdata["allow_screen_content_tools"], decoded_value.allow_screen_content_tools, options);
        FieldToJsonResolve(jdata["is_filter_switchable"], decoded_value.is_filter_switchable, options);
        FieldToJsonResolve(jdata["force_integer_mv"], decoded_value.force_integer_mv, options);
        FieldToJsonResolve(jdata["frame_size_override_flag"], decoded_value.frame_size_override_flag, options);
        FieldToJsonResolve(jdata["buffer_removal_time_present_flag"], decoded_value.buffer_removal_time_present_flag, options);
        FieldToJsonResolve(jdata["allow_intrabc"], decoded_value.allow_intrabc, options);
        FieldToJsonResolve(jdata["frame_refs_short_signaling"], decoded_value.frame_refs_short_signaling, options);
        FieldToJsonResolve(jdata["allow_high_precision_mv"], decoded_value.allow_high_precision_mv, options);
        FieldToJsonResolve(jdata["is_motion_mode_switchable"], decoded_value.is_motion_mode_switchable, options);
        FieldToJsonResolve(jdata["use_ref_frame_mvs"], decoded_value.use_ref_frame_mvs, options);
        FieldToJsonResolve(jdata["disable_frame_end_update_cdf"], decoded_value.disable_frame_end_update_cdf, options);
        FieldToJsonResolve(jdata["allow_warped_motion"], decoded_value.allow_warped_motion, options);
        FieldToJsonResolve(jdata["reduced_tx_set"], decoded_value.reduced_tx_set, options);
        FieldToJsonResolve(jdata["skip_mode_present"], decoded_value.skip_mode_present, options);
        FieldToJsonResolve(jdata["delta_q_present"], decoded_value.delta_q_present, options);
        FieldToJsonResolve(jdata["delta_lf_present"], decoded_value.delta_lf_present, options);
        FieldToJsonResolve(jdata["delta_lf_multi"], decoded_value.delta_lf_multi, options);
        FieldToJsonResolve(jdata["segmentation_enabled"], decoded_value.segmentation_enabled, options);
        FieldToJsonResolve(jdata["segmentation_update_map"], decoded_value.segmentation_update_map, options);
        FieldToJsonResolve(jdata["segmentation_temporal_update"], decoded_value.segmentation_temporal_update, options);
        FieldToJsonResolve(jdata["segmentation_update_data"], decoded_value.segmentation_update_data, options);
        FieldToJsonResolve(jdata["UsesLr"], decoded_value.UsesLr, options);
        FieldToJsonResolve(jdata["usesChromaLr"], decoded_value.usesChromaLr, options);
        FieldToJsonResolve(jdata["show_frame"], decoded_value.show_frame, options);
        FieldToJsonResolve(jdata["showable_frame"], decoded_value.showable_frame, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1PictureInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1PictureInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1PictureInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1PictureInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1PictureInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1PictureInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["frame_type"], decoded_value.frame_type, options);
        FieldToJsonResolve(jdata["frame_presentation_time"], decoded_value.frame_presentation_time, options);
        FieldToJsonResolve(jdata["current_frame_id"], decoded_value.current_frame_id, options);
        FieldToJsonResolve(jdata["order_hint"], decoded_value.order_hint, options);
        FieldToJsonResolve(jdata["primary_ref_frame"], decoded_value.primary_ref_frame, options);
        FieldToJsonResolve(jdata["refresh_frame_flags"], decoded_value.refresh_frame_flags, options);
        FieldToJsonResolve(jdata["coded_denom"], decoded_value.coded_denom, options);
        FieldToJsonResolve(jdata["render_width_minus_1"], decoded_value.render_width_minus_1, options);
        FieldToJsonResolve(jdata["render_height_minus_1"], decoded_value.render_height_minus_1, options);
        FieldToJsonResolve(jdata["interpolation_filter"], decoded_value.interpolation_filter, options);
        FieldToJsonResolve(jdata["TxMode"], decoded_value.TxMode, options);
        FieldToJsonResolve(jdata["delta_q_res"], decoded_value.delta_q_res, options);
        FieldToJsonResolve(jdata["delta_lf_res"], decoded_value.delta_lf_res, options);
        FieldToJsonResolve(jdata["ref_order_hint"], &meta_struct.ref_order_hint, options);
        FieldToJsonResolve(jdata["ref_frame_idx"], &meta_struct.ref_frame_idx, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["delta_frame_id_minus_1"], &meta_struct.delta_frame_id_minus_1, options);
        FieldToJsonResolve(jdata["pTileInfo"], meta_struct.pTileInfo, options);
        FieldToJsonResolve(jdata["pQuantization"], meta_struct.pQuantization, options);
        FieldToJsonResolve(jdata["pSegmentation"], meta_struct.pSegmentation, options);
        FieldToJsonResolve(jdata["pLoopFilter"], meta_struct.pLoopFilter, options);
        FieldToJsonResolve(jdata["pCDEF"], meta_struct.pCDEF, options);
        FieldToJsonResolve(jdata["pLoopRestoration"], meta_struct.pLoopRestoration, options);
        FieldToJsonResolve(jdata["pGlobalMotion"], meta_struct.pGlobalMotion, options);
        FieldToJsonResolve(jdata["pExtensionHeader"], meta_struct.pExtensionHeader, options);
        FieldToJsonResolve(jdata["pBufferRemovalTimes"], meta_struct.pBufferRemovalTimes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1PictureInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1PictureInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1ReferenceInfoFlags>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ReferenceInfoFlags* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ReferenceInfoFlags& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ReferenceInfoFlags& meta_struct = *data;

        FieldToJsonResolve(jdata["disable_frame_end_update_cdf"], decoded_value.disable_frame_end_update_cdf, options);
        FieldToJsonResolve(jdata["segmentation_enabled"], decoded_value.segmentation_enabled, options);
        FieldToJsonResolve(jdata["reserved"], decoded_value.reserved, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ReferenceInfoFlags* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1ReferenceInfoFlags>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_StdVideoEncodeAV1ReferenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ReferenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const StdVideoEncodeAV1ReferenceInfo& decoded_value = *data->decoded_value;
        const Decoded_StdVideoEncodeAV1ReferenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["flags"], meta_struct.flags, options);
        FieldToJsonResolve(jdata["RefFrameId"], decoded_value.RefFrameId, options);
        FieldToJsonResolve(jdata["frame_type"], decoded_value.frame_type, options);
        FieldToJsonResolve(jdata["OrderHint"], decoded_value.OrderHint, options);
        FieldToJsonResolve(jdata["reserved1"], &meta_struct.reserved1, options);
        FieldToJsonResolve(jdata["pExtensionHeader"], meta_struct.pExtensionHeader, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_StdVideoEncodeAV1ReferenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_StdVideoEncodeAV1ReferenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExtent2D>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExtent2D* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExtent2D& decoded_value = *data->decoded_value;
        const Decoded_VkExtent2D& meta_struct = *data;

        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExtent2D* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExtent2D>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExtent3D>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExtent3D* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExtent3D& decoded_value = *data->decoded_value;
        const Decoded_VkExtent3D& meta_struct = *data;

        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["depth"], decoded_value.depth, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExtent3D* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExtent3D>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOffset2D>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOffset2D* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOffset2D& decoded_value = *data->decoded_value;
        const Decoded_VkOffset2D& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOffset2D* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOffset2D>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOffset3D>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOffset3D* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOffset3D& decoded_value = *data->decoded_value;
        const Decoded_VkOffset3D& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
        FieldToJsonResolve(jdata["z"], decoded_value.z, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOffset3D* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOffset3D>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRect2D>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRect2D* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRect2D& decoded_value = *data->decoded_value;
        const Decoded_VkRect2D& meta_struct = *data;

        FieldToJsonResolve(jdata["offset"], meta_struct.offset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRect2D* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRect2D>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferMemoryBarrier>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryBarrier* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryBarrier& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAccessFlags_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["srcQueueFamilyIndex"], decoded_value.srcQueueFamilyIndex, options);
        FieldToJsonResolve(jdata["dstQueueFamilyIndex"], decoded_value.dstQueueFamilyIndex, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryBarrier* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferMemoryBarrier>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDispatchIndirectCommand>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDispatchIndirectCommand* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDispatchIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDispatchIndirectCommand& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
        FieldToJsonResolve(jdata["z"], decoded_value.z, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDispatchIndirectCommand* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDispatchIndirectCommand>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrawIndexedIndirectCommand>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndexedIndirectCommand* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndexedIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndexedIndirectCommand& meta_struct = *data;

        FieldToJsonResolve(jdata["indexCount"], decoded_value.indexCount, options);
        FieldToJsonResolve(jdata["instanceCount"], decoded_value.instanceCount, options);
        FieldToJsonResolve(jdata["firstIndex"], decoded_value.firstIndex, options);
        FieldToJsonResolve(jdata["vertexOffset"], decoded_value.vertexOffset, options);
        FieldToJsonResolve(jdata["firstInstance"], decoded_value.firstInstance, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndexedIndirectCommand* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrawIndexedIndirectCommand>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrawIndirectCommand>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndirectCommand* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndirectCommand& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndirectCommand& meta_struct = *data;

        FieldToJsonResolve(jdata["vertexCount"], decoded_value.vertexCount, options);
        FieldToJsonResolve(jdata["instanceCount"], decoded_value.instanceCount, options);
        FieldToJsonResolve(jdata["firstVertex"], decoded_value.firstVertex, options);
        FieldToJsonResolve(jdata["firstInstance"], decoded_value.firstInstance, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndirectCommand* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrawIndirectCommand>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSubresourceRange>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresourceRange* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresourceRange& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresourceRange& meta_struct = *data;

        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["baseMipLevel"], decoded_value.baseMipLevel, options);
        FieldToJsonResolve(jdata["levelCount"], decoded_value.levelCount, options);
        FieldToJsonResolve(jdata["baseArrayLayer"], decoded_value.baseArrayLayer, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresourceRange* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSubresourceRange>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageMemoryBarrier>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryBarrier* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryBarrier& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAccessFlags_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["oldLayout"], decoded_value.oldLayout, options);
        FieldToJsonResolve(jdata["newLayout"], decoded_value.newLayout, options);
        FieldToJsonResolve(jdata["srcQueueFamilyIndex"], decoded_value.srcQueueFamilyIndex, options);
        FieldToJsonResolve(jdata["dstQueueFamilyIndex"], decoded_value.dstQueueFamilyIndex, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["subresourceRange"], meta_struct.subresourceRange, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryBarrier* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageMemoryBarrier>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryBarrier>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrier* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrier& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrier& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAccessFlags_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrier* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryBarrier>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCacheHeaderVersionOne>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCacheHeaderVersionOne* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCacheHeaderVersionOne& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCacheHeaderVersionOne& meta_struct = *data;

        FieldToJsonResolve(jdata["headerSize"], decoded_value.headerSize, options);
        FieldToJsonResolve(jdata["headerVersion"], decoded_value.headerVersion, options);
        FieldToJsonResolve(jdata["vendorID"], decoded_value.vendorID, options);
        FieldToJsonResolve(jdata["deviceID"], decoded_value.deviceID, options);
        FieldToJsonResolve(jdata["pipelineCacheUUID"], uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID), options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCacheHeaderVersionOne* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCacheHeaderVersionOne>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAllocationCallbacks>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAllocationCallbacks* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAllocationCallbacks& decoded_value = *data->decoded_value;
        const Decoded_VkAllocationCallbacks& meta_struct = *data;

        FieldToJsonResolve(jdata["pUserData"], to_hex_variable_width(meta_struct.pUserData), options);
        FieldToJsonResolve(jdata["pfnAllocation"], to_hex_variable_width(meta_struct.pfnAllocation), options);
        FieldToJsonResolve(jdata["pfnReallocation"], to_hex_variable_width(meta_struct.pfnReallocation), options);
        FieldToJsonResolve(jdata["pfnFree"], to_hex_variable_width(meta_struct.pfnFree), options);
        FieldToJsonResolve(jdata["pfnInternalAllocation"], to_hex_variable_width(meta_struct.pfnInternalAllocation), options);
        FieldToJsonResolve(jdata["pfnInternalFree"], to_hex_variable_width(meta_struct.pfnInternalFree), options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAllocationCallbacks* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAllocationCallbacks>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkApplicationInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkApplicationInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkApplicationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkApplicationInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pApplicationName"], &meta_struct.pApplicationName, options);
        FieldToJsonResolve(jdata["applicationVersion"], decoded_value.applicationVersion, options);
        FieldToJsonResolve(jdata["pEngineName"], &meta_struct.pEngineName, options);
        FieldToJsonResolve(jdata["engineVersion"], decoded_value.engineVersion, options);
        FieldToJsonResolve(jdata["apiVersion"], decoded_value.apiVersion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkApplicationInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkApplicationInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFormatProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties& meta_struct = *data;

        FieldToJson(VkFormatFeatureFlags_t(),jdata["linearTilingFeatures"], decoded_value.linearTilingFeatures, options);
        FieldToJson(VkFormatFeatureFlags_t(),jdata["optimalTilingFeatures"], decoded_value.optimalTilingFeatures, options);
        FieldToJson(VkFormatFeatureFlags_t(),jdata["bufferFeatures"], decoded_value.bufferFeatures, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFormatProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageFormatProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["maxExtent"], meta_struct.maxExtent, options);
        FieldToJsonResolve(jdata["maxMipLevels"], decoded_value.maxMipLevels, options);
        FieldToJsonResolve(jdata["maxArrayLayers"], decoded_value.maxArrayLayers, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampleCounts"], decoded_value.sampleCounts, options);
        FieldToJsonResolve(jdata["maxResourceSize"], decoded_value.maxResourceSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageFormatProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkInstanceCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkInstanceCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkInstanceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkInstanceCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkInstanceCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pApplicationInfo"], meta_struct.pApplicationInfo, options);
        FieldToJsonResolve(jdata["enabledLayerCount"], decoded_value.enabledLayerCount, options);
        FieldToJsonResolve(jdata["ppEnabledLayerNames"], &meta_struct.ppEnabledLayerNames, options);
        FieldToJsonResolve(jdata["enabledExtensionCount"], decoded_value.enabledExtensionCount, options);
        FieldToJsonResolve(jdata["ppEnabledExtensionNames"], &meta_struct.ppEnabledExtensionNames, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkInstanceCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkInstanceCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryHeap>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryHeap* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryHeap& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryHeap& meta_struct = *data;

        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJson(VkMemoryHeapFlags_t(),jdata["flags"], decoded_value.flags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryHeap* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryHeap>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryType>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryType* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryType& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryType& meta_struct = *data;

        FieldToJson(VkMemoryPropertyFlags_t(),jdata["propertyFlags"], decoded_value.propertyFlags, options);
        FieldToJsonResolve(jdata["heapIndex"], decoded_value.heapIndex, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryType* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryType>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFeatures& meta_struct = *data;

        jdata["robustBufferAccess"] = static_cast<bool>(decoded_value.robustBufferAccess);
        jdata["fullDrawIndexUint32"] = static_cast<bool>(decoded_value.fullDrawIndexUint32);
        jdata["imageCubeArray"] = static_cast<bool>(decoded_value.imageCubeArray);
        jdata["independentBlend"] = static_cast<bool>(decoded_value.independentBlend);
        jdata["geometryShader"] = static_cast<bool>(decoded_value.geometryShader);
        jdata["tessellationShader"] = static_cast<bool>(decoded_value.tessellationShader);
        jdata["sampleRateShading"] = static_cast<bool>(decoded_value.sampleRateShading);
        jdata["dualSrcBlend"] = static_cast<bool>(decoded_value.dualSrcBlend);
        jdata["logicOp"] = static_cast<bool>(decoded_value.logicOp);
        jdata["multiDrawIndirect"] = static_cast<bool>(decoded_value.multiDrawIndirect);
        jdata["drawIndirectFirstInstance"] = static_cast<bool>(decoded_value.drawIndirectFirstInstance);
        jdata["depthClamp"] = static_cast<bool>(decoded_value.depthClamp);
        jdata["depthBiasClamp"] = static_cast<bool>(decoded_value.depthBiasClamp);
        jdata["fillModeNonSolid"] = static_cast<bool>(decoded_value.fillModeNonSolid);
        jdata["depthBounds"] = static_cast<bool>(decoded_value.depthBounds);
        jdata["wideLines"] = static_cast<bool>(decoded_value.wideLines);
        jdata["largePoints"] = static_cast<bool>(decoded_value.largePoints);
        jdata["alphaToOne"] = static_cast<bool>(decoded_value.alphaToOne);
        jdata["multiViewport"] = static_cast<bool>(decoded_value.multiViewport);
        jdata["samplerAnisotropy"] = static_cast<bool>(decoded_value.samplerAnisotropy);
        jdata["textureCompressionETC2"] = static_cast<bool>(decoded_value.textureCompressionETC2);
        jdata["textureCompressionASTC_LDR"] = static_cast<bool>(decoded_value.textureCompressionASTC_LDR);
        jdata["textureCompressionBC"] = static_cast<bool>(decoded_value.textureCompressionBC);
        jdata["occlusionQueryPrecise"] = static_cast<bool>(decoded_value.occlusionQueryPrecise);
        jdata["pipelineStatisticsQuery"] = static_cast<bool>(decoded_value.pipelineStatisticsQuery);
        jdata["vertexPipelineStoresAndAtomics"] = static_cast<bool>(decoded_value.vertexPipelineStoresAndAtomics);
        jdata["fragmentStoresAndAtomics"] = static_cast<bool>(decoded_value.fragmentStoresAndAtomics);
        jdata["shaderTessellationAndGeometryPointSize"] = static_cast<bool>(decoded_value.shaderTessellationAndGeometryPointSize);
        jdata["shaderImageGatherExtended"] = static_cast<bool>(decoded_value.shaderImageGatherExtended);
        jdata["shaderStorageImageExtendedFormats"] = static_cast<bool>(decoded_value.shaderStorageImageExtendedFormats);
        jdata["shaderStorageImageMultisample"] = static_cast<bool>(decoded_value.shaderStorageImageMultisample);
        jdata["shaderStorageImageReadWithoutFormat"] = static_cast<bool>(decoded_value.shaderStorageImageReadWithoutFormat);
        jdata["shaderStorageImageWriteWithoutFormat"] = static_cast<bool>(decoded_value.shaderStorageImageWriteWithoutFormat);
        jdata["shaderUniformBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderUniformBufferArrayDynamicIndexing);
        jdata["shaderSampledImageArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderSampledImageArrayDynamicIndexing);
        jdata["shaderStorageBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderStorageBufferArrayDynamicIndexing);
        jdata["shaderStorageImageArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderStorageImageArrayDynamicIndexing);
        jdata["shaderClipDistance"] = static_cast<bool>(decoded_value.shaderClipDistance);
        jdata["shaderCullDistance"] = static_cast<bool>(decoded_value.shaderCullDistance);
        jdata["shaderFloat64"] = static_cast<bool>(decoded_value.shaderFloat64);
        jdata["shaderInt64"] = static_cast<bool>(decoded_value.shaderInt64);
        jdata["shaderInt16"] = static_cast<bool>(decoded_value.shaderInt16);
        jdata["shaderResourceResidency"] = static_cast<bool>(decoded_value.shaderResourceResidency);
        jdata["shaderResourceMinLod"] = static_cast<bool>(decoded_value.shaderResourceMinLod);
        jdata["sparseBinding"] = static_cast<bool>(decoded_value.sparseBinding);
        jdata["sparseResidencyBuffer"] = static_cast<bool>(decoded_value.sparseResidencyBuffer);
        jdata["sparseResidencyImage2D"] = static_cast<bool>(decoded_value.sparseResidencyImage2D);
        jdata["sparseResidencyImage3D"] = static_cast<bool>(decoded_value.sparseResidencyImage3D);
        jdata["sparseResidency2Samples"] = static_cast<bool>(decoded_value.sparseResidency2Samples);
        jdata["sparseResidency4Samples"] = static_cast<bool>(decoded_value.sparseResidency4Samples);
        jdata["sparseResidency8Samples"] = static_cast<bool>(decoded_value.sparseResidency8Samples);
        jdata["sparseResidency16Samples"] = static_cast<bool>(decoded_value.sparseResidency16Samples);
        jdata["sparseResidencyAliased"] = static_cast<bool>(decoded_value.sparseResidencyAliased);
        jdata["variableMultisampleRate"] = static_cast<bool>(decoded_value.variableMultisampleRate);
        jdata["inheritedQueries"] = static_cast<bool>(decoded_value.inheritedQueries);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLimits>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLimits* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLimits& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLimits& meta_struct = *data;

        FieldToJsonResolve(jdata["maxImageDimension1D"], decoded_value.maxImageDimension1D, options);
        FieldToJsonResolve(jdata["maxImageDimension2D"], decoded_value.maxImageDimension2D, options);
        FieldToJsonResolve(jdata["maxImageDimension3D"], decoded_value.maxImageDimension3D, options);
        FieldToJsonResolve(jdata["maxImageDimensionCube"], decoded_value.maxImageDimensionCube, options);
        FieldToJsonResolve(jdata["maxImageArrayLayers"], decoded_value.maxImageArrayLayers, options);
        FieldToJsonResolve(jdata["maxTexelBufferElements"], decoded_value.maxTexelBufferElements, options);
        FieldToJsonResolve(jdata["maxUniformBufferRange"], decoded_value.maxUniformBufferRange, options);
        FieldToJsonResolve(jdata["maxStorageBufferRange"], decoded_value.maxStorageBufferRange, options);
        FieldToJsonResolve(jdata["maxPushConstantsSize"], decoded_value.maxPushConstantsSize, options);
        FieldToJsonResolve(jdata["maxMemoryAllocationCount"], decoded_value.maxMemoryAllocationCount, options);
        FieldToJsonResolve(jdata["maxSamplerAllocationCount"], decoded_value.maxSamplerAllocationCount, options);
        FieldToJsonResolve(jdata["bufferImageGranularity"], decoded_value.bufferImageGranularity, options);
        FieldToJsonResolve(jdata["sparseAddressSpaceSize"], decoded_value.sparseAddressSpaceSize, options);
        FieldToJsonResolve(jdata["maxBoundDescriptorSets"], decoded_value.maxBoundDescriptorSets, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorSamplers"], decoded_value.maxPerStageDescriptorSamplers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUniformBuffers"], decoded_value.maxPerStageDescriptorUniformBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorStorageBuffers"], decoded_value.maxPerStageDescriptorStorageBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorSampledImages"], decoded_value.maxPerStageDescriptorSampledImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorStorageImages"], decoded_value.maxPerStageDescriptorStorageImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorInputAttachments"], decoded_value.maxPerStageDescriptorInputAttachments, options);
        FieldToJsonResolve(jdata["maxPerStageResources"], decoded_value.maxPerStageResources, options);
        FieldToJsonResolve(jdata["maxDescriptorSetSamplers"], decoded_value.maxDescriptorSetSamplers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUniformBuffers"], decoded_value.maxDescriptorSetUniformBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUniformBuffersDynamic"], decoded_value.maxDescriptorSetUniformBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetStorageBuffers"], decoded_value.maxDescriptorSetStorageBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetStorageBuffersDynamic"], decoded_value.maxDescriptorSetStorageBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetSampledImages"], decoded_value.maxDescriptorSetSampledImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetStorageImages"], decoded_value.maxDescriptorSetStorageImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetInputAttachments"], decoded_value.maxDescriptorSetInputAttachments, options);
        FieldToJsonResolve(jdata["maxVertexInputAttributes"], decoded_value.maxVertexInputAttributes, options);
        FieldToJsonResolve(jdata["maxVertexInputBindings"], decoded_value.maxVertexInputBindings, options);
        FieldToJsonResolve(jdata["maxVertexInputAttributeOffset"], decoded_value.maxVertexInputAttributeOffset, options);
        FieldToJsonResolve(jdata["maxVertexInputBindingStride"], decoded_value.maxVertexInputBindingStride, options);
        FieldToJsonResolve(jdata["maxVertexOutputComponents"], decoded_value.maxVertexOutputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationGenerationLevel"], decoded_value.maxTessellationGenerationLevel, options);
        FieldToJsonResolve(jdata["maxTessellationPatchSize"], decoded_value.maxTessellationPatchSize, options);
        FieldToJsonResolve(jdata["maxTessellationControlPerVertexInputComponents"], decoded_value.maxTessellationControlPerVertexInputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationControlPerVertexOutputComponents"], decoded_value.maxTessellationControlPerVertexOutputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationControlPerPatchOutputComponents"], decoded_value.maxTessellationControlPerPatchOutputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationControlTotalOutputComponents"], decoded_value.maxTessellationControlTotalOutputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationEvaluationInputComponents"], decoded_value.maxTessellationEvaluationInputComponents, options);
        FieldToJsonResolve(jdata["maxTessellationEvaluationOutputComponents"], decoded_value.maxTessellationEvaluationOutputComponents, options);
        FieldToJsonResolve(jdata["maxGeometryShaderInvocations"], decoded_value.maxGeometryShaderInvocations, options);
        FieldToJsonResolve(jdata["maxGeometryInputComponents"], decoded_value.maxGeometryInputComponents, options);
        FieldToJsonResolve(jdata["maxGeometryOutputComponents"], decoded_value.maxGeometryOutputComponents, options);
        FieldToJsonResolve(jdata["maxGeometryOutputVertices"], decoded_value.maxGeometryOutputVertices, options);
        FieldToJsonResolve(jdata["maxGeometryTotalOutputComponents"], decoded_value.maxGeometryTotalOutputComponents, options);
        FieldToJsonResolve(jdata["maxFragmentInputComponents"], decoded_value.maxFragmentInputComponents, options);
        FieldToJsonResolve(jdata["maxFragmentOutputAttachments"], decoded_value.maxFragmentOutputAttachments, options);
        FieldToJsonResolve(jdata["maxFragmentDualSrcAttachments"], decoded_value.maxFragmentDualSrcAttachments, options);
        FieldToJsonResolve(jdata["maxFragmentCombinedOutputResources"], decoded_value.maxFragmentCombinedOutputResources, options);
        FieldToJsonResolve(jdata["maxComputeSharedMemorySize"], decoded_value.maxComputeSharedMemorySize, options);
        FieldToJsonResolve(jdata["maxComputeWorkGroupCount"], &meta_struct.maxComputeWorkGroupCount, options);
        FieldToJsonResolve(jdata["maxComputeWorkGroupInvocations"], decoded_value.maxComputeWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxComputeWorkGroupSize"], &meta_struct.maxComputeWorkGroupSize, options);
        FieldToJsonResolve(jdata["subPixelPrecisionBits"], decoded_value.subPixelPrecisionBits, options);
        FieldToJsonResolve(jdata["subTexelPrecisionBits"], decoded_value.subTexelPrecisionBits, options);
        FieldToJsonResolve(jdata["mipmapPrecisionBits"], decoded_value.mipmapPrecisionBits, options);
        FieldToJsonResolve(jdata["maxDrawIndexedIndexValue"], decoded_value.maxDrawIndexedIndexValue, options);
        FieldToJsonResolve(jdata["maxDrawIndirectCount"], decoded_value.maxDrawIndirectCount, options);
        FieldToJsonResolve(jdata["maxSamplerLodBias"], decoded_value.maxSamplerLodBias, options);
        FieldToJsonResolve(jdata["maxSamplerAnisotropy"], decoded_value.maxSamplerAnisotropy, options);
        FieldToJsonResolve(jdata["maxViewports"], decoded_value.maxViewports, options);
        FieldToJsonResolve(jdata["maxViewportDimensions"], &meta_struct.maxViewportDimensions, options);
        FieldToJsonResolve(jdata["viewportBoundsRange"], &meta_struct.viewportBoundsRange, options);
        FieldToJsonResolve(jdata["viewportSubPixelBits"], decoded_value.viewportSubPixelBits, options);
        FieldToJsonResolve(jdata["minMemoryMapAlignment"], decoded_value.minMemoryMapAlignment, options);
        FieldToJsonResolve(jdata["minTexelBufferOffsetAlignment"], decoded_value.minTexelBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minUniformBufferOffsetAlignment"], decoded_value.minUniformBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minStorageBufferOffsetAlignment"], decoded_value.minStorageBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minTexelOffset"], decoded_value.minTexelOffset, options);
        FieldToJsonResolve(jdata["maxTexelOffset"], decoded_value.maxTexelOffset, options);
        FieldToJsonResolve(jdata["minTexelGatherOffset"], decoded_value.minTexelGatherOffset, options);
        FieldToJsonResolve(jdata["maxTexelGatherOffset"], decoded_value.maxTexelGatherOffset, options);
        FieldToJsonResolve(jdata["minInterpolationOffset"], decoded_value.minInterpolationOffset, options);
        FieldToJsonResolve(jdata["maxInterpolationOffset"], decoded_value.maxInterpolationOffset, options);
        FieldToJsonResolve(jdata["subPixelInterpolationOffsetBits"], decoded_value.subPixelInterpolationOffsetBits, options);
        FieldToJsonResolve(jdata["maxFramebufferWidth"], decoded_value.maxFramebufferWidth, options);
        FieldToJsonResolve(jdata["maxFramebufferHeight"], decoded_value.maxFramebufferHeight, options);
        FieldToJsonResolve(jdata["maxFramebufferLayers"], decoded_value.maxFramebufferLayers, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["framebufferColorSampleCounts"], decoded_value.framebufferColorSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["framebufferDepthSampleCounts"], decoded_value.framebufferDepthSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["framebufferStencilSampleCounts"], decoded_value.framebufferStencilSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["framebufferNoAttachmentsSampleCounts"], decoded_value.framebufferNoAttachmentsSampleCounts, options);
        FieldToJsonResolve(jdata["maxColorAttachments"], decoded_value.maxColorAttachments, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampledImageColorSampleCounts"], decoded_value.sampledImageColorSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampledImageIntegerSampleCounts"], decoded_value.sampledImageIntegerSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampledImageDepthSampleCounts"], decoded_value.sampledImageDepthSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampledImageStencilSampleCounts"], decoded_value.sampledImageStencilSampleCounts, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["storageImageSampleCounts"], decoded_value.storageImageSampleCounts, options);
        FieldToJsonResolve(jdata["maxSampleMaskWords"], decoded_value.maxSampleMaskWords, options);
        jdata["timestampComputeAndGraphics"] = static_cast<bool>(decoded_value.timestampComputeAndGraphics);
        FieldToJsonResolve(jdata["timestampPeriod"], decoded_value.timestampPeriod, options);
        FieldToJsonResolve(jdata["maxClipDistances"], decoded_value.maxClipDistances, options);
        FieldToJsonResolve(jdata["maxCullDistances"], decoded_value.maxCullDistances, options);
        FieldToJsonResolve(jdata["maxCombinedClipAndCullDistances"], decoded_value.maxCombinedClipAndCullDistances, options);
        FieldToJsonResolve(jdata["discreteQueuePriorities"], decoded_value.discreteQueuePriorities, options);
        FieldToJsonResolve(jdata["pointSizeRange"], &meta_struct.pointSizeRange, options);
        FieldToJsonResolve(jdata["lineWidthRange"], &meta_struct.lineWidthRange, options);
        FieldToJsonResolve(jdata["pointSizeGranularity"], decoded_value.pointSizeGranularity, options);
        FieldToJsonResolve(jdata["lineWidthGranularity"], decoded_value.lineWidthGranularity, options);
        jdata["strictLines"] = static_cast<bool>(decoded_value.strictLines);
        jdata["standardSampleLocations"] = static_cast<bool>(decoded_value.standardSampleLocations);
        FieldToJsonResolve(jdata["optimalBufferCopyOffsetAlignment"], decoded_value.optimalBufferCopyOffsetAlignment, options);
        FieldToJsonResolve(jdata["optimalBufferCopyRowPitchAlignment"], decoded_value.optimalBufferCopyRowPitchAlignment, options);
        FieldToJsonResolve(jdata["nonCoherentAtomSize"], decoded_value.nonCoherentAtomSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLimits* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLimits>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["memoryTypeCount"], decoded_value.memoryTypeCount, options);
        FieldToJsonResolve(jdata["memoryTypes"], meta_struct.memoryTypes, options);
        FieldToJsonResolve(jdata["memoryHeapCount"], decoded_value.memoryHeapCount, options);
        FieldToJsonResolve(jdata["memoryHeaps"], meta_struct.memoryHeaps, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSparseProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSparseProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSparseProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSparseProperties& meta_struct = *data;

        jdata["residencyStandard2DBlockShape"] = static_cast<bool>(decoded_value.residencyStandard2DBlockShape);
        jdata["residencyStandard2DMultisampleBlockShape"] = static_cast<bool>(decoded_value.residencyStandard2DMultisampleBlockShape);
        jdata["residencyStandard3DBlockShape"] = static_cast<bool>(decoded_value.residencyStandard3DBlockShape);
        jdata["residencyAlignedMipSize"] = static_cast<bool>(decoded_value.residencyAlignedMipSize);
        jdata["residencyNonResidentStrict"] = static_cast<bool>(decoded_value.residencyNonResidentStrict);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSparseProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSparseProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["apiVersion"], decoded_value.apiVersion, options);
        FieldToJsonResolve(jdata["driverVersion"], decoded_value.driverVersion, options);
        FieldToJsonResolve(jdata["vendorID"], decoded_value.vendorID, options);
        FieldToJsonResolve(jdata["deviceID"], decoded_value.deviceID, options);
        FieldToJsonResolve(jdata["deviceType"], decoded_value.deviceType, options);
        FieldToJsonResolve(jdata["deviceName"], &meta_struct.deviceName, options);
        FieldToJsonResolve(jdata["pipelineCacheUUID"], uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID), options);
        FieldToJsonResolve(jdata["limits"], meta_struct.limits, options);
        FieldToJsonResolve(jdata["sparseProperties"], meta_struct.sparseProperties, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyProperties& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyProperties& meta_struct = *data;

        FieldToJson(VkQueueFlags_t(),jdata["queueFlags"], decoded_value.queueFlags, options);
        FieldToJsonResolve(jdata["queueCount"], decoded_value.queueCount, options);
        FieldToJsonResolve(jdata["timestampValidBits"], decoded_value.timestampValidBits, options);
        FieldToJsonResolve(jdata["minImageTransferGranularity"], meta_struct.minImageTransferGranularity, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceQueueCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceQueueCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["queueFamilyIndex"], decoded_value.queueFamilyIndex, options);
        FieldToJsonResolve(jdata["queueCount"], decoded_value.queueCount, options);
        FieldToJsonResolve(jdata["pQueuePriorities"], meta_struct.pQueuePriorities, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceQueueCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["queueCreateInfoCount"], decoded_value.queueCreateInfoCount, options);
        FieldToJsonResolve(jdata["pQueueCreateInfos"], meta_struct.pQueueCreateInfos, options);
        FieldToJsonResolve(jdata["enabledLayerCount"], decoded_value.enabledLayerCount, options);
        FieldToJsonResolve(jdata["ppEnabledLayerNames"], &meta_struct.ppEnabledLayerNames, options);
        FieldToJsonResolve(jdata["enabledExtensionCount"], decoded_value.enabledExtensionCount, options);
        FieldToJsonResolve(jdata["ppEnabledExtensionNames"], &meta_struct.ppEnabledExtensionNames, options);
        FieldToJsonResolve(jdata["pEnabledFeatures"], meta_struct.pEnabledFeatures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExtensionProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExtensionProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExtensionProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExtensionProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["extensionName"], &meta_struct.extensionName, options);
        FieldToJsonResolve(jdata["specVersion"], decoded_value.specVersion, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExtensionProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExtensionProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLayerProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLayerProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLayerProperties& decoded_value = *data->decoded_value;
        const Decoded_VkLayerProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["layerName"], &meta_struct.layerName, options);
        FieldToJsonResolve(jdata["specVersion"], decoded_value.specVersion, options);
        FieldToJsonResolve(jdata["implementationVersion"], decoded_value.implementationVersion, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLayerProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLayerProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreCount"], decoded_value.waitSemaphoreCount, options);
        HandleToJson(jdata["pWaitSemaphores"], &meta_struct.pWaitSemaphores, options);
        FieldToJsonResolve(jdata["pWaitDstStageMask"], meta_struct.pWaitDstStageMask, options);
        FieldToJsonResolve(jdata["commandBufferCount"], decoded_value.commandBufferCount, options);
        HandleToJson(jdata["pCommandBuffers"], &meta_struct.pCommandBuffers, options);
        FieldToJsonResolve(jdata["signalSemaphoreCount"], decoded_value.signalSemaphoreCount, options);
        HandleToJson(jdata["pSignalSemaphores"], &meta_struct.pSignalSemaphores, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMappedMemoryRange>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMappedMemoryRange* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMappedMemoryRange& decoded_value = *data->decoded_value;
        const Decoded_VkMappedMemoryRange& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMappedMemoryRange* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMappedMemoryRange>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["allocationSize"], decoded_value.allocationSize, options);
        FieldToJsonResolve(jdata["memoryTypeIndex"], decoded_value.memoryTypeIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryRequirements>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryRequirements* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryRequirements& meta_struct = *data;

        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["alignment"], decoded_value.alignment, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryRequirements* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryRequirements>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseMemoryBind>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseMemoryBind* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseMemoryBind& decoded_value = *data->decoded_value;
        const Decoded_VkSparseMemoryBind& meta_struct = *data;

        FieldToJsonResolve(jdata["resourceOffset"], decoded_value.resourceOffset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJson(VkSparseMemoryBindFlags_t(),jdata["flags"], decoded_value.flags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseMemoryBind* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseMemoryBind>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseBufferMemoryBindInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseBufferMemoryBindInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseBufferMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseBufferMemoryBindInfo& meta_struct = *data;

        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["bindCount"], decoded_value.bindCount, options);
        FieldToJsonResolve(jdata["pBinds"], meta_struct.pBinds, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseBufferMemoryBindInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseBufferMemoryBindInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageOpaqueMemoryBindInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageOpaqueMemoryBindInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageOpaqueMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageOpaqueMemoryBindInfo& meta_struct = *data;

        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["bindCount"], decoded_value.bindCount, options);
        FieldToJsonResolve(jdata["pBinds"], meta_struct.pBinds, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageOpaqueMemoryBindInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageOpaqueMemoryBindInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSubresource>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresource* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresource& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresource& meta_struct = *data;

        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["mipLevel"], decoded_value.mipLevel, options);
        FieldToJsonResolve(jdata["arrayLayer"], decoded_value.arrayLayer, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresource* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSubresource>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageMemoryBind>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryBind* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryBind& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryBind& meta_struct = *data;

        FieldToJsonResolve(jdata["subresource"], meta_struct.subresource, options);
        FieldToJsonResolve(jdata["offset"], meta_struct.offset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJson(VkSparseMemoryBindFlags_t(),jdata["flags"], decoded_value.flags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryBind* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageMemoryBind>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageMemoryBindInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryBindInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryBindInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryBindInfo& meta_struct = *data;

        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["bindCount"], decoded_value.bindCount, options);
        FieldToJsonResolve(jdata["pBinds"], meta_struct.pBinds, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryBindInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageMemoryBindInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindSparseInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindSparseInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindSparseInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindSparseInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreCount"], decoded_value.waitSemaphoreCount, options);
        HandleToJson(jdata["pWaitSemaphores"], &meta_struct.pWaitSemaphores, options);
        FieldToJsonResolve(jdata["bufferBindCount"], decoded_value.bufferBindCount, options);
        FieldToJsonResolve(jdata["pBufferBinds"], meta_struct.pBufferBinds, options);
        FieldToJsonResolve(jdata["imageOpaqueBindCount"], decoded_value.imageOpaqueBindCount, options);
        FieldToJsonResolve(jdata["pImageOpaqueBinds"], meta_struct.pImageOpaqueBinds, options);
        FieldToJsonResolve(jdata["imageBindCount"], decoded_value.imageBindCount, options);
        FieldToJsonResolve(jdata["pImageBinds"], meta_struct.pImageBinds, options);
        FieldToJsonResolve(jdata["signalSemaphoreCount"], decoded_value.signalSemaphoreCount, options);
        HandleToJson(jdata["pSignalSemaphores"], &meta_struct.pSignalSemaphores, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindSparseInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindSparseInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageFormatProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageFormatProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageFormatProperties& meta_struct = *data;

        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["imageGranularity"], meta_struct.imageGranularity, options);
        FieldToJson(VkSparseImageFormatFlags_t(),jdata["flags"], decoded_value.flags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageFormatProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageFormatProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageMemoryRequirements>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryRequirements* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryRequirements& meta_struct = *data;

        FieldToJsonResolve(jdata["formatProperties"], meta_struct.formatProperties, options);
        FieldToJsonResolve(jdata["imageMipTailFirstLod"], decoded_value.imageMipTailFirstLod, options);
        FieldToJsonResolve(jdata["imageMipTailSize"], decoded_value.imageMipTailSize, options);
        FieldToJsonResolve(jdata["imageMipTailOffset"], decoded_value.imageMipTailOffset, options);
        FieldToJsonResolve(jdata["imageMipTailStride"], decoded_value.imageMipTailStride, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryRequirements* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageMemoryRequirements>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFenceCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFenceCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFenceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFenceCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkFenceCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFenceCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFenceCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSemaphoreCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkEventCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkEventCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkEventCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkEventCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkEventCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkEventCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkEventCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueryPoolCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkQueryPoolCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["queryType"], decoded_value.queryType, options);
        FieldToJsonResolve(jdata["queryCount"], decoded_value.queryCount, options);
        FieldToJson(VkQueryPipelineStatisticFlags_t(),jdata["pipelineStatistics"], decoded_value.pipelineStatistics, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueryPoolCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkBufferCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJson(VkBufferUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["sharingMode"], decoded_value.sharingMode, options);
        FieldToJsonResolve(jdata["queueFamilyIndexCount"], decoded_value.queueFamilyIndexCount, options);
        FieldToJsonResolve(jdata["pQueueFamilyIndices"], meta_struct.pQueueFamilyIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferViewCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferViewCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferViewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferViewCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkBufferViewCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["range"], decoded_value.range, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferViewCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferViewCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["imageType"], decoded_value.imageType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
        FieldToJsonResolve(jdata["mipLevels"], decoded_value.mipLevels, options);
        FieldToJsonResolve(jdata["arrayLayers"], decoded_value.arrayLayers, options);
        FieldToJsonResolve(jdata["samples"], decoded_value.samples, options);
        FieldToJsonResolve(jdata["tiling"], decoded_value.tiling, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["sharingMode"], decoded_value.sharingMode, options);
        FieldToJsonResolve(jdata["queueFamilyIndexCount"], decoded_value.queueFamilyIndexCount, options);
        FieldToJsonResolve(jdata["pQueueFamilyIndices"], meta_struct.pQueueFamilyIndices, options);
        FieldToJsonResolve(jdata["initialLayout"], decoded_value.initialLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubresourceLayout>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceLayout* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceLayout& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceLayout& meta_struct = *data;

        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["rowPitch"], decoded_value.rowPitch, options);
        FieldToJsonResolve(jdata["arrayPitch"], decoded_value.arrayPitch, options);
        FieldToJsonResolve(jdata["depthPitch"], decoded_value.depthPitch, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceLayout* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubresourceLayout>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkComponentMapping>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkComponentMapping* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkComponentMapping& decoded_value = *data->decoded_value;
        const Decoded_VkComponentMapping& meta_struct = *data;

        FieldToJsonResolve(jdata["r"], decoded_value.r, options);
        FieldToJsonResolve(jdata["g"], decoded_value.g, options);
        FieldToJsonResolve(jdata["b"], decoded_value.b, options);
        FieldToJsonResolve(jdata["a"], decoded_value.a, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkComponentMapping* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkComponentMapping>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageViewCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["viewType"], decoded_value.viewType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["components"], meta_struct.components, options);
        FieldToJsonResolve(jdata["subresourceRange"], meta_struct.subresourceRange, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSpecializationMapEntry>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSpecializationMapEntry* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSpecializationMapEntry& decoded_value = *data->decoded_value;
        const Decoded_VkSpecializationMapEntry& meta_struct = *data;

        FieldToJsonResolve(jdata["constantID"], decoded_value.constantID, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSpecializationMapEntry* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSpecializationMapEntry>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSpecializationInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSpecializationInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSpecializationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSpecializationInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["mapEntryCount"], decoded_value.mapEntryCount, options);
        FieldToJsonResolve(jdata["pMapEntries"], meta_struct.pMapEntries, options);
        FieldToJsonResolve(jdata["dataSize"], decoded_value.dataSize, options);
        FieldToJsonResolve(jdata["pData"], meta_struct.pData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSpecializationInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSpecializationInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineShaderStageCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineShaderStageCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stage"], decoded_value.stage, options);
        HandleToJson(jdata["module"], meta_struct.module, options);
        FieldToJsonResolve(jdata["pName"], &meta_struct.pName, options);
        FieldToJsonResolve(jdata["pSpecializationInfo"], meta_struct.pSpecializationInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineShaderStageCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkComputePipelineCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkComputePipelineCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkComputePipelineCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkComputePipelineCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stage"], meta_struct.stage, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        HandleToJson(jdata["basePipelineHandle"], meta_struct.basePipelineHandle, options);
        FieldToJsonResolve(jdata["basePipelineIndex"], decoded_value.basePipelineIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkComputePipelineCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkComputePipelineCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVertexInputBindingDescription>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDescription* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDescription& meta_struct = *data;

        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["inputRate"], decoded_value.inputRate, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDescription* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVertexInputBindingDescription>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVertexInputAttributeDescription>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputAttributeDescription* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputAttributeDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputAttributeDescription& meta_struct = *data;

        FieldToJsonResolve(jdata["location"], decoded_value.location, options);
        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputAttributeDescription* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVertexInputAttributeDescription>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineVertexInputStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineVertexInputStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineVertexInputStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineVertexInputStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineVertexInputStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["vertexBindingDescriptionCount"], decoded_value.vertexBindingDescriptionCount, options);
        FieldToJsonResolve(jdata["pVertexBindingDescriptions"], meta_struct.pVertexBindingDescriptions, options);
        FieldToJsonResolve(jdata["vertexAttributeDescriptionCount"], decoded_value.vertexAttributeDescriptionCount, options);
        FieldToJsonResolve(jdata["pVertexAttributeDescriptions"], meta_struct.pVertexAttributeDescriptions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineVertexInputStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineVertexInputStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineInputAssemblyStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineInputAssemblyStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineInputAssemblyStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineInputAssemblyStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineInputAssemblyStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["topology"], decoded_value.topology, options);
        jdata["primitiveRestartEnable"] = static_cast<bool>(decoded_value.primitiveRestartEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineInputAssemblyStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineInputAssemblyStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineTessellationStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineTessellationStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineTessellationStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineTessellationStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineTessellationStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["patchControlPoints"], decoded_value.patchControlPoints, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineTessellationStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineTessellationStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkViewport>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkViewport* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkViewport& decoded_value = *data->decoded_value;
        const Decoded_VkViewport& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["minDepth"], decoded_value.minDepth, options);
        FieldToJsonResolve(jdata["maxDepth"], decoded_value.maxDepth, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkViewport* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkViewport>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineViewportStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["viewportCount"], decoded_value.viewportCount, options);
        FieldToJsonResolve(jdata["pViewports"], meta_struct.pViewports, options);
        FieldToJsonResolve(jdata["scissorCount"], decoded_value.scissorCount, options);
        FieldToJsonResolve(jdata["pScissors"], meta_struct.pScissors, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineRasterizationStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        jdata["depthClampEnable"] = static_cast<bool>(decoded_value.depthClampEnable);
        jdata["rasterizerDiscardEnable"] = static_cast<bool>(decoded_value.rasterizerDiscardEnable);
        FieldToJsonResolve(jdata["polygonMode"], decoded_value.polygonMode, options);
        FieldToJson(VkCullModeFlags_t(),jdata["cullMode"], decoded_value.cullMode, options);
        FieldToJsonResolve(jdata["frontFace"], decoded_value.frontFace, options);
        jdata["depthBiasEnable"] = static_cast<bool>(decoded_value.depthBiasEnable);
        FieldToJsonResolve(jdata["depthBiasConstantFactor"], decoded_value.depthBiasConstantFactor, options);
        FieldToJsonResolve(jdata["depthBiasClamp"], decoded_value.depthBiasClamp, options);
        FieldToJsonResolve(jdata["depthBiasSlopeFactor"], decoded_value.depthBiasSlopeFactor, options);
        FieldToJsonResolve(jdata["lineWidth"], decoded_value.lineWidth, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineMultisampleStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineMultisampleStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineMultisampleStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineMultisampleStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineMultisampleStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["rasterizationSamples"], decoded_value.rasterizationSamples, options);
        jdata["sampleShadingEnable"] = static_cast<bool>(decoded_value.sampleShadingEnable);
        FieldToJsonResolve(jdata["minSampleShading"], decoded_value.minSampleShading, options);
        FieldToJsonResolve(jdata["pSampleMask"], meta_struct.pSampleMask, options);
        jdata["alphaToCoverageEnable"] = static_cast<bool>(decoded_value.alphaToCoverageEnable);
        jdata["alphaToOneEnable"] = static_cast<bool>(decoded_value.alphaToOneEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineMultisampleStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineMultisampleStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkStencilOpState>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkStencilOpState* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkStencilOpState& decoded_value = *data->decoded_value;
        const Decoded_VkStencilOpState& meta_struct = *data;

        FieldToJsonResolve(jdata["failOp"], decoded_value.failOp, options);
        FieldToJsonResolve(jdata["passOp"], decoded_value.passOp, options);
        FieldToJsonResolve(jdata["depthFailOp"], decoded_value.depthFailOp, options);
        FieldToJsonResolve(jdata["compareOp"], decoded_value.compareOp, options);
        FieldToJsonResolve(jdata["compareMask"], decoded_value.compareMask, options);
        FieldToJsonResolve(jdata["writeMask"], decoded_value.writeMask, options);
        FieldToJsonResolve(jdata["reference"], decoded_value.reference, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkStencilOpState* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkStencilOpState>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineDepthStencilStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDepthStencilStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDepthStencilStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDepthStencilStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineDepthStencilStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        jdata["depthTestEnable"] = static_cast<bool>(decoded_value.depthTestEnable);
        jdata["depthWriteEnable"] = static_cast<bool>(decoded_value.depthWriteEnable);
        FieldToJsonResolve(jdata["depthCompareOp"], decoded_value.depthCompareOp, options);
        jdata["depthBoundsTestEnable"] = static_cast<bool>(decoded_value.depthBoundsTestEnable);
        jdata["stencilTestEnable"] = static_cast<bool>(decoded_value.stencilTestEnable);
        FieldToJsonResolve(jdata["front"], meta_struct.front, options);
        FieldToJsonResolve(jdata["back"], meta_struct.back, options);
        FieldToJsonResolve(jdata["minDepthBounds"], decoded_value.minDepthBounds, options);
        FieldToJsonResolve(jdata["maxDepthBounds"], decoded_value.maxDepthBounds, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDepthStencilStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineDepthStencilStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineColorBlendAttachmentState>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendAttachmentState* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendAttachmentState& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendAttachmentState& meta_struct = *data;

        jdata["blendEnable"] = static_cast<bool>(decoded_value.blendEnable);
        FieldToJsonResolve(jdata["srcColorBlendFactor"], decoded_value.srcColorBlendFactor, options);
        FieldToJsonResolve(jdata["dstColorBlendFactor"], decoded_value.dstColorBlendFactor, options);
        FieldToJsonResolve(jdata["colorBlendOp"], decoded_value.colorBlendOp, options);
        FieldToJsonResolve(jdata["srcAlphaBlendFactor"], decoded_value.srcAlphaBlendFactor, options);
        FieldToJsonResolve(jdata["dstAlphaBlendFactor"], decoded_value.dstAlphaBlendFactor, options);
        FieldToJsonResolve(jdata["alphaBlendOp"], decoded_value.alphaBlendOp, options);
        FieldToJson(VkColorComponentFlags_t(),jdata["colorWriteMask"], decoded_value.colorWriteMask, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendAttachmentState* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineColorBlendAttachmentState>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineColorBlendStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineColorBlendStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        jdata["logicOpEnable"] = static_cast<bool>(decoded_value.logicOpEnable);
        FieldToJsonResolve(jdata["logicOp"], decoded_value.logicOp, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        FieldToJsonResolve(jdata["pAttachments"], meta_struct.pAttachments, options);
        FieldToJsonResolve(jdata["blendConstants"], &meta_struct.blendConstants, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineColorBlendStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineDynamicStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDynamicStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDynamicStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDynamicStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineDynamicStateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["dynamicStateCount"], decoded_value.dynamicStateCount, options);
        FieldToJsonResolve(jdata["pDynamicStates"], meta_struct.pDynamicStates, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDynamicStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineDynamicStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGraphicsPipelineCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stageCount"], decoded_value.stageCount, options);
        FieldToJsonResolve(jdata["pStages"], meta_struct.pStages, options);
        FieldToJsonResolve(jdata["pVertexInputState"], meta_struct.pVertexInputState, options);
        FieldToJsonResolve(jdata["pInputAssemblyState"], meta_struct.pInputAssemblyState, options);
        FieldToJsonResolve(jdata["pTessellationState"], meta_struct.pTessellationState, options);
        FieldToJsonResolve(jdata["pViewportState"], meta_struct.pViewportState, options);
        FieldToJsonResolve(jdata["pRasterizationState"], meta_struct.pRasterizationState, options);
        FieldToJsonResolve(jdata["pMultisampleState"], meta_struct.pMultisampleState, options);
        FieldToJsonResolve(jdata["pDepthStencilState"], meta_struct.pDepthStencilState, options);
        FieldToJsonResolve(jdata["pColorBlendState"], meta_struct.pColorBlendState, options);
        FieldToJsonResolve(jdata["pDynamicState"], meta_struct.pDynamicState, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        HandleToJson(jdata["renderPass"], meta_struct.renderPass, options);
        FieldToJsonResolve(jdata["subpass"], decoded_value.subpass, options);
        HandleToJson(jdata["basePipelineHandle"], meta_struct.basePipelineHandle, options);
        FieldToJsonResolve(jdata["basePipelineIndex"], decoded_value.basePipelineIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGraphicsPipelineCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPushConstantRange>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPushConstantRange* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPushConstantRange& decoded_value = *data->decoded_value;
        const Decoded_VkPushConstantRange& meta_struct = *data;

        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPushConstantRange* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPushConstantRange>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineLayoutCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineLayoutCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineLayoutCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineLayoutCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineLayoutCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["setLayoutCount"], decoded_value.setLayoutCount, options);
        HandleToJson(jdata["pSetLayouts"], &meta_struct.pSetLayouts, options);
        FieldToJsonResolve(jdata["pushConstantRangeCount"], decoded_value.pushConstantRangeCount, options);
        FieldToJsonResolve(jdata["pPushConstantRanges"], meta_struct.pPushConstantRanges, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineLayoutCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineLayoutCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSamplerCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["magFilter"], decoded_value.magFilter, options);
        FieldToJsonResolve(jdata["minFilter"], decoded_value.minFilter, options);
        FieldToJsonResolve(jdata["mipmapMode"], decoded_value.mipmapMode, options);
        FieldToJsonResolve(jdata["addressModeU"], decoded_value.addressModeU, options);
        FieldToJsonResolve(jdata["addressModeV"], decoded_value.addressModeV, options);
        FieldToJsonResolve(jdata["addressModeW"], decoded_value.addressModeW, options);
        FieldToJsonResolve(jdata["mipLodBias"], decoded_value.mipLodBias, options);
        jdata["anisotropyEnable"] = static_cast<bool>(decoded_value.anisotropyEnable);
        FieldToJsonResolve(jdata["maxAnisotropy"], decoded_value.maxAnisotropy, options);
        jdata["compareEnable"] = static_cast<bool>(decoded_value.compareEnable);
        FieldToJsonResolve(jdata["compareOp"], decoded_value.compareOp, options);
        FieldToJsonResolve(jdata["minLod"], decoded_value.minLod, options);
        FieldToJsonResolve(jdata["maxLod"], decoded_value.maxLod, options);
        FieldToJsonResolve(jdata["borderColor"], decoded_value.borderColor, options);
        jdata["unnormalizedCoordinates"] = static_cast<bool>(decoded_value.unnormalizedCoordinates);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyDescriptorSet>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyDescriptorSet* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyDescriptorSet& decoded_value = *data->decoded_value;
        const Decoded_VkCopyDescriptorSet& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcSet"], meta_struct.srcSet, options);
        FieldToJsonResolve(jdata["srcBinding"], decoded_value.srcBinding, options);
        FieldToJsonResolve(jdata["srcArrayElement"], decoded_value.srcArrayElement, options);
        HandleToJson(jdata["dstSet"], meta_struct.dstSet, options);
        FieldToJsonResolve(jdata["dstBinding"], decoded_value.dstBinding, options);
        FieldToJsonResolve(jdata["dstArrayElement"], decoded_value.dstArrayElement, options);
        FieldToJsonResolve(jdata["descriptorCount"], decoded_value.descriptorCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyDescriptorSet* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyDescriptorSet>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorBufferInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorBufferInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorBufferInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorBufferInfo& meta_struct = *data;

        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["range"], decoded_value.range, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorBufferInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorBufferInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorPoolSize>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolSize* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolSize& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolSize& meta_struct = *data;

        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["descriptorCount"], decoded_value.descriptorCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolSize* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorPoolSize>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorPoolCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDescriptorPoolCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["maxSets"], decoded_value.maxSets, options);
        FieldToJsonResolve(jdata["poolSizeCount"], decoded_value.poolSizeCount, options);
        FieldToJsonResolve(jdata["pPoolSizes"], meta_struct.pPoolSizes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorPoolCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["descriptorPool"], meta_struct.descriptorPool, options);
        FieldToJsonResolve(jdata["descriptorSetCount"], decoded_value.descriptorSetCount, options);
        HandleToJson(jdata["pSetLayouts"], &meta_struct.pSetLayouts, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetLayoutBinding>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutBinding* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutBinding& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutBinding& meta_struct = *data;

        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["descriptorType"], decoded_value.descriptorType, options);
        FieldToJsonResolve(jdata["descriptorCount"], decoded_value.descriptorCount, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        HandleToJson(jdata["pImmutableSamplers"], &meta_struct.pImmutableSamplers, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutBinding* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetLayoutBinding>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetLayoutCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDescriptorSetLayoutCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["bindingCount"], decoded_value.bindingCount, options);
        FieldToJsonResolve(jdata["pBindings"], meta_struct.pBindings, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetLayoutCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentDescription>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescription* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescription& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescription& meta_struct = *data;

        FieldToJson(VkAttachmentDescriptionFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["samples"], decoded_value.samples, options);
        FieldToJsonResolve(jdata["loadOp"], decoded_value.loadOp, options);
        FieldToJsonResolve(jdata["storeOp"], decoded_value.storeOp, options);
        FieldToJsonResolve(jdata["stencilLoadOp"], decoded_value.stencilLoadOp, options);
        FieldToJsonResolve(jdata["stencilStoreOp"], decoded_value.stencilStoreOp, options);
        FieldToJsonResolve(jdata["initialLayout"], decoded_value.initialLayout, options);
        FieldToJsonResolve(jdata["finalLayout"], decoded_value.finalLayout, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescription* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentDescription>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentReference>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReference* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReference& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReference& meta_struct = *data;

        FieldToJsonResolve(jdata["attachment"], decoded_value.attachment, options);
        FieldToJsonResolve(jdata["layout"], decoded_value.layout, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReference* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentReference>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFramebufferCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkFramebufferCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["renderPass"], meta_struct.renderPass, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        HandleToJson(jdata["pAttachments"], &meta_struct.pAttachments, options);
        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["layers"], decoded_value.layers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFramebufferCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassDescription>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescription* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescription& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescription& meta_struct = *data;

        FieldToJson(VkSubpassDescriptionFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        FieldToJsonResolve(jdata["inputAttachmentCount"], decoded_value.inputAttachmentCount, options);
        FieldToJsonResolve(jdata["pInputAttachments"], meta_struct.pInputAttachments, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachments"], meta_struct.pColorAttachments, options);
        FieldToJsonResolve(jdata["pResolveAttachments"], meta_struct.pResolveAttachments, options);
        FieldToJsonResolve(jdata["pDepthStencilAttachment"], meta_struct.pDepthStencilAttachment, options);
        FieldToJsonResolve(jdata["preserveAttachmentCount"], decoded_value.preserveAttachmentCount, options);
        FieldToJsonResolve(jdata["pPreserveAttachments"], meta_struct.pPreserveAttachments, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescription* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassDescription>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassDependency>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDependency* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDependency& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDependency& meta_struct = *data;

        FieldToJsonResolve(jdata["srcSubpass"], decoded_value.srcSubpass, options);
        FieldToJsonResolve(jdata["dstSubpass"], decoded_value.dstSubpass, options);
        FieldToJson(VkPipelineStageFlags_t(),jdata["srcStageMask"], decoded_value.srcStageMask, options);
        FieldToJson(VkPipelineStageFlags_t(),jdata["dstStageMask"], decoded_value.dstStageMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJson(VkDependencyFlags_t(),jdata["dependencyFlags"], decoded_value.dependencyFlags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDependency* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassDependency>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkRenderPassCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        FieldToJsonResolve(jdata["pAttachments"], meta_struct.pAttachments, options);
        FieldToJsonResolve(jdata["subpassCount"], decoded_value.subpassCount, options);
        FieldToJsonResolve(jdata["pSubpasses"], meta_struct.pSubpasses, options);
        FieldToJsonResolve(jdata["dependencyCount"], decoded_value.dependencyCount, options);
        FieldToJsonResolve(jdata["pDependencies"], meta_struct.pDependencies, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandPoolCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandPoolCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandPoolCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandPoolCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkCommandPoolCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["queueFamilyIndex"], decoded_value.queueFamilyIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandPoolCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandPoolCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["commandPool"], meta_struct.commandPool, options);
        FieldToJsonResolve(jdata["level"], decoded_value.level, options);
        FieldToJsonResolve(jdata["commandBufferCount"], decoded_value.commandBufferCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferInheritanceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["renderPass"], meta_struct.renderPass, options);
        FieldToJsonResolve(jdata["subpass"], decoded_value.subpass, options);
        HandleToJson(jdata["framebuffer"], meta_struct.framebuffer, options);
        jdata["occlusionQueryEnable"] = static_cast<bool>(decoded_value.occlusionQueryEnable);
        FieldToJson(VkQueryControlFlags_t(),jdata["queryFlags"], decoded_value.queryFlags, options);
        FieldToJson(VkQueryPipelineStatisticFlags_t(),jdata["pipelineStatistics"], decoded_value.pipelineStatistics, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferInheritanceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkCommandBufferUsageFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pInheritanceInfo"], meta_struct.pInheritanceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferCopy>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferCopy* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferCopy& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCopy& meta_struct = *data;

        FieldToJsonResolve(jdata["srcOffset"], decoded_value.srcOffset, options);
        FieldToJsonResolve(jdata["dstOffset"], decoded_value.dstOffset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferCopy* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferCopy>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSubresourceLayers>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresourceLayers* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresourceLayers& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresourceLayers& meta_struct = *data;

        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["mipLevel"], decoded_value.mipLevel, options);
        FieldToJsonResolve(jdata["baseArrayLayer"], decoded_value.baseArrayLayer, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresourceLayers* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSubresourceLayers>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferImageCopy>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferImageCopy* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferImageCopy& decoded_value = *data->decoded_value;
        const Decoded_VkBufferImageCopy& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferOffset"], decoded_value.bufferOffset, options);
        FieldToJsonResolve(jdata["bufferRowLength"], decoded_value.bufferRowLength, options);
        FieldToJsonResolve(jdata["bufferImageHeight"], decoded_value.bufferImageHeight, options);
        FieldToJsonResolve(jdata["imageSubresource"], meta_struct.imageSubresource, options);
        FieldToJsonResolve(jdata["imageOffset"], meta_struct.imageOffset, options);
        FieldToJsonResolve(jdata["imageExtent"], meta_struct.imageExtent, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferImageCopy* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferImageCopy>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkClearDepthStencilValue>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkClearDepthStencilValue* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkClearDepthStencilValue& decoded_value = *data->decoded_value;
        const Decoded_VkClearDepthStencilValue& meta_struct = *data;

        FieldToJsonResolve(jdata["depth"], decoded_value.depth, options);
        FieldToJsonResolve(jdata["stencil"], decoded_value.stencil, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkClearDepthStencilValue* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkClearDepthStencilValue>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkClearAttachment>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkClearAttachment* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkClearAttachment& decoded_value = *data->decoded_value;
        const Decoded_VkClearAttachment& meta_struct = *data;

        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["colorAttachment"], decoded_value.colorAttachment, options);
        FieldToJsonResolve(jdata["clearValue"], meta_struct.clearValue, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkClearAttachment* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkClearAttachment>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkClearRect>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkClearRect* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkClearRect& decoded_value = *data->decoded_value;
        const Decoded_VkClearRect& meta_struct = *data;

        FieldToJsonResolve(jdata["rect"], meta_struct.rect, options);
        FieldToJsonResolve(jdata["baseArrayLayer"], decoded_value.baseArrayLayer, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkClearRect* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkClearRect>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageBlit>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageBlit* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageBlit& decoded_value = *data->decoded_value;
        const Decoded_VkImageBlit& meta_struct = *data;

        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffsets"], meta_struct.srcOffsets, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffsets"], meta_struct.dstOffsets, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageBlit* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageBlit>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageCopy>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageCopy* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageCopy& decoded_value = *data->decoded_value;
        const Decoded_VkImageCopy& meta_struct = *data;

        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffset"], meta_struct.srcOffset, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffset"], meta_struct.dstOffset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageCopy* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageCopy>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageResolve>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageResolve* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageResolve& decoded_value = *data->decoded_value;
        const Decoded_VkImageResolve& meta_struct = *data;

        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffset"], meta_struct.srcOffset, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffset"], meta_struct.dstOffset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageResolve* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageResolve>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["renderPass"], meta_struct.renderPass, options);
        HandleToJson(jdata["framebuffer"], meta_struct.framebuffer, options);
        FieldToJsonResolve(jdata["renderArea"], meta_struct.renderArea, options);
        FieldToJsonResolve(jdata["clearValueCount"], decoded_value.clearValueCount, options);
        FieldToJsonResolve(jdata["pClearValues"], meta_struct.pClearValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["subgroupSize"], decoded_value.subgroupSize, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["supportedStages"], decoded_value.supportedStages, options);
        FieldToJson(VkSubgroupFeatureFlags_t(),jdata["supportedOperations"], decoded_value.supportedOperations, options);
        jdata["quadOperationsInAllStages"] = static_cast<bool>(decoded_value.quadOperationsInAllStages);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindBufferMemoryInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindBufferMemoryInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindBufferMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindBufferMemoryInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindBufferMemoryInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindBufferMemoryInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindImageMemoryInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemoryInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemoryInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemoryInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindImageMemoryInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevice16BitStorageFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice16BitStorageFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice16BitStorageFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice16BitStorageFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["storageBuffer16BitAccess"] = static_cast<bool>(decoded_value.storageBuffer16BitAccess);
        jdata["uniformAndStorageBuffer16BitAccess"] = static_cast<bool>(decoded_value.uniformAndStorageBuffer16BitAccess);
        jdata["storagePushConstant16"] = static_cast<bool>(decoded_value.storagePushConstant16);
        jdata["storageInputOutput16"] = static_cast<bool>(decoded_value.storageInputOutput16);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice16BitStorageFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevice16BitStorageFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryDedicatedRequirements>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryDedicatedRequirements* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryDedicatedRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryDedicatedRequirements& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["prefersDedicatedAllocation"] = static_cast<bool>(decoded_value.prefersDedicatedAllocation);
        jdata["requiresDedicatedAllocation"] = static_cast<bool>(decoded_value.requiresDedicatedAllocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryDedicatedRequirements* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryDedicatedRequirements>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryDedicatedAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryDedicatedAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryDedicatedAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryDedicatedAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryDedicatedAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryDedicatedAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryAllocateFlagsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryAllocateFlagsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryAllocateFlagsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryAllocateFlagsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMemoryAllocateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["deviceMask"], decoded_value.deviceMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryAllocateFlagsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryAllocateFlagsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupRenderPassBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupRenderPassBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupRenderPassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupRenderPassBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceMask"], decoded_value.deviceMask, options);
        FieldToJsonResolve(jdata["deviceRenderAreaCount"], decoded_value.deviceRenderAreaCount, options);
        FieldToJsonResolve(jdata["pDeviceRenderAreas"], meta_struct.pDeviceRenderAreas, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupRenderPassBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupRenderPassBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupCommandBufferBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupCommandBufferBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupCommandBufferBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupCommandBufferBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceMask"], decoded_value.deviceMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupCommandBufferBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupCommandBufferBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreCount"], decoded_value.waitSemaphoreCount, options);
        FieldToJsonResolve(jdata["pWaitSemaphoreDeviceIndices"], meta_struct.pWaitSemaphoreDeviceIndices, options);
        FieldToJsonResolve(jdata["commandBufferCount"], decoded_value.commandBufferCount, options);
        FieldToJsonResolve(jdata["pCommandBufferDeviceMasks"], meta_struct.pCommandBufferDeviceMasks, options);
        FieldToJsonResolve(jdata["signalSemaphoreCount"], decoded_value.signalSemaphoreCount, options);
        FieldToJsonResolve(jdata["pSignalSemaphoreDeviceIndices"], meta_struct.pSignalSemaphoreDeviceIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupBindSparseInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupBindSparseInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupBindSparseInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupBindSparseInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["resourceDeviceIndex"], decoded_value.resourceDeviceIndex, options);
        FieldToJsonResolve(jdata["memoryDeviceIndex"], decoded_value.memoryDeviceIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupBindSparseInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupBindSparseInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindBufferMemoryDeviceGroupInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindBufferMemoryDeviceGroupInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindBufferMemoryDeviceGroupInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindBufferMemoryDeviceGroupInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceIndexCount"], decoded_value.deviceIndexCount, options);
        FieldToJsonResolve(jdata["pDeviceIndices"], meta_struct.pDeviceIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindBufferMemoryDeviceGroupInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindBufferMemoryDeviceGroupInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindImageMemoryDeviceGroupInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemoryDeviceGroupInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemoryDeviceGroupInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemoryDeviceGroupInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceIndexCount"], decoded_value.deviceIndexCount, options);
        FieldToJsonResolve(jdata["pDeviceIndices"], meta_struct.pDeviceIndices, options);
        FieldToJsonResolve(jdata["splitInstanceBindRegionCount"], decoded_value.splitInstanceBindRegionCount, options);
        FieldToJsonResolve(jdata["pSplitInstanceBindRegions"], meta_struct.pSplitInstanceBindRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemoryDeviceGroupInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindImageMemoryDeviceGroupInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceGroupProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGroupProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGroupProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGroupProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["physicalDeviceCount"], decoded_value.physicalDeviceCount, options);
        HandleToJson(jdata["physicalDevices"], &meta_struct.physicalDevices, options);
        jdata["subsetAllocation"] = static_cast<bool>(decoded_value.subsetAllocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGroupProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceGroupProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupDeviceCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupDeviceCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupDeviceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupDeviceCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["physicalDeviceCount"], decoded_value.physicalDeviceCount, options);
        HandleToJson(jdata["pPhysicalDevices"], &meta_struct.pPhysicalDevices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupDeviceCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupDeviceCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferMemoryRequirementsInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryRequirementsInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryRequirementsInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryRequirementsInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferMemoryRequirementsInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageMemoryRequirementsInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryRequirementsInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryRequirementsInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryRequirementsInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageMemoryRequirementsInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSparseMemoryRequirementsInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSparseMemoryRequirementsInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSparseMemoryRequirementsInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkImageSparseMemoryRequirementsInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSparseMemoryRequirementsInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSparseMemoryRequirementsInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryRequirements2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryRequirements2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryRequirements2& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryRequirements2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryRequirements"], meta_struct.memoryRequirements, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryRequirements2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryRequirements2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageMemoryRequirements2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryRequirements2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageMemoryRequirements2& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageMemoryRequirements2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryRequirements"], meta_struct.memoryRequirements, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageMemoryRequirements2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageMemoryRequirements2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFeatures2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFeatures2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFeatures2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFeatures2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["features"], meta_struct.features, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFeatures2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFeatures2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["properties"], meta_struct.properties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFormatProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["formatProperties"], meta_struct.formatProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFormatProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageFormatProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["imageFormatProperties"], meta_struct.imageFormatProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageFormatProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageFormatInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageFormatInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageFormatInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageFormatInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["tiling"], decoded_value.tiling, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJson(VkImageCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageFormatInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageFormatInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["queueFamilyProperties"], meta_struct.queueFamilyProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryProperties"], meta_struct.memoryProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSparseImageFormatProperties2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageFormatProperties2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSparseImageFormatProperties2& decoded_value = *data->decoded_value;
        const Decoded_VkSparseImageFormatProperties2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["properties"], meta_struct.properties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSparseImageFormatProperties2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSparseImageFormatProperties2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSparseImageFormatInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSparseImageFormatInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["samples"], decoded_value.samples, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["tiling"], decoded_value.tiling, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSparseImageFormatInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePointClippingProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePointClippingProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePointClippingProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePointClippingProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pointClippingBehavior"], decoded_value.pointClippingBehavior, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePointClippingProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePointClippingProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkInputAttachmentAspectReference>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkInputAttachmentAspectReference* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkInputAttachmentAspectReference& decoded_value = *data->decoded_value;
        const Decoded_VkInputAttachmentAspectReference& meta_struct = *data;

        FieldToJsonResolve(jdata["subpass"], decoded_value.subpass, options);
        FieldToJsonResolve(jdata["inputAttachmentIndex"], decoded_value.inputAttachmentIndex, options);
        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkInputAttachmentAspectReference* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkInputAttachmentAspectReference>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassInputAttachmentAspectCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassInputAttachmentAspectCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["aspectReferenceCount"], decoded_value.aspectReferenceCount, options);
        FieldToJsonResolve(jdata["pAspectReferences"], meta_struct.pAspectReferences, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassInputAttachmentAspectCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassInputAttachmentAspectCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewUsageCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewUsageCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewUsageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewUsageCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewUsageCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewUsageCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineTessellationDomainOriginStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["domainOrigin"], decoded_value.domainOrigin, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineTessellationDomainOriginStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassMultiviewCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassMultiviewCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassMultiviewCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassMultiviewCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["subpassCount"], decoded_value.subpassCount, options);
        FieldToJsonResolve(jdata["pViewMasks"], meta_struct.pViewMasks, options);
        FieldToJsonResolve(jdata["dependencyCount"], decoded_value.dependencyCount, options);
        FieldToJsonResolve(jdata["pViewOffsets"], meta_struct.pViewOffsets, options);
        FieldToJsonResolve(jdata["correlationMaskCount"], decoded_value.correlationMaskCount, options);
        FieldToJsonResolve(jdata["pCorrelationMasks"], meta_struct.pCorrelationMasks, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassMultiviewCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassMultiviewCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multiview"] = static_cast<bool>(decoded_value.multiview);
        jdata["multiviewGeometryShader"] = static_cast<bool>(decoded_value.multiviewGeometryShader);
        jdata["multiviewTessellationShader"] = static_cast<bool>(decoded_value.multiviewTessellationShader);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxMultiviewViewCount"], decoded_value.maxMultiviewViewCount, options);
        FieldToJsonResolve(jdata["maxMultiviewInstanceIndex"], decoded_value.maxMultiviewInstanceIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVariablePointersFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVariablePointersFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVariablePointersFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVariablePointersFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["variablePointersStorageBuffer"] = static_cast<bool>(decoded_value.variablePointersStorageBuffer);
        jdata["variablePointers"] = static_cast<bool>(decoded_value.variablePointers);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVariablePointersFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVariablePointersFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProtectedMemoryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProtectedMemoryFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["protectedMemory"] = static_cast<bool>(decoded_value.protectedMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProtectedMemoryFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProtectedMemoryFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProtectedMemoryProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProtectedMemoryProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProtectedMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProtectedMemoryProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["protectedNoFault"] = static_cast<bool>(decoded_value.protectedNoFault);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProtectedMemoryProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProtectedMemoryProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceQueueInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceQueueCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["queueFamilyIndex"], decoded_value.queueFamilyIndex, options);
        FieldToJsonResolve(jdata["queueIndex"], decoded_value.queueIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceQueueInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkProtectedSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkProtectedSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkProtectedSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkProtectedSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["protectedSubmit"] = static_cast<bool>(decoded_value.protectedSubmit);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkProtectedSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkProtectedSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["ycbcrModel"], decoded_value.ycbcrModel, options);
        FieldToJsonResolve(jdata["ycbcrRange"], decoded_value.ycbcrRange, options);
        FieldToJsonResolve(jdata["components"], meta_struct.components, options);
        FieldToJsonResolve(jdata["xChromaOffset"], decoded_value.xChromaOffset, options);
        FieldToJsonResolve(jdata["yChromaOffset"], decoded_value.yChromaOffset, options);
        FieldToJsonResolve(jdata["chromaFilter"], decoded_value.chromaFilter, options);
        jdata["forceExplicitReconstruction"] = static_cast<bool>(decoded_value.forceExplicitReconstruction);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["conversion"], meta_struct.conversion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindImagePlaneMemoryInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindImagePlaneMemoryInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindImagePlaneMemoryInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindImagePlaneMemoryInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["planeAspect"], decoded_value.planeAspect, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindImagePlaneMemoryInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindImagePlaneMemoryInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImagePlaneMemoryRequirementsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImagePlaneMemoryRequirementsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImagePlaneMemoryRequirementsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImagePlaneMemoryRequirementsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["planeAspect"], decoded_value.planeAspect, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImagePlaneMemoryRequirementsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImagePlaneMemoryRequirementsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSamplerYcbcrConversionFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["samplerYcbcrConversion"] = static_cast<bool>(decoded_value.samplerYcbcrConversion);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionImageFormatProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionImageFormatProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionImageFormatProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["combinedImageSamplerDescriptorCount"], decoded_value.combinedImageSamplerDescriptorCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionImageFormatProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionImageFormatProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorUpdateTemplateEntry>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorUpdateTemplateEntry* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorUpdateTemplateEntry& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorUpdateTemplateEntry& meta_struct = *data;

        FieldToJsonResolve(jdata["dstBinding"], decoded_value.dstBinding, options);
        FieldToJsonResolve(jdata["dstArrayElement"], decoded_value.dstArrayElement, options);
        FieldToJsonResolve(jdata["descriptorCount"], decoded_value.descriptorCount, options);
        FieldToJsonResolve(jdata["descriptorType"], decoded_value.descriptorType, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorUpdateTemplateEntry* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorUpdateTemplateEntry>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorUpdateTemplateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorUpdateTemplateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorUpdateTemplateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorUpdateTemplateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDescriptorUpdateTemplateCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["descriptorUpdateEntryCount"], decoded_value.descriptorUpdateEntryCount, options);
        FieldToJsonResolve(jdata["pDescriptorUpdateEntries"], meta_struct.pDescriptorUpdateEntries, options);
        FieldToJsonResolve(jdata["templateType"], decoded_value.templateType, options);
        HandleToJson(jdata["descriptorSetLayout"], meta_struct.descriptorSetLayout, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        HandleToJson(jdata["pipelineLayout"], meta_struct.pipelineLayout, options);
        FieldToJsonResolve(jdata["set"], decoded_value.set, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorUpdateTemplateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorUpdateTemplateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalMemoryProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryProperties& meta_struct = *data;

        FieldToJson(VkExternalMemoryFeatureFlags_t(),jdata["externalMemoryFeatures"], decoded_value.externalMemoryFeatures, options);
        FieldToJson(VkExternalMemoryHandleTypeFlags_t(),jdata["exportFromImportedHandleTypes"], decoded_value.exportFromImportedHandleTypes, options);
        FieldToJson(VkExternalMemoryHandleTypeFlags_t(),jdata["compatibleHandleTypes"], decoded_value.compatibleHandleTypes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalMemoryProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalImageFormatInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalImageFormatInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalImageFormatInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalImageFormatInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalImageFormatInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalImageFormatInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalImageFormatProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalImageFormatProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalImageFormatProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalImageFormatProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["externalMemoryProperties"], meta_struct.externalMemoryProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalImageFormatProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalImageFormatProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalBufferInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalBufferInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalBufferInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalBufferInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkBufferCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJson(VkBufferUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalBufferInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalBufferInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalBufferProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalBufferProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalBufferProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalBufferProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["externalMemoryProperties"], meta_struct.externalMemoryProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalBufferProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalBufferProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceIDProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceIDProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceIDProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceIDProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceUUID"], uuid_to_string(sizeof(decoded_value.deviceUUID), decoded_value.deviceUUID), options);
        FieldToJsonResolve(jdata["driverUUID"], uuid_to_string(sizeof(decoded_value.driverUUID), decoded_value.driverUUID), options);
        FieldToJsonResolve(jdata["deviceLUID"], uuid_to_string(sizeof(decoded_value.deviceLUID), decoded_value.deviceLUID), options);
        FieldToJsonResolve(jdata["deviceNodeMask"], decoded_value.deviceNodeMask, options);
        jdata["deviceLUIDValid"] = static_cast<bool>(decoded_value.deviceLUIDValid);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceIDProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceIDProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalMemoryImageCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryImageCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryImageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryImageCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlags_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryImageCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalMemoryImageCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalMemoryBufferCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryBufferCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryBufferCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryBufferCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlags_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryBufferCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalMemoryBufferCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportMemoryAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlags_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportMemoryAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFenceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFenceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFenceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFenceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFenceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFenceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalFenceProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalFenceProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalFenceProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalFenceProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalFenceHandleTypeFlags_t(),jdata["exportFromImportedHandleTypes"], decoded_value.exportFromImportedHandleTypes, options);
        FieldToJson(VkExternalFenceHandleTypeFlags_t(),jdata["compatibleHandleTypes"], decoded_value.compatibleHandleTypes, options);
        FieldToJson(VkExternalFenceFeatureFlags_t(),jdata["externalFenceFeatures"], decoded_value.externalFenceFeatures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalFenceProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalFenceProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportFenceCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportFenceCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportFenceCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportFenceCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalFenceHandleTypeFlags_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportFenceCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportFenceCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportSemaphoreCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportSemaphoreCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportSemaphoreCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkExportSemaphoreCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalSemaphoreHandleTypeFlags_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportSemaphoreCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportSemaphoreCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalSemaphoreInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalSemaphoreInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalSemaphoreInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalSemaphoreProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalSemaphoreProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalSemaphoreProperties& decoded_value = *data->decoded_value;
        const Decoded_VkExternalSemaphoreProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalSemaphoreHandleTypeFlags_t(),jdata["exportFromImportedHandleTypes"], decoded_value.exportFromImportedHandleTypes, options);
        FieldToJson(VkExternalSemaphoreHandleTypeFlags_t(),jdata["compatibleHandleTypes"], decoded_value.compatibleHandleTypes, options);
        FieldToJson(VkExternalSemaphoreFeatureFlags_t(),jdata["externalSemaphoreFeatures"], decoded_value.externalSemaphoreFeatures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalSemaphoreProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalSemaphoreProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance3Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance3Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance3Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance3Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxPerSetDescriptors"], decoded_value.maxPerSetDescriptors, options);
        FieldToJsonResolve(jdata["maxMemoryAllocationSize"], decoded_value.maxMemoryAllocationSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance3Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance3Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetLayoutSupport>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutSupport* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutSupport& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutSupport& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["supported"] = static_cast<bool>(decoded_value.supported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutSupport* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetLayoutSupport>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderDrawParametersFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderDrawParameters"] = static_cast<bool>(decoded_value.shaderDrawParameters);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderDrawParametersFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan11Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan11Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan11Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan11Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["storageBuffer16BitAccess"] = static_cast<bool>(decoded_value.storageBuffer16BitAccess);
        jdata["uniformAndStorageBuffer16BitAccess"] = static_cast<bool>(decoded_value.uniformAndStorageBuffer16BitAccess);
        jdata["storagePushConstant16"] = static_cast<bool>(decoded_value.storagePushConstant16);
        jdata["storageInputOutput16"] = static_cast<bool>(decoded_value.storageInputOutput16);
        jdata["multiview"] = static_cast<bool>(decoded_value.multiview);
        jdata["multiviewGeometryShader"] = static_cast<bool>(decoded_value.multiviewGeometryShader);
        jdata["multiviewTessellationShader"] = static_cast<bool>(decoded_value.multiviewTessellationShader);
        jdata["variablePointersStorageBuffer"] = static_cast<bool>(decoded_value.variablePointersStorageBuffer);
        jdata["variablePointers"] = static_cast<bool>(decoded_value.variablePointers);
        jdata["protectedMemory"] = static_cast<bool>(decoded_value.protectedMemory);
        jdata["samplerYcbcrConversion"] = static_cast<bool>(decoded_value.samplerYcbcrConversion);
        jdata["shaderDrawParameters"] = static_cast<bool>(decoded_value.shaderDrawParameters);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan11Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan11Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan11Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan11Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan11Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan11Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceUUID"], uuid_to_string(sizeof(decoded_value.deviceUUID), decoded_value.deviceUUID), options);
        FieldToJsonResolve(jdata["driverUUID"], uuid_to_string(sizeof(decoded_value.driverUUID), decoded_value.driverUUID), options);
        FieldToJsonResolve(jdata["deviceLUID"], uuid_to_string(sizeof(decoded_value.deviceLUID), decoded_value.deviceLUID), options);
        FieldToJsonResolve(jdata["deviceNodeMask"], decoded_value.deviceNodeMask, options);
        jdata["deviceLUIDValid"] = static_cast<bool>(decoded_value.deviceLUIDValid);
        FieldToJsonResolve(jdata["subgroupSize"], decoded_value.subgroupSize, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["subgroupSupportedStages"], decoded_value.subgroupSupportedStages, options);
        FieldToJson(VkSubgroupFeatureFlags_t(),jdata["subgroupSupportedOperations"], decoded_value.subgroupSupportedOperations, options);
        jdata["subgroupQuadOperationsInAllStages"] = static_cast<bool>(decoded_value.subgroupQuadOperationsInAllStages);
        FieldToJsonResolve(jdata["pointClippingBehavior"], decoded_value.pointClippingBehavior, options);
        FieldToJsonResolve(jdata["maxMultiviewViewCount"], decoded_value.maxMultiviewViewCount, options);
        FieldToJsonResolve(jdata["maxMultiviewInstanceIndex"], decoded_value.maxMultiviewInstanceIndex, options);
        jdata["protectedNoFault"] = static_cast<bool>(decoded_value.protectedNoFault);
        FieldToJsonResolve(jdata["maxPerSetDescriptors"], decoded_value.maxPerSetDescriptors, options);
        FieldToJsonResolve(jdata["maxMemoryAllocationSize"], decoded_value.maxMemoryAllocationSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan11Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan11Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan12Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan12Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan12Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan12Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["samplerMirrorClampToEdge"] = static_cast<bool>(decoded_value.samplerMirrorClampToEdge);
        jdata["drawIndirectCount"] = static_cast<bool>(decoded_value.drawIndirectCount);
        jdata["storageBuffer8BitAccess"] = static_cast<bool>(decoded_value.storageBuffer8BitAccess);
        jdata["uniformAndStorageBuffer8BitAccess"] = static_cast<bool>(decoded_value.uniformAndStorageBuffer8BitAccess);
        jdata["storagePushConstant8"] = static_cast<bool>(decoded_value.storagePushConstant8);
        jdata["shaderBufferInt64Atomics"] = static_cast<bool>(decoded_value.shaderBufferInt64Atomics);
        jdata["shaderSharedInt64Atomics"] = static_cast<bool>(decoded_value.shaderSharedInt64Atomics);
        jdata["shaderFloat16"] = static_cast<bool>(decoded_value.shaderFloat16);
        jdata["shaderInt8"] = static_cast<bool>(decoded_value.shaderInt8);
        jdata["descriptorIndexing"] = static_cast<bool>(decoded_value.descriptorIndexing);
        jdata["shaderInputAttachmentArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayDynamicIndexing);
        jdata["shaderUniformTexelBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderUniformTexelBufferArrayDynamicIndexing);
        jdata["shaderStorageTexelBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderStorageTexelBufferArrayDynamicIndexing);
        jdata["shaderUniformBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderUniformBufferArrayNonUniformIndexing);
        jdata["shaderSampledImageArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderSampledImageArrayNonUniformIndexing);
        jdata["shaderStorageBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageBufferArrayNonUniformIndexing);
        jdata["shaderStorageImageArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageImageArrayNonUniformIndexing);
        jdata["shaderInputAttachmentArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayNonUniformIndexing);
        jdata["shaderUniformTexelBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderUniformTexelBufferArrayNonUniformIndexing);
        jdata["shaderStorageTexelBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageTexelBufferArrayNonUniformIndexing);
        jdata["descriptorBindingUniformBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingUniformBufferUpdateAfterBind);
        jdata["descriptorBindingSampledImageUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingSampledImageUpdateAfterBind);
        jdata["descriptorBindingStorageImageUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageImageUpdateAfterBind);
        jdata["descriptorBindingStorageBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageBufferUpdateAfterBind);
        jdata["descriptorBindingUniformTexelBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingUniformTexelBufferUpdateAfterBind);
        jdata["descriptorBindingStorageTexelBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageTexelBufferUpdateAfterBind);
        jdata["descriptorBindingUpdateUnusedWhilePending"] = static_cast<bool>(decoded_value.descriptorBindingUpdateUnusedWhilePending);
        jdata["descriptorBindingPartiallyBound"] = static_cast<bool>(decoded_value.descriptorBindingPartiallyBound);
        jdata["descriptorBindingVariableDescriptorCount"] = static_cast<bool>(decoded_value.descriptorBindingVariableDescriptorCount);
        jdata["runtimeDescriptorArray"] = static_cast<bool>(decoded_value.runtimeDescriptorArray);
        jdata["samplerFilterMinmax"] = static_cast<bool>(decoded_value.samplerFilterMinmax);
        jdata["scalarBlockLayout"] = static_cast<bool>(decoded_value.scalarBlockLayout);
        jdata["imagelessFramebuffer"] = static_cast<bool>(decoded_value.imagelessFramebuffer);
        jdata["uniformBufferStandardLayout"] = static_cast<bool>(decoded_value.uniformBufferStandardLayout);
        jdata["shaderSubgroupExtendedTypes"] = static_cast<bool>(decoded_value.shaderSubgroupExtendedTypes);
        jdata["separateDepthStencilLayouts"] = static_cast<bool>(decoded_value.separateDepthStencilLayouts);
        jdata["hostQueryReset"] = static_cast<bool>(decoded_value.hostQueryReset);
        jdata["timelineSemaphore"] = static_cast<bool>(decoded_value.timelineSemaphore);
        jdata["bufferDeviceAddress"] = static_cast<bool>(decoded_value.bufferDeviceAddress);
        jdata["bufferDeviceAddressCaptureReplay"] = static_cast<bool>(decoded_value.bufferDeviceAddressCaptureReplay);
        jdata["bufferDeviceAddressMultiDevice"] = static_cast<bool>(decoded_value.bufferDeviceAddressMultiDevice);
        jdata["vulkanMemoryModel"] = static_cast<bool>(decoded_value.vulkanMemoryModel);
        jdata["vulkanMemoryModelDeviceScope"] = static_cast<bool>(decoded_value.vulkanMemoryModelDeviceScope);
        jdata["vulkanMemoryModelAvailabilityVisibilityChains"] = static_cast<bool>(decoded_value.vulkanMemoryModelAvailabilityVisibilityChains);
        jdata["shaderOutputViewportIndex"] = static_cast<bool>(decoded_value.shaderOutputViewportIndex);
        jdata["shaderOutputLayer"] = static_cast<bool>(decoded_value.shaderOutputLayer);
        jdata["subgroupBroadcastDynamicId"] = static_cast<bool>(decoded_value.subgroupBroadcastDynamicId);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan12Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan12Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkConformanceVersion>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkConformanceVersion* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkConformanceVersion& decoded_value = *data->decoded_value;
        const Decoded_VkConformanceVersion& meta_struct = *data;

        FieldToJsonResolve(jdata["major"], decoded_value.major, options);
        FieldToJsonResolve(jdata["minor"], decoded_value.minor, options);
        FieldToJsonResolve(jdata["subminor"], decoded_value.subminor, options);
        FieldToJsonResolve(jdata["patch"], decoded_value.patch, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkConformanceVersion* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkConformanceVersion>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan12Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan12Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan12Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan12Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["driverID"], decoded_value.driverID, options);
        FieldToJsonResolve(jdata["driverName"], &meta_struct.driverName, options);
        FieldToJsonResolve(jdata["driverInfo"], &meta_struct.driverInfo, options);
        FieldToJsonResolve(jdata["conformanceVersion"], meta_struct.conformanceVersion, options);
        FieldToJsonResolve(jdata["denormBehaviorIndependence"], decoded_value.denormBehaviorIndependence, options);
        FieldToJsonResolve(jdata["roundingModeIndependence"], decoded_value.roundingModeIndependence, options);
        jdata["shaderSignedZeroInfNanPreserveFloat16"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat16);
        jdata["shaderSignedZeroInfNanPreserveFloat32"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat32);
        jdata["shaderSignedZeroInfNanPreserveFloat64"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat64);
        jdata["shaderDenormPreserveFloat16"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat16);
        jdata["shaderDenormPreserveFloat32"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat32);
        jdata["shaderDenormPreserveFloat64"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat64);
        jdata["shaderDenormFlushToZeroFloat16"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat16);
        jdata["shaderDenormFlushToZeroFloat32"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat32);
        jdata["shaderDenormFlushToZeroFloat64"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat64);
        jdata["shaderRoundingModeRTEFloat16"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat16);
        jdata["shaderRoundingModeRTEFloat32"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat32);
        jdata["shaderRoundingModeRTEFloat64"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat64);
        jdata["shaderRoundingModeRTZFloat16"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat16);
        jdata["shaderRoundingModeRTZFloat32"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat32);
        jdata["shaderRoundingModeRTZFloat64"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat64);
        FieldToJsonResolve(jdata["maxUpdateAfterBindDescriptorsInAllPools"], decoded_value.maxUpdateAfterBindDescriptorsInAllPools, options);
        jdata["shaderUniformBufferArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderUniformBufferArrayNonUniformIndexingNative);
        jdata["shaderSampledImageArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderSampledImageArrayNonUniformIndexingNative);
        jdata["shaderStorageBufferArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderStorageBufferArrayNonUniformIndexingNative);
        jdata["shaderStorageImageArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderStorageImageArrayNonUniformIndexingNative);
        jdata["shaderInputAttachmentArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayNonUniformIndexingNative);
        jdata["robustBufferAccessUpdateAfterBind"] = static_cast<bool>(decoded_value.robustBufferAccessUpdateAfterBind);
        jdata["quadDivergentImplicitLod"] = static_cast<bool>(decoded_value.quadDivergentImplicitLod);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindSamplers"], decoded_value.maxPerStageDescriptorUpdateAfterBindSamplers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindUniformBuffers"], decoded_value.maxPerStageDescriptorUpdateAfterBindUniformBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindStorageBuffers"], decoded_value.maxPerStageDescriptorUpdateAfterBindStorageBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindSampledImages"], decoded_value.maxPerStageDescriptorUpdateAfterBindSampledImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindStorageImages"], decoded_value.maxPerStageDescriptorUpdateAfterBindStorageImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindInputAttachments"], decoded_value.maxPerStageDescriptorUpdateAfterBindInputAttachments, options);
        FieldToJsonResolve(jdata["maxPerStageUpdateAfterBindResources"], decoded_value.maxPerStageUpdateAfterBindResources, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindSamplers"], decoded_value.maxDescriptorSetUpdateAfterBindSamplers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindUniformBuffers"], decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageBuffers"], decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindSampledImages"], decoded_value.maxDescriptorSetUpdateAfterBindSampledImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageImages"], decoded_value.maxDescriptorSetUpdateAfterBindStorageImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindInputAttachments"], decoded_value.maxDescriptorSetUpdateAfterBindInputAttachments, options);
        FieldToJson(VkResolveModeFlags_t(),jdata["supportedDepthResolveModes"], decoded_value.supportedDepthResolveModes, options);
        FieldToJson(VkResolveModeFlags_t(),jdata["supportedStencilResolveModes"], decoded_value.supportedStencilResolveModes, options);
        jdata["independentResolveNone"] = static_cast<bool>(decoded_value.independentResolveNone);
        jdata["independentResolve"] = static_cast<bool>(decoded_value.independentResolve);
        jdata["filterMinmaxSingleComponentFormats"] = static_cast<bool>(decoded_value.filterMinmaxSingleComponentFormats);
        jdata["filterMinmaxImageComponentMapping"] = static_cast<bool>(decoded_value.filterMinmaxImageComponentMapping);
        FieldToJsonResolve(jdata["maxTimelineSemaphoreValueDifference"], decoded_value.maxTimelineSemaphoreValueDifference, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["framebufferIntegerColorSampleCounts"], decoded_value.framebufferIntegerColorSampleCounts, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan12Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan12Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageFormatListCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatListCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageFormatListCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageFormatListCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["viewFormatCount"], decoded_value.viewFormatCount, options);
        FieldToJsonResolve(jdata["pViewFormats"], meta_struct.pViewFormats, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageFormatListCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageFormatListCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentDescription2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescription2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescription2& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescription2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAttachmentDescriptionFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["samples"], decoded_value.samples, options);
        FieldToJsonResolve(jdata["loadOp"], decoded_value.loadOp, options);
        FieldToJsonResolve(jdata["storeOp"], decoded_value.storeOp, options);
        FieldToJsonResolve(jdata["stencilLoadOp"], decoded_value.stencilLoadOp, options);
        FieldToJsonResolve(jdata["stencilStoreOp"], decoded_value.stencilStoreOp, options);
        FieldToJsonResolve(jdata["initialLayout"], decoded_value.initialLayout, options);
        FieldToJsonResolve(jdata["finalLayout"], decoded_value.finalLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescription2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentDescription2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentReference2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReference2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReference2& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReference2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["attachment"], decoded_value.attachment, options);
        FieldToJsonResolve(jdata["layout"], decoded_value.layout, options);
        FieldToJson(VkImageAspectFlags_t(),jdata["aspectMask"], decoded_value.aspectMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReference2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentReference2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassDescription2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescription2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescription2& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescription2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSubpassDescriptionFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        FieldToJsonResolve(jdata["viewMask"], decoded_value.viewMask, options);
        FieldToJsonResolve(jdata["inputAttachmentCount"], decoded_value.inputAttachmentCount, options);
        FieldToJsonResolve(jdata["pInputAttachments"], meta_struct.pInputAttachments, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachments"], meta_struct.pColorAttachments, options);
        FieldToJsonResolve(jdata["pResolveAttachments"], meta_struct.pResolveAttachments, options);
        FieldToJsonResolve(jdata["pDepthStencilAttachment"], meta_struct.pDepthStencilAttachment, options);
        FieldToJsonResolve(jdata["preserveAttachmentCount"], decoded_value.preserveAttachmentCount, options);
        FieldToJsonResolve(jdata["pPreserveAttachments"], meta_struct.pPreserveAttachments, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescription2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassDescription2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassDependency2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDependency2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDependency2& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDependency2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcSubpass"], decoded_value.srcSubpass, options);
        FieldToJsonResolve(jdata["dstSubpass"], decoded_value.dstSubpass, options);
        FieldToJson(VkPipelineStageFlags_t(),jdata["srcStageMask"], decoded_value.srcStageMask, options);
        FieldToJson(VkPipelineStageFlags_t(),jdata["dstStageMask"], decoded_value.dstStageMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkAccessFlags_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJson(VkDependencyFlags_t(),jdata["dependencyFlags"], decoded_value.dependencyFlags, options);
        FieldToJsonResolve(jdata["viewOffset"], decoded_value.viewOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDependency2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassDependency2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassCreateInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreateInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreateInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreateInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkRenderPassCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        FieldToJsonResolve(jdata["pAttachments"], meta_struct.pAttachments, options);
        FieldToJsonResolve(jdata["subpassCount"], decoded_value.subpassCount, options);
        FieldToJsonResolve(jdata["pSubpasses"], meta_struct.pSubpasses, options);
        FieldToJsonResolve(jdata["dependencyCount"], decoded_value.dependencyCount, options);
        FieldToJsonResolve(jdata["pDependencies"], meta_struct.pDependencies, options);
        FieldToJsonResolve(jdata["correlatedViewMaskCount"], decoded_value.correlatedViewMaskCount, options);
        FieldToJsonResolve(jdata["pCorrelatedViewMasks"], meta_struct.pCorrelatedViewMasks, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreateInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassCreateInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["contents"], decoded_value.contents, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassEndInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassEndInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassEndInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassEndInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassEndInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassEndInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevice8BitStorageFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice8BitStorageFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice8BitStorageFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice8BitStorageFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["storageBuffer8BitAccess"] = static_cast<bool>(decoded_value.storageBuffer8BitAccess);
        jdata["uniformAndStorageBuffer8BitAccess"] = static_cast<bool>(decoded_value.uniformAndStorageBuffer8BitAccess);
        jdata["storagePushConstant8"] = static_cast<bool>(decoded_value.storagePushConstant8);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice8BitStorageFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevice8BitStorageFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDriverProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDriverProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDriverProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDriverProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["driverID"], decoded_value.driverID, options);
        FieldToJsonResolve(jdata["driverName"], &meta_struct.driverName, options);
        FieldToJsonResolve(jdata["driverInfo"], &meta_struct.driverInfo, options);
        FieldToJsonResolve(jdata["conformanceVersion"], meta_struct.conformanceVersion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDriverProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDriverProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicInt64Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicInt64Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicInt64Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicInt64Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderBufferInt64Atomics"] = static_cast<bool>(decoded_value.shaderBufferInt64Atomics);
        jdata["shaderSharedInt64Atomics"] = static_cast<bool>(decoded_value.shaderSharedInt64Atomics);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicInt64Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicInt64Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloat16Int8Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloat16Int8Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderFloat16Int8Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderFloat16Int8Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderFloat16"] = static_cast<bool>(decoded_value.shaderFloat16);
        jdata["shaderInt8"] = static_cast<bool>(decoded_value.shaderInt8);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloat16Int8Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloat16Int8Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFloatControlsProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFloatControlsProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFloatControlsProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFloatControlsProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["denormBehaviorIndependence"], decoded_value.denormBehaviorIndependence, options);
        FieldToJsonResolve(jdata["roundingModeIndependence"], decoded_value.roundingModeIndependence, options);
        jdata["shaderSignedZeroInfNanPreserveFloat16"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat16);
        jdata["shaderSignedZeroInfNanPreserveFloat32"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat32);
        jdata["shaderSignedZeroInfNanPreserveFloat64"] = static_cast<bool>(decoded_value.shaderSignedZeroInfNanPreserveFloat64);
        jdata["shaderDenormPreserveFloat16"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat16);
        jdata["shaderDenormPreserveFloat32"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat32);
        jdata["shaderDenormPreserveFloat64"] = static_cast<bool>(decoded_value.shaderDenormPreserveFloat64);
        jdata["shaderDenormFlushToZeroFloat16"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat16);
        jdata["shaderDenormFlushToZeroFloat32"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat32);
        jdata["shaderDenormFlushToZeroFloat64"] = static_cast<bool>(decoded_value.shaderDenormFlushToZeroFloat64);
        jdata["shaderRoundingModeRTEFloat16"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat16);
        jdata["shaderRoundingModeRTEFloat32"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat32);
        jdata["shaderRoundingModeRTEFloat64"] = static_cast<bool>(decoded_value.shaderRoundingModeRTEFloat64);
        jdata["shaderRoundingModeRTZFloat16"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat16);
        jdata["shaderRoundingModeRTZFloat32"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat32);
        jdata["shaderRoundingModeRTZFloat64"] = static_cast<bool>(decoded_value.shaderRoundingModeRTZFloat64);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFloatControlsProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFloatControlsProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutBindingFlagsCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["bindingCount"], decoded_value.bindingCount, options);
        FieldToJsonResolve(jdata["pBindingFlags"], meta_struct.pBindingFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorIndexingFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorIndexingFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderInputAttachmentArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayDynamicIndexing);
        jdata["shaderUniformTexelBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderUniformTexelBufferArrayDynamicIndexing);
        jdata["shaderStorageTexelBufferArrayDynamicIndexing"] = static_cast<bool>(decoded_value.shaderStorageTexelBufferArrayDynamicIndexing);
        jdata["shaderUniformBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderUniformBufferArrayNonUniformIndexing);
        jdata["shaderSampledImageArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderSampledImageArrayNonUniformIndexing);
        jdata["shaderStorageBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageBufferArrayNonUniformIndexing);
        jdata["shaderStorageImageArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageImageArrayNonUniformIndexing);
        jdata["shaderInputAttachmentArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayNonUniformIndexing);
        jdata["shaderUniformTexelBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderUniformTexelBufferArrayNonUniformIndexing);
        jdata["shaderStorageTexelBufferArrayNonUniformIndexing"] = static_cast<bool>(decoded_value.shaderStorageTexelBufferArrayNonUniformIndexing);
        jdata["descriptorBindingUniformBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingUniformBufferUpdateAfterBind);
        jdata["descriptorBindingSampledImageUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingSampledImageUpdateAfterBind);
        jdata["descriptorBindingStorageImageUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageImageUpdateAfterBind);
        jdata["descriptorBindingStorageBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageBufferUpdateAfterBind);
        jdata["descriptorBindingUniformTexelBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingUniformTexelBufferUpdateAfterBind);
        jdata["descriptorBindingStorageTexelBufferUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingStorageTexelBufferUpdateAfterBind);
        jdata["descriptorBindingUpdateUnusedWhilePending"] = static_cast<bool>(decoded_value.descriptorBindingUpdateUnusedWhilePending);
        jdata["descriptorBindingPartiallyBound"] = static_cast<bool>(decoded_value.descriptorBindingPartiallyBound);
        jdata["descriptorBindingVariableDescriptorCount"] = static_cast<bool>(decoded_value.descriptorBindingVariableDescriptorCount);
        jdata["runtimeDescriptorArray"] = static_cast<bool>(decoded_value.runtimeDescriptorArray);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorIndexingFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorIndexingProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorIndexingProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorIndexingProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorIndexingProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxUpdateAfterBindDescriptorsInAllPools"], decoded_value.maxUpdateAfterBindDescriptorsInAllPools, options);
        jdata["shaderUniformBufferArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderUniformBufferArrayNonUniformIndexingNative);
        jdata["shaderSampledImageArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderSampledImageArrayNonUniformIndexingNative);
        jdata["shaderStorageBufferArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderStorageBufferArrayNonUniformIndexingNative);
        jdata["shaderStorageImageArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderStorageImageArrayNonUniformIndexingNative);
        jdata["shaderInputAttachmentArrayNonUniformIndexingNative"] = static_cast<bool>(decoded_value.shaderInputAttachmentArrayNonUniformIndexingNative);
        jdata["robustBufferAccessUpdateAfterBind"] = static_cast<bool>(decoded_value.robustBufferAccessUpdateAfterBind);
        jdata["quadDivergentImplicitLod"] = static_cast<bool>(decoded_value.quadDivergentImplicitLod);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindSamplers"], decoded_value.maxPerStageDescriptorUpdateAfterBindSamplers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindUniformBuffers"], decoded_value.maxPerStageDescriptorUpdateAfterBindUniformBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindStorageBuffers"], decoded_value.maxPerStageDescriptorUpdateAfterBindStorageBuffers, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindSampledImages"], decoded_value.maxPerStageDescriptorUpdateAfterBindSampledImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindStorageImages"], decoded_value.maxPerStageDescriptorUpdateAfterBindStorageImages, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindInputAttachments"], decoded_value.maxPerStageDescriptorUpdateAfterBindInputAttachments, options);
        FieldToJsonResolve(jdata["maxPerStageUpdateAfterBindResources"], decoded_value.maxPerStageUpdateAfterBindResources, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindSamplers"], decoded_value.maxDescriptorSetUpdateAfterBindSamplers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindUniformBuffers"], decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageBuffers"], decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindSampledImages"], decoded_value.maxDescriptorSetUpdateAfterBindSampledImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindStorageImages"], decoded_value.maxDescriptorSetUpdateAfterBindStorageImages, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindInputAttachments"], decoded_value.maxDescriptorSetUpdateAfterBindInputAttachments, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorIndexingProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorIndexingProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetVariableDescriptorCountAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["descriptorSetCount"], decoded_value.descriptorSetCount, options);
        FieldToJsonResolve(jdata["pDescriptorCounts"], meta_struct.pDescriptorCounts, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetVariableDescriptorCountLayoutSupport& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxVariableDescriptorCount"], decoded_value.maxVariableDescriptorCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassDescriptionDepthStencilResolve>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescriptionDepthStencilResolve* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassDescriptionDepthStencilResolve& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassDescriptionDepthStencilResolve& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["depthResolveMode"], decoded_value.depthResolveMode, options);
        FieldToJsonResolve(jdata["stencilResolveMode"], decoded_value.stencilResolveMode, options);
        FieldToJsonResolve(jdata["pDepthStencilResolveAttachment"], meta_struct.pDepthStencilResolveAttachment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassDescriptionDepthStencilResolve* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassDescriptionDepthStencilResolve>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthStencilResolveProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthStencilResolveProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthStencilResolveProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthStencilResolveProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkResolveModeFlags_t(),jdata["supportedDepthResolveModes"], decoded_value.supportedDepthResolveModes, options);
        FieldToJson(VkResolveModeFlags_t(),jdata["supportedStencilResolveModes"], decoded_value.supportedStencilResolveModes, options);
        jdata["independentResolveNone"] = static_cast<bool>(decoded_value.independentResolveNone);
        jdata["independentResolve"] = static_cast<bool>(decoded_value.independentResolve);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthStencilResolveProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthStencilResolveProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceScalarBlockLayoutFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["scalarBlockLayout"] = static_cast<bool>(decoded_value.scalarBlockLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageStencilUsageCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageStencilUsageCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageStencilUsageCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkImageStencilUsageCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["stencilUsage"], decoded_value.stencilUsage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageStencilUsageCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageStencilUsageCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerReductionModeCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerReductionModeCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerReductionModeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerReductionModeCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["reductionMode"], decoded_value.reductionMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerReductionModeCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerReductionModeCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSamplerFilterMinmaxProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["filterMinmaxSingleComponentFormats"] = static_cast<bool>(decoded_value.filterMinmaxSingleComponentFormats);
        jdata["filterMinmaxImageComponentMapping"] = static_cast<bool>(decoded_value.filterMinmaxImageComponentMapping);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkanMemoryModelFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["vulkanMemoryModel"] = static_cast<bool>(decoded_value.vulkanMemoryModel);
        jdata["vulkanMemoryModelDeviceScope"] = static_cast<bool>(decoded_value.vulkanMemoryModelDeviceScope);
        jdata["vulkanMemoryModelAvailabilityVisibilityChains"] = static_cast<bool>(decoded_value.vulkanMemoryModelAvailabilityVisibilityChains);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImagelessFramebufferFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImagelessFramebufferFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imagelessFramebuffer"] = static_cast<bool>(decoded_value.imagelessFramebuffer);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImagelessFramebufferFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFramebufferAttachmentImageInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferAttachmentImageInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferAttachmentImageInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferAttachmentImageInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
        FieldToJsonResolve(jdata["viewFormatCount"], decoded_value.viewFormatCount, options);
        FieldToJsonResolve(jdata["pViewFormats"], meta_struct.pViewFormats, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferAttachmentImageInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFramebufferAttachmentImageInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFramebufferAttachmentsCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferAttachmentsCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferAttachmentsCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferAttachmentsCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["attachmentImageInfoCount"], decoded_value.attachmentImageInfoCount, options);
        FieldToJsonResolve(jdata["pAttachmentImageInfos"], meta_struct.pAttachmentImageInfos, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferAttachmentsCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFramebufferAttachmentsCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassAttachmentBeginInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassAttachmentBeginInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassAttachmentBeginInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassAttachmentBeginInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        HandleToJson(jdata["pAttachments"], &meta_struct.pAttachments, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassAttachmentBeginInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassAttachmentBeginInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceUniformBufferStandardLayoutFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["uniformBufferStandardLayout"] = static_cast<bool>(decoded_value.uniformBufferStandardLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderSubgroupExtendedTypes"] = static_cast<bool>(decoded_value.shaderSubgroupExtendedTypes);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["separateDepthStencilLayouts"] = static_cast<bool>(decoded_value.separateDepthStencilLayouts);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentReferenceStencilLayout>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReferenceStencilLayout* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentReferenceStencilLayout& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentReferenceStencilLayout& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stencilLayout"], decoded_value.stencilLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentReferenceStencilLayout* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentReferenceStencilLayout>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentDescriptionStencilLayout>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescriptionStencilLayout* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentDescriptionStencilLayout& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentDescriptionStencilLayout& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stencilInitialLayout"], decoded_value.stencilInitialLayout, options);
        FieldToJsonResolve(jdata["stencilFinalLayout"], decoded_value.stencilFinalLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentDescriptionStencilLayout* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentDescriptionStencilLayout>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceHostQueryResetFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostQueryResetFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostQueryResetFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostQueryResetFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hostQueryReset"] = static_cast<bool>(decoded_value.hostQueryReset);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostQueryResetFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceHostQueryResetFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTimelineSemaphoreFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["timelineSemaphore"] = static_cast<bool>(decoded_value.timelineSemaphore);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTimelineSemaphoreProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTimelineSemaphoreProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxTimelineSemaphoreValueDifference"], decoded_value.maxTimelineSemaphoreValueDifference, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTimelineSemaphoreProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreTypeCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreTypeCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreTypeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreTypeCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["semaphoreType"], decoded_value.semaphoreType, options);
        FieldToJsonResolve(jdata["initialValue"], decoded_value.initialValue, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreTypeCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreTypeCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTimelineSemaphoreSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTimelineSemaphoreSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTimelineSemaphoreSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkTimelineSemaphoreSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreValueCount"], decoded_value.waitSemaphoreValueCount, options);
        FieldToJsonResolve(jdata["pWaitSemaphoreValues"], meta_struct.pWaitSemaphoreValues, options);
        FieldToJsonResolve(jdata["signalSemaphoreValueCount"], decoded_value.signalSemaphoreValueCount, options);
        FieldToJsonResolve(jdata["pSignalSemaphoreValues"], meta_struct.pSignalSemaphoreValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTimelineSemaphoreSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTimelineSemaphoreSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreWaitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreWaitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreWaitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreWaitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSemaphoreWaitFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["semaphoreCount"], decoded_value.semaphoreCount, options);
        HandleToJson(jdata["pSemaphores"], &meta_struct.pSemaphores, options);
        FieldToJsonResolve(jdata["pValues"], meta_struct.pValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreWaitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreWaitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreSignalInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreSignalInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreSignalInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreSignalInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJsonResolve(jdata["value"], decoded_value.value, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreSignalInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreSignalInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBufferDeviceAddressFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["bufferDeviceAddress"] = static_cast<bool>(decoded_value.bufferDeviceAddress);
        jdata["bufferDeviceAddressCaptureReplay"] = static_cast<bool>(decoded_value.bufferDeviceAddressCaptureReplay);
        jdata["bufferDeviceAddressMultiDevice"] = static_cast<bool>(decoded_value.bufferDeviceAddressMultiDevice);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferDeviceAddressInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferDeviceAddressInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferDeviceAddressInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferDeviceAddressInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferDeviceAddressInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferDeviceAddressInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferOpaqueCaptureAddressCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferOpaqueCaptureAddressCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferOpaqueCaptureAddressCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferOpaqueCaptureAddressCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["opaqueCaptureAddress"], decoded_value.opaqueCaptureAddress, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferOpaqueCaptureAddressCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferOpaqueCaptureAddressCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryOpaqueCaptureAddressAllocateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["opaqueCaptureAddress"], decoded_value.opaqueCaptureAddress, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryOpaqueCaptureAddressInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan13Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan13Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan13Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan13Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["robustImageAccess"] = static_cast<bool>(decoded_value.robustImageAccess);
        jdata["inlineUniformBlock"] = static_cast<bool>(decoded_value.inlineUniformBlock);
        jdata["descriptorBindingInlineUniformBlockUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingInlineUniformBlockUpdateAfterBind);
        jdata["pipelineCreationCacheControl"] = static_cast<bool>(decoded_value.pipelineCreationCacheControl);
        jdata["privateData"] = static_cast<bool>(decoded_value.privateData);
        jdata["shaderDemoteToHelperInvocation"] = static_cast<bool>(decoded_value.shaderDemoteToHelperInvocation);
        jdata["shaderTerminateInvocation"] = static_cast<bool>(decoded_value.shaderTerminateInvocation);
        jdata["subgroupSizeControl"] = static_cast<bool>(decoded_value.subgroupSizeControl);
        jdata["computeFullSubgroups"] = static_cast<bool>(decoded_value.computeFullSubgroups);
        jdata["synchronization2"] = static_cast<bool>(decoded_value.synchronization2);
        jdata["textureCompressionASTC_HDR"] = static_cast<bool>(decoded_value.textureCompressionASTC_HDR);
        jdata["shaderZeroInitializeWorkgroupMemory"] = static_cast<bool>(decoded_value.shaderZeroInitializeWorkgroupMemory);
        jdata["dynamicRendering"] = static_cast<bool>(decoded_value.dynamicRendering);
        jdata["shaderIntegerDotProduct"] = static_cast<bool>(decoded_value.shaderIntegerDotProduct);
        jdata["maintenance4"] = static_cast<bool>(decoded_value.maintenance4);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan13Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan13Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan13Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan13Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan13Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan13Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minSubgroupSize"], decoded_value.minSubgroupSize, options);
        FieldToJsonResolve(jdata["maxSubgroupSize"], decoded_value.maxSubgroupSize, options);
        FieldToJsonResolve(jdata["maxComputeWorkgroupSubgroups"], decoded_value.maxComputeWorkgroupSubgroups, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["requiredSubgroupSizeStages"], decoded_value.requiredSubgroupSizeStages, options);
        FieldToJsonResolve(jdata["maxInlineUniformBlockSize"], decoded_value.maxInlineUniformBlockSize, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorInlineUniformBlocks"], decoded_value.maxPerStageDescriptorInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"], decoded_value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxDescriptorSetInlineUniformBlocks"], decoded_value.maxDescriptorSetInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"], decoded_value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxInlineUniformTotalSize"], decoded_value.maxInlineUniformTotalSize, options);
        jdata["integerDotProduct8BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitUnsignedAccelerated);
        jdata["integerDotProduct8BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitSignedAccelerated);
        jdata["integerDotProduct8BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitMixedSignednessAccelerated);
        jdata["integerDotProduct4x8BitPackedUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedUnsignedAccelerated);
        jdata["integerDotProduct4x8BitPackedSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedSignedAccelerated);
        jdata["integerDotProduct4x8BitPackedMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedMixedSignednessAccelerated);
        jdata["integerDotProduct16BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitUnsignedAccelerated);
        jdata["integerDotProduct16BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitSignedAccelerated);
        jdata["integerDotProduct16BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitMixedSignednessAccelerated);
        jdata["integerDotProduct32BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitUnsignedAccelerated);
        jdata["integerDotProduct32BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitSignedAccelerated);
        jdata["integerDotProduct32BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitMixedSignednessAccelerated);
        jdata["integerDotProduct64BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitUnsignedAccelerated);
        jdata["integerDotProduct64BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitSignedAccelerated);
        jdata["integerDotProduct64BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);
        FieldToJsonResolve(jdata["storageTexelBufferOffsetAlignmentBytes"], decoded_value.storageTexelBufferOffsetAlignmentBytes, options);
        jdata["storageTexelBufferOffsetSingleTexelAlignment"] = static_cast<bool>(decoded_value.storageTexelBufferOffsetSingleTexelAlignment);
        FieldToJsonResolve(jdata["uniformTexelBufferOffsetAlignmentBytes"], decoded_value.uniformTexelBufferOffsetAlignmentBytes, options);
        jdata["uniformTexelBufferOffsetSingleTexelAlignment"] = static_cast<bool>(decoded_value.uniformTexelBufferOffsetSingleTexelAlignment);
        FieldToJsonResolve(jdata["maxBufferSize"], decoded_value.maxBufferSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan13Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan13Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCreationFeedback>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreationFeedback* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreationFeedback& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreationFeedback& meta_struct = *data;

        FieldToJson(VkPipelineCreationFeedbackFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["duration"], decoded_value.duration, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreationFeedback* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCreationFeedback>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCreationFeedbackCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreationFeedbackCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreationFeedbackCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreationFeedbackCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pPipelineCreationFeedback"], meta_struct.pPipelineCreationFeedback, options);
        FieldToJsonResolve(jdata["pipelineStageCreationFeedbackCount"], decoded_value.pipelineStageCreationFeedbackCount, options);
        FieldToJsonResolve(jdata["pPipelineStageCreationFeedbacks"], meta_struct.pPipelineStageCreationFeedbacks, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreationFeedbackCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCreationFeedbackCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTerminateInvocationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderTerminateInvocation"] = static_cast<bool>(decoded_value.shaderTerminateInvocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceToolProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceToolProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceToolProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceToolProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["version"], &meta_struct.version, options);
        FieldToJson(VkToolPurposeFlags_t(),jdata["purposes"], decoded_value.purposes, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["layer"], &meta_struct.layer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceToolProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceToolProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderDemoteToHelperInvocation"] = static_cast<bool>(decoded_value.shaderDemoteToHelperInvocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePrivateDataFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrivateDataFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrivateDataFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrivateDataFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["privateData"] = static_cast<bool>(decoded_value.privateData);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrivateDataFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePrivateDataFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDevicePrivateDataCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDevicePrivateDataCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDevicePrivateDataCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDevicePrivateDataCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["privateDataSlotRequestCount"], decoded_value.privateDataSlotRequestCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDevicePrivateDataCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDevicePrivateDataCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPrivateDataSlotCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPrivateDataSlotCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPrivateDataSlotCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPrivateDataSlotCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPrivateDataSlotCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPrivateDataSlotCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPrivateDataSlotCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineCreationCacheControlFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineCreationCacheControl"] = static_cast<bool>(decoded_value.pipelineCreationCacheControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryBarrier2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrier2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrier2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["srcStageMask"], decoded_value.srcStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["dstStageMask"], decoded_value.dstStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrier2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryBarrier2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferMemoryBarrier2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryBarrier2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferMemoryBarrier2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["srcStageMask"], decoded_value.srcStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["dstStageMask"], decoded_value.dstStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["srcQueueFamilyIndex"], decoded_value.srcQueueFamilyIndex, options);
        FieldToJsonResolve(jdata["dstQueueFamilyIndex"], decoded_value.dstQueueFamilyIndex, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferMemoryBarrier2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferMemoryBarrier2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageMemoryBarrier2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryBarrier2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageMemoryBarrier2& decoded_value = *data->decoded_value;
        const Decoded_VkImageMemoryBarrier2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["srcStageMask"], decoded_value.srcStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["srcAccessMask"], decoded_value.srcAccessMask, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["dstStageMask"], decoded_value.dstStageMask, options);
        FieldToJson(VkAccessFlags2_t(),jdata["dstAccessMask"], decoded_value.dstAccessMask, options);
        FieldToJsonResolve(jdata["oldLayout"], decoded_value.oldLayout, options);
        FieldToJsonResolve(jdata["newLayout"], decoded_value.newLayout, options);
        FieldToJsonResolve(jdata["srcQueueFamilyIndex"], decoded_value.srcQueueFamilyIndex, options);
        FieldToJsonResolve(jdata["dstQueueFamilyIndex"], decoded_value.dstQueueFamilyIndex, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["subresourceRange"], meta_struct.subresourceRange, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageMemoryBarrier2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageMemoryBarrier2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDependencyInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDependencyInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDependencyInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDependencyInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDependencyFlags_t(),jdata["dependencyFlags"], decoded_value.dependencyFlags, options);
        FieldToJsonResolve(jdata["memoryBarrierCount"], decoded_value.memoryBarrierCount, options);
        FieldToJsonResolve(jdata["pMemoryBarriers"], meta_struct.pMemoryBarriers, options);
        FieldToJsonResolve(jdata["bufferMemoryBarrierCount"], decoded_value.bufferMemoryBarrierCount, options);
        FieldToJsonResolve(jdata["pBufferMemoryBarriers"], meta_struct.pBufferMemoryBarriers, options);
        FieldToJsonResolve(jdata["imageMemoryBarrierCount"], decoded_value.imageMemoryBarrierCount, options);
        FieldToJsonResolve(jdata["pImageMemoryBarriers"], meta_struct.pImageMemoryBarriers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDependencyInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDependencyInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJsonResolve(jdata["value"], decoded_value.value, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["stageMask"], decoded_value.stageMask, options);
        FieldToJsonResolve(jdata["deviceIndex"], decoded_value.deviceIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferSubmitInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferSubmitInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferSubmitInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferSubmitInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["commandBuffer"], meta_struct.commandBuffer, options);
        FieldToJsonResolve(jdata["deviceMask"], decoded_value.deviceMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferSubmitInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferSubmitInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubmitInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubmitInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubmitInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkSubmitInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSubmitFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["waitSemaphoreInfoCount"], decoded_value.waitSemaphoreInfoCount, options);
        FieldToJsonResolve(jdata["pWaitSemaphoreInfos"], meta_struct.pWaitSemaphoreInfos, options);
        FieldToJsonResolve(jdata["commandBufferInfoCount"], decoded_value.commandBufferInfoCount, options);
        FieldToJsonResolve(jdata["pCommandBufferInfos"], meta_struct.pCommandBufferInfos, options);
        FieldToJsonResolve(jdata["signalSemaphoreInfoCount"], decoded_value.signalSemaphoreInfoCount, options);
        FieldToJsonResolve(jdata["pSignalSemaphoreInfos"], meta_struct.pSignalSemaphoreInfos, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubmitInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubmitInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSynchronization2Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSynchronization2Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSynchronization2Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSynchronization2Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["synchronization2"] = static_cast<bool>(decoded_value.synchronization2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSynchronization2Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSynchronization2Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderZeroInitializeWorkgroupMemory"] = static_cast<bool>(decoded_value.shaderZeroInitializeWorkgroupMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageRobustnessFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageRobustnessFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageRobustnessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageRobustnessFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["robustImageAccess"] = static_cast<bool>(decoded_value.robustImageAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageRobustnessFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageRobustnessFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferCopy2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferCopy2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferCopy2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcOffset"], decoded_value.srcOffset, options);
        FieldToJsonResolve(jdata["dstOffset"], decoded_value.dstOffset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferCopy2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferCopy2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyBufferInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyBufferInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyBufferInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyBufferInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcBuffer"], meta_struct.srcBuffer, options);
        HandleToJson(jdata["dstBuffer"], meta_struct.dstBuffer, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyBufferInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyBufferInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageCopy2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageCopy2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkImageCopy2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffset"], meta_struct.srcOffset, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffset"], meta_struct.dstOffset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageCopy2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageCopy2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyImageInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcImage"], meta_struct.srcImage, options);
        FieldToJsonResolve(jdata["srcImageLayout"], decoded_value.srcImageLayout, options);
        HandleToJson(jdata["dstImage"], meta_struct.dstImage, options);
        FieldToJsonResolve(jdata["dstImageLayout"], decoded_value.dstImageLayout, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyImageInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferImageCopy2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferImageCopy2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferImageCopy2& decoded_value = *data->decoded_value;
        const Decoded_VkBufferImageCopy2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["bufferOffset"], decoded_value.bufferOffset, options);
        FieldToJsonResolve(jdata["bufferRowLength"], decoded_value.bufferRowLength, options);
        FieldToJsonResolve(jdata["bufferImageHeight"], decoded_value.bufferImageHeight, options);
        FieldToJsonResolve(jdata["imageSubresource"], meta_struct.imageSubresource, options);
        FieldToJsonResolve(jdata["imageOffset"], meta_struct.imageOffset, options);
        FieldToJsonResolve(jdata["imageExtent"], meta_struct.imageExtent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferImageCopy2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferImageCopy2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyBufferToImageInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyBufferToImageInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyBufferToImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyBufferToImageInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcBuffer"], meta_struct.srcBuffer, options);
        HandleToJson(jdata["dstImage"], meta_struct.dstImage, options);
        FieldToJsonResolve(jdata["dstImageLayout"], decoded_value.dstImageLayout, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyBufferToImageInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyBufferToImageInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyImageToBufferInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageToBufferInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageToBufferInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageToBufferInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcImage"], meta_struct.srcImage, options);
        FieldToJsonResolve(jdata["srcImageLayout"], decoded_value.srcImageLayout, options);
        HandleToJson(jdata["dstBuffer"], meta_struct.dstBuffer, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageToBufferInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyImageToBufferInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageBlit2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageBlit2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageBlit2& decoded_value = *data->decoded_value;
        const Decoded_VkImageBlit2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffsets"], meta_struct.srcOffsets, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffsets"], meta_struct.dstOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageBlit2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageBlit2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBlitImageInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBlitImageInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBlitImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkBlitImageInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcImage"], meta_struct.srcImage, options);
        FieldToJsonResolve(jdata["srcImageLayout"], decoded_value.srcImageLayout, options);
        HandleToJson(jdata["dstImage"], meta_struct.dstImage, options);
        FieldToJsonResolve(jdata["dstImageLayout"], decoded_value.dstImageLayout, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["filter"], decoded_value.filter, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBlitImageInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBlitImageInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageResolve2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageResolve2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageResolve2& decoded_value = *data->decoded_value;
        const Decoded_VkImageResolve2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcSubresource"], meta_struct.srcSubresource, options);
        FieldToJsonResolve(jdata["srcOffset"], meta_struct.srcOffset, options);
        FieldToJsonResolve(jdata["dstSubresource"], meta_struct.dstSubresource, options);
        FieldToJsonResolve(jdata["dstOffset"], meta_struct.dstOffset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageResolve2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageResolve2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkResolveImageInfo2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkResolveImageInfo2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkResolveImageInfo2& decoded_value = *data->decoded_value;
        const Decoded_VkResolveImageInfo2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["srcImage"], meta_struct.srcImage, options);
        FieldToJsonResolve(jdata["srcImageLayout"], decoded_value.srcImageLayout, options);
        HandleToJson(jdata["dstImage"], meta_struct.dstImage, options);
        FieldToJsonResolve(jdata["dstImageLayout"], decoded_value.dstImageLayout, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkResolveImageInfo2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkResolveImageInfo2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupSizeControlFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["subgroupSizeControl"] = static_cast<bool>(decoded_value.subgroupSizeControl);
        jdata["computeFullSubgroups"] = static_cast<bool>(decoded_value.computeFullSubgroups);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupSizeControlProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubgroupSizeControlProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minSubgroupSize"], decoded_value.minSubgroupSize, options);
        FieldToJsonResolve(jdata["maxSubgroupSize"], decoded_value.maxSubgroupSize, options);
        FieldToJsonResolve(jdata["maxComputeWorkgroupSubgroups"], decoded_value.maxComputeWorkgroupSubgroups, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["requiredSubgroupSizeStages"], decoded_value.requiredSubgroupSizeStages, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSubgroupSizeControlProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["requiredSubgroupSize"], decoded_value.requiredSubgroupSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceInlineUniformBlockFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInlineUniformBlockFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["inlineUniformBlock"] = static_cast<bool>(decoded_value.inlineUniformBlock);
        jdata["descriptorBindingInlineUniformBlockUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingInlineUniformBlockUpdateAfterBind);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceInlineUniformBlockFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceInlineUniformBlockProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInlineUniformBlockProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInlineUniformBlockProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInlineUniformBlockProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxInlineUniformBlockSize"], decoded_value.maxInlineUniformBlockSize, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorInlineUniformBlocks"], decoded_value.maxPerStageDescriptorInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"], decoded_value.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxDescriptorSetInlineUniformBlocks"], decoded_value.maxDescriptorSetInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"], decoded_value.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInlineUniformBlockProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceInlineUniformBlockProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteDescriptorSetInlineUniformBlock>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetInlineUniformBlock* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetInlineUniformBlock& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetInlineUniformBlock& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["dataSize"], decoded_value.dataSize, options);
        FieldToJsonResolve(jdata["pData"], meta_struct.pData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetInlineUniformBlock* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteDescriptorSetInlineUniformBlock>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorPoolInlineUniformBlockCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxInlineUniformBlockBindings"], decoded_value.maxInlineUniformBlockBindings, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTextureCompressionASTCHDRFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["textureCompressionASTC_HDR"] = static_cast<bool>(decoded_value.textureCompressionASTC_HDR);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingAttachmentInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAttachmentInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAttachmentInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAttachmentInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["imageView"], meta_struct.imageView, options);
        FieldToJsonResolve(jdata["imageLayout"], decoded_value.imageLayout, options);
        FieldToJsonResolve(jdata["resolveMode"], decoded_value.resolveMode, options);
        HandleToJson(jdata["resolveImageView"], meta_struct.resolveImageView, options);
        FieldToJsonResolve(jdata["resolveImageLayout"], decoded_value.resolveImageLayout, options);
        FieldToJsonResolve(jdata["loadOp"], decoded_value.loadOp, options);
        FieldToJsonResolve(jdata["storeOp"], decoded_value.storeOp, options);
        FieldToJsonResolve(jdata["clearValue"], meta_struct.clearValue, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAttachmentInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingAttachmentInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkRenderingFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["renderArea"], meta_struct.renderArea, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
        FieldToJsonResolve(jdata["viewMask"], decoded_value.viewMask, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachments"], meta_struct.pColorAttachments, options);
        FieldToJsonResolve(jdata["pDepthAttachment"], meta_struct.pDepthAttachment, options);
        FieldToJsonResolve(jdata["pStencilAttachment"], meta_struct.pStencilAttachment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRenderingCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRenderingCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRenderingCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRenderingCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["viewMask"], decoded_value.viewMask, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentFormats"], meta_struct.pColorAttachmentFormats, options);
        FieldToJsonResolve(jdata["depthAttachmentFormat"], decoded_value.depthAttachmentFormat, options);
        FieldToJsonResolve(jdata["stencilAttachmentFormat"], decoded_value.stencilAttachmentFormat, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRenderingCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRenderingCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dynamicRendering"] = static_cast<bool>(decoded_value.dynamicRendering);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferInheritanceRenderingInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceRenderingInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceRenderingInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceRenderingInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkRenderingFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["viewMask"], decoded_value.viewMask, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentFormats"], meta_struct.pColorAttachmentFormats, options);
        FieldToJsonResolve(jdata["depthAttachmentFormat"], decoded_value.depthAttachmentFormat, options);
        FieldToJsonResolve(jdata["stencilAttachmentFormat"], decoded_value.stencilAttachmentFormat, options);
        FieldToJsonResolve(jdata["rasterizationSamples"], decoded_value.rasterizationSamples, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceRenderingInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferInheritanceRenderingInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerDotProductFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderIntegerDotProduct"] = static_cast<bool>(decoded_value.shaderIntegerDotProduct);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerDotProductProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["integerDotProduct8BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitUnsignedAccelerated);
        jdata["integerDotProduct8BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitSignedAccelerated);
        jdata["integerDotProduct8BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct8BitMixedSignednessAccelerated);
        jdata["integerDotProduct4x8BitPackedUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedUnsignedAccelerated);
        jdata["integerDotProduct4x8BitPackedSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedSignedAccelerated);
        jdata["integerDotProduct4x8BitPackedMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct4x8BitPackedMixedSignednessAccelerated);
        jdata["integerDotProduct16BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitUnsignedAccelerated);
        jdata["integerDotProduct16BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitSignedAccelerated);
        jdata["integerDotProduct16BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct16BitMixedSignednessAccelerated);
        jdata["integerDotProduct32BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitUnsignedAccelerated);
        jdata["integerDotProduct32BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitSignedAccelerated);
        jdata["integerDotProduct32BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct32BitMixedSignednessAccelerated);
        jdata["integerDotProduct64BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitUnsignedAccelerated);
        jdata["integerDotProduct64BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitSignedAccelerated);
        jdata["integerDotProduct64BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProduct64BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitSignedAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitSignedAccelerated);
        jdata["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"] = static_cast<bool>(decoded_value.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTexelBufferAlignmentProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["storageTexelBufferOffsetAlignmentBytes"], decoded_value.storageTexelBufferOffsetAlignmentBytes, options);
        jdata["storageTexelBufferOffsetSingleTexelAlignment"] = static_cast<bool>(decoded_value.storageTexelBufferOffsetSingleTexelAlignment);
        FieldToJsonResolve(jdata["uniformTexelBufferOffsetAlignmentBytes"], decoded_value.uniformTexelBufferOffsetAlignmentBytes, options);
        jdata["uniformTexelBufferOffsetSingleTexelAlignment"] = static_cast<bool>(decoded_value.uniformTexelBufferOffsetSingleTexelAlignment);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFormatProperties3>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties3* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFormatProperties3& decoded_value = *data->decoded_value;
        const Decoded_VkFormatProperties3& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkFormatFeatureFlags2_t(),jdata["linearTilingFeatures"], decoded_value.linearTilingFeatures, options);
        FieldToJson(VkFormatFeatureFlags2_t(),jdata["optimalTilingFeatures"], decoded_value.optimalTilingFeatures, options);
        FieldToJson(VkFormatFeatureFlags2_t(),jdata["bufferFeatures"], decoded_value.bufferFeatures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFormatProperties3* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFormatProperties3>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance4Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance4Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance4Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance4Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance4"] = static_cast<bool>(decoded_value.maintenance4);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance4Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance4Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance4Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance4Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance4Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance4Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxBufferSize"], decoded_value.maxBufferSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance4Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance4Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceBufferMemoryRequirements>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceBufferMemoryRequirements* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceBufferMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceBufferMemoryRequirements& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pCreateInfo"], meta_struct.pCreateInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceBufferMemoryRequirements* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceBufferMemoryRequirements>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceImageMemoryRequirements>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceImageMemoryRequirements* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceImageMemoryRequirements& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceImageMemoryRequirements& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pCreateInfo"], meta_struct.pCreateInfo, options);
        FieldToJsonResolve(jdata["planeAspect"], decoded_value.planeAspect, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceImageMemoryRequirements* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceImageMemoryRequirements>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan14Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan14Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan14Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan14Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["globalPriorityQuery"] = static_cast<bool>(decoded_value.globalPriorityQuery);
        jdata["shaderSubgroupRotate"] = static_cast<bool>(decoded_value.shaderSubgroupRotate);
        jdata["shaderSubgroupRotateClustered"] = static_cast<bool>(decoded_value.shaderSubgroupRotateClustered);
        jdata["shaderFloatControls2"] = static_cast<bool>(decoded_value.shaderFloatControls2);
        jdata["shaderExpectAssume"] = static_cast<bool>(decoded_value.shaderExpectAssume);
        jdata["rectangularLines"] = static_cast<bool>(decoded_value.rectangularLines);
        jdata["bresenhamLines"] = static_cast<bool>(decoded_value.bresenhamLines);
        jdata["smoothLines"] = static_cast<bool>(decoded_value.smoothLines);
        jdata["stippledRectangularLines"] = static_cast<bool>(decoded_value.stippledRectangularLines);
        jdata["stippledBresenhamLines"] = static_cast<bool>(decoded_value.stippledBresenhamLines);
        jdata["stippledSmoothLines"] = static_cast<bool>(decoded_value.stippledSmoothLines);
        jdata["vertexAttributeInstanceRateDivisor"] = static_cast<bool>(decoded_value.vertexAttributeInstanceRateDivisor);
        jdata["vertexAttributeInstanceRateZeroDivisor"] = static_cast<bool>(decoded_value.vertexAttributeInstanceRateZeroDivisor);
        jdata["indexTypeUint8"] = static_cast<bool>(decoded_value.indexTypeUint8);
        jdata["dynamicRenderingLocalRead"] = static_cast<bool>(decoded_value.dynamicRenderingLocalRead);
        jdata["maintenance5"] = static_cast<bool>(decoded_value.maintenance5);
        jdata["maintenance6"] = static_cast<bool>(decoded_value.maintenance6);
        jdata["pipelineProtectedAccess"] = static_cast<bool>(decoded_value.pipelineProtectedAccess);
        jdata["pipelineRobustness"] = static_cast<bool>(decoded_value.pipelineRobustness);
        jdata["hostImageCopy"] = static_cast<bool>(decoded_value.hostImageCopy);
        jdata["pushDescriptor"] = static_cast<bool>(decoded_value.pushDescriptor);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan14Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan14Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan14Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan14Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVulkan14Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVulkan14Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["lineSubPixelPrecisionBits"], decoded_value.lineSubPixelPrecisionBits, options);
        FieldToJsonResolve(jdata["maxVertexAttribDivisor"], decoded_value.maxVertexAttribDivisor, options);
        jdata["supportsNonZeroFirstInstance"] = static_cast<bool>(decoded_value.supportsNonZeroFirstInstance);
        FieldToJsonResolve(jdata["maxPushDescriptors"], decoded_value.maxPushDescriptors, options);
        jdata["dynamicRenderingLocalReadDepthStencilAttachments"] = static_cast<bool>(decoded_value.dynamicRenderingLocalReadDepthStencilAttachments);
        jdata["dynamicRenderingLocalReadMultisampledAttachments"] = static_cast<bool>(decoded_value.dynamicRenderingLocalReadMultisampledAttachments);
        jdata["earlyFragmentMultisampleCoverageAfterSampleCounting"] = static_cast<bool>(decoded_value.earlyFragmentMultisampleCoverageAfterSampleCounting);
        jdata["earlyFragmentSampleMaskTestBeforeSampleCounting"] = static_cast<bool>(decoded_value.earlyFragmentSampleMaskTestBeforeSampleCounting);
        jdata["depthStencilSwizzleOneSupport"] = static_cast<bool>(decoded_value.depthStencilSwizzleOneSupport);
        jdata["polygonModePointSize"] = static_cast<bool>(decoded_value.polygonModePointSize);
        jdata["nonStrictSinglePixelWideLinesUseParallelogram"] = static_cast<bool>(decoded_value.nonStrictSinglePixelWideLinesUseParallelogram);
        jdata["nonStrictWideLinesUseParallelogram"] = static_cast<bool>(decoded_value.nonStrictWideLinesUseParallelogram);
        jdata["blockTexelViewCompatibleMultipleLayers"] = static_cast<bool>(decoded_value.blockTexelViewCompatibleMultipleLayers);
        FieldToJsonResolve(jdata["maxCombinedImageSamplerDescriptorCount"], decoded_value.maxCombinedImageSamplerDescriptorCount, options);
        jdata["fragmentShadingRateClampCombinerInputs"] = static_cast<bool>(decoded_value.fragmentShadingRateClampCombinerInputs);
        FieldToJsonResolve(jdata["defaultRobustnessStorageBuffers"], decoded_value.defaultRobustnessStorageBuffers, options);
        FieldToJsonResolve(jdata["defaultRobustnessUniformBuffers"], decoded_value.defaultRobustnessUniformBuffers, options);
        FieldToJsonResolve(jdata["defaultRobustnessVertexInputs"], decoded_value.defaultRobustnessVertexInputs, options);
        FieldToJsonResolve(jdata["defaultRobustnessImages"], decoded_value.defaultRobustnessImages, options);
        FieldToJsonResolve(jdata["copySrcLayoutCount"], decoded_value.copySrcLayoutCount, options);
        FieldToJsonResolve(jdata["pCopySrcLayouts"], meta_struct.pCopySrcLayouts, options);
        FieldToJsonResolve(jdata["copyDstLayoutCount"], decoded_value.copyDstLayoutCount, options);
        FieldToJsonResolve(jdata["pCopyDstLayouts"], meta_struct.pCopyDstLayouts, options);
        FieldToJsonResolve(jdata["optimalTilingLayoutUUID"], uuid_to_string(sizeof(decoded_value.optimalTilingLayoutUUID), decoded_value.optimalTilingLayoutUUID), options);
        jdata["identicalMemoryTypeRequirements"] = static_cast<bool>(decoded_value.identicalMemoryTypeRequirements);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVulkan14Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVulkan14Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceQueueGlobalPriorityCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueGlobalPriorityCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueGlobalPriorityCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueGlobalPriorityCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["globalPriority"], decoded_value.globalPriority, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueGlobalPriorityCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceQueueGlobalPriorityCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGlobalPriorityQueryFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["globalPriorityQuery"] = static_cast<bool>(decoded_value.globalPriorityQuery);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyGlobalPriorityProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyGlobalPriorityProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyGlobalPriorityProperties& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyGlobalPriorityProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["priorityCount"], decoded_value.priorityCount, options);
        FieldToJsonResolve(jdata["priorities"], &meta_struct.priorities, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyGlobalPriorityProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyGlobalPriorityProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupRotateFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderSubgroupRotate"] = static_cast<bool>(decoded_value.shaderSubgroupRotate);
        jdata["shaderSubgroupRotateClustered"] = static_cast<bool>(decoded_value.shaderSubgroupRotateClustered);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloatControls2Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloatControls2Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderFloatControls2Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderFloatControls2Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderFloatControls2"] = static_cast<bool>(decoded_value.shaderFloatControls2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloatControls2Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloatControls2Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderExpectAssumeFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderExpectAssume"] = static_cast<bool>(decoded_value.shaderExpectAssume);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLineRasterizationFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLineRasterizationFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLineRasterizationFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLineRasterizationFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rectangularLines"] = static_cast<bool>(decoded_value.rectangularLines);
        jdata["bresenhamLines"] = static_cast<bool>(decoded_value.bresenhamLines);
        jdata["smoothLines"] = static_cast<bool>(decoded_value.smoothLines);
        jdata["stippledRectangularLines"] = static_cast<bool>(decoded_value.stippledRectangularLines);
        jdata["stippledBresenhamLines"] = static_cast<bool>(decoded_value.stippledBresenhamLines);
        jdata["stippledSmoothLines"] = static_cast<bool>(decoded_value.stippledSmoothLines);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLineRasterizationFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLineRasterizationFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLineRasterizationProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLineRasterizationProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLineRasterizationProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLineRasterizationProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["lineSubPixelPrecisionBits"], decoded_value.lineSubPixelPrecisionBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLineRasterizationProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLineRasterizationProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationLineStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationLineStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationLineStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationLineStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["lineRasterizationMode"], decoded_value.lineRasterizationMode, options);
        jdata["stippledLineEnable"] = static_cast<bool>(decoded_value.stippledLineEnable);
        FieldToJsonResolve(jdata["lineStippleFactor"], decoded_value.lineStippleFactor, options);
        FieldToJsonResolve(jdata["lineStipplePattern"], decoded_value.lineStipplePattern, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationLineStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationLineStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxVertexAttribDivisor"], decoded_value.maxVertexAttribDivisor, options);
        jdata["supportsNonZeroFirstInstance"] = static_cast<bool>(decoded_value.supportsNonZeroFirstInstance);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVertexInputBindingDivisorDescription>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDivisorDescription* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDivisorDescription& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDivisorDescription& meta_struct = *data;

        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["divisor"], decoded_value.divisor, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDivisorDescription* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVertexInputBindingDivisorDescription>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineVertexInputDivisorStateCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineVertexInputDivisorStateCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineVertexInputDivisorStateCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineVertexInputDivisorStateCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vertexBindingDivisorCount"], decoded_value.vertexBindingDivisorCount, options);
        FieldToJsonResolve(jdata["pVertexBindingDivisors"], meta_struct.pVertexBindingDivisors, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineVertexInputDivisorStateCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineVertexInputDivisorStateCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["vertexAttributeInstanceRateDivisor"] = static_cast<bool>(decoded_value.vertexAttributeInstanceRateDivisor);
        jdata["vertexAttributeInstanceRateZeroDivisor"] = static_cast<bool>(decoded_value.vertexAttributeInstanceRateZeroDivisor);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceIndexTypeUint8Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceIndexTypeUint8Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceIndexTypeUint8Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceIndexTypeUint8Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["indexTypeUint8"] = static_cast<bool>(decoded_value.indexTypeUint8);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceIndexTypeUint8Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceIndexTypeUint8Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryMapInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMapInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMapInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMapInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMemoryMapFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMapInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryMapInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryUnmapInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryUnmapInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryUnmapInfo& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryUnmapInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMemoryUnmapFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryUnmapInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryUnmapInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance5Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance5Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance5Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance5Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance5"] = static_cast<bool>(decoded_value.maintenance5);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance5Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance5Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance5Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance5Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance5Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance5Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["earlyFragmentMultisampleCoverageAfterSampleCounting"] = static_cast<bool>(decoded_value.earlyFragmentMultisampleCoverageAfterSampleCounting);
        jdata["earlyFragmentSampleMaskTestBeforeSampleCounting"] = static_cast<bool>(decoded_value.earlyFragmentSampleMaskTestBeforeSampleCounting);
        jdata["depthStencilSwizzleOneSupport"] = static_cast<bool>(decoded_value.depthStencilSwizzleOneSupport);
        jdata["polygonModePointSize"] = static_cast<bool>(decoded_value.polygonModePointSize);
        jdata["nonStrictSinglePixelWideLinesUseParallelogram"] = static_cast<bool>(decoded_value.nonStrictSinglePixelWideLinesUseParallelogram);
        jdata["nonStrictWideLinesUseParallelogram"] = static_cast<bool>(decoded_value.nonStrictWideLinesUseParallelogram);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance5Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance5Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingAreaInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAreaInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAreaInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAreaInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["viewMask"], decoded_value.viewMask, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentFormats"], meta_struct.pColorAttachmentFormats, options);
        FieldToJsonResolve(jdata["depthAttachmentFormat"], decoded_value.depthAttachmentFormat, options);
        FieldToJsonResolve(jdata["stencilAttachmentFormat"], decoded_value.stencilAttachmentFormat, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAreaInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingAreaInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSubresource2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresource2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSubresource2& decoded_value = *data->decoded_value;
        const Decoded_VkImageSubresource2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["imageSubresource"], meta_struct.imageSubresource, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSubresource2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSubresource2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceImageSubresourceInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceImageSubresourceInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceImageSubresourceInfo& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceImageSubresourceInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pCreateInfo"], meta_struct.pCreateInfo, options);
        FieldToJsonResolve(jdata["pSubresource"], meta_struct.pSubresource, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceImageSubresourceInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceImageSubresourceInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubresourceLayout2>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceLayout2* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceLayout2& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceLayout2& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["subresourceLayout"], meta_struct.subresourceLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceLayout2* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubresourceLayout2>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCreateFlags2CreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreateFlags2CreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreateFlags2CreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreateFlags2CreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCreateFlags2_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreateFlags2CreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCreateFlags2CreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferUsageFlags2CreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferUsageFlags2CreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferUsageFlags2CreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBufferUsageFlags2CreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkBufferUsageFlags2_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferUsageFlags2CreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferUsageFlags2CreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePushDescriptorProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePushDescriptorProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePushDescriptorProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePushDescriptorProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxPushDescriptors"], decoded_value.maxPushDescriptors, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePushDescriptorProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePushDescriptorProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingLocalReadFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dynamicRenderingLocalRead"] = static_cast<bool>(decoded_value.dynamicRenderingLocalRead);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingAttachmentLocationInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAttachmentLocationInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingAttachmentLocationInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingAttachmentLocationInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentLocations"], meta_struct.pColorAttachmentLocations, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingAttachmentLocationInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingAttachmentLocationInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingInputAttachmentIndexInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingInputAttachmentIndexInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingInputAttachmentIndexInfo& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingInputAttachmentIndexInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentInputIndices"], meta_struct.pColorAttachmentInputIndices, options);
        FieldToJsonResolve(jdata["pDepthInputAttachmentIndex"], meta_struct.pDepthInputAttachmentIndex, options);
        FieldToJsonResolve(jdata["pStencilInputAttachmentIndex"], meta_struct.pStencilInputAttachmentIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingInputAttachmentIndexInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingInputAttachmentIndexInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance6Features>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance6Features* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance6Features& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance6Features& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance6"] = static_cast<bool>(decoded_value.maintenance6);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance6Features* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance6Features>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance6Properties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance6Properties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance6Properties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance6Properties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["blockTexelViewCompatibleMultipleLayers"] = static_cast<bool>(decoded_value.blockTexelViewCompatibleMultipleLayers);
        FieldToJsonResolve(jdata["maxCombinedImageSamplerDescriptorCount"], decoded_value.maxCombinedImageSamplerDescriptorCount, options);
        jdata["fragmentShadingRateClampCombinerInputs"] = static_cast<bool>(decoded_value.fragmentShadingRateClampCombinerInputs);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance6Properties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance6Properties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindMemoryStatus>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindMemoryStatus* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindMemoryStatus& decoded_value = *data->decoded_value;
        const Decoded_VkBindMemoryStatus& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pResult"], meta_struct.pResult, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindMemoryStatus* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindMemoryStatus>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindDescriptorSetsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindDescriptorSetsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindDescriptorSetsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkBindDescriptorSetsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        FieldToJsonResolve(jdata["firstSet"], decoded_value.firstSet, options);
        FieldToJsonResolve(jdata["descriptorSetCount"], decoded_value.descriptorSetCount, options);
        HandleToJson(jdata["pDescriptorSets"], &meta_struct.pDescriptorSets, options);
        FieldToJsonResolve(jdata["dynamicOffsetCount"], decoded_value.dynamicOffsetCount, options);
        FieldToJsonResolve(jdata["pDynamicOffsets"], meta_struct.pDynamicOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindDescriptorSetsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindDescriptorSetsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPushConstantsInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPushConstantsInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPushConstantsInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPushConstantsInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pValues"], meta_struct.pValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPushConstantsInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPushConstantsInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPushDescriptorSetInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPushDescriptorSetInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPushDescriptorSetInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPushDescriptorSetInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        FieldToJsonResolve(jdata["set"], decoded_value.set, options);
        FieldToJsonResolve(jdata["descriptorWriteCount"], decoded_value.descriptorWriteCount, options);
        FieldToJsonResolve(jdata["pDescriptorWrites"], meta_struct.pDescriptorWrites, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPushDescriptorSetInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPushDescriptorSetInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineProtectedAccessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineProtectedAccess"] = static_cast<bool>(decoded_value.pipelineProtectedAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineRobustnessFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineRobustnessFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineRobustnessFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineRobustnessFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineRobustness"] = static_cast<bool>(decoded_value.pipelineRobustness);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineRobustnessFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineRobustnessFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineRobustnessProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineRobustnessProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineRobustnessProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineRobustnessProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["defaultRobustnessStorageBuffers"], decoded_value.defaultRobustnessStorageBuffers, options);
        FieldToJsonResolve(jdata["defaultRobustnessUniformBuffers"], decoded_value.defaultRobustnessUniformBuffers, options);
        FieldToJsonResolve(jdata["defaultRobustnessVertexInputs"], decoded_value.defaultRobustnessVertexInputs, options);
        FieldToJsonResolve(jdata["defaultRobustnessImages"], decoded_value.defaultRobustnessImages, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineRobustnessProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineRobustnessProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRobustnessCreateInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRobustnessCreateInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRobustnessCreateInfo& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRobustnessCreateInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["storageBuffers"], decoded_value.storageBuffers, options);
        FieldToJsonResolve(jdata["uniformBuffers"], decoded_value.uniformBuffers, options);
        FieldToJsonResolve(jdata["vertexInputs"], decoded_value.vertexInputs, options);
        FieldToJsonResolve(jdata["images"], decoded_value.images, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRobustnessCreateInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRobustnessCreateInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceHostImageCopyFeatures>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostImageCopyFeatures* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostImageCopyFeatures& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostImageCopyFeatures& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hostImageCopy"] = static_cast<bool>(decoded_value.hostImageCopy);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostImageCopyFeatures* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceHostImageCopyFeatures>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceHostImageCopyProperties>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostImageCopyProperties* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHostImageCopyProperties& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHostImageCopyProperties& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["copySrcLayoutCount"], decoded_value.copySrcLayoutCount, options);
        FieldToJsonResolve(jdata["pCopySrcLayouts"], meta_struct.pCopySrcLayouts, options);
        FieldToJsonResolve(jdata["copyDstLayoutCount"], decoded_value.copyDstLayoutCount, options);
        FieldToJsonResolve(jdata["pCopyDstLayouts"], meta_struct.pCopyDstLayouts, options);
        FieldToJsonResolve(jdata["optimalTilingLayoutUUID"], uuid_to_string(sizeof(decoded_value.optimalTilingLayoutUUID), decoded_value.optimalTilingLayoutUUID), options);
        jdata["identicalMemoryTypeRequirements"] = static_cast<bool>(decoded_value.identicalMemoryTypeRequirements);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHostImageCopyProperties* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceHostImageCopyProperties>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyImageToImageInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageToImageInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyImageToImageInfo& decoded_value = *data->decoded_value;
        const Decoded_VkCopyImageToImageInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkHostImageCopyFlags_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["srcImage"], meta_struct.srcImage, options);
        FieldToJsonResolve(jdata["srcImageLayout"], decoded_value.srcImageLayout, options);
        HandleToJson(jdata["dstImage"], meta_struct.dstImage, options);
        FieldToJsonResolve(jdata["dstImageLayout"], decoded_value.dstImageLayout, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyImageToImageInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyImageToImageInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkHostImageLayoutTransitionInfo>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkHostImageLayoutTransitionInfo* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkHostImageLayoutTransitionInfo& decoded_value = *data->decoded_value;
        const Decoded_VkHostImageLayoutTransitionInfo& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        FieldToJsonResolve(jdata["oldLayout"], decoded_value.oldLayout, options);
        FieldToJsonResolve(jdata["newLayout"], decoded_value.newLayout, options);
        FieldToJsonResolve(jdata["subresourceRange"], meta_struct.subresourceRange, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkHostImageLayoutTransitionInfo* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkHostImageLayoutTransitionInfo>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubresourceHostMemcpySize>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceHostMemcpySize* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubresourceHostMemcpySize& decoded_value = *data->decoded_value;
        const Decoded_VkSubresourceHostMemcpySize& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubresourceHostMemcpySize* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubresourceHostMemcpySize>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkHostImageCopyDevicePerformanceQuery>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkHostImageCopyDevicePerformanceQuery* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkHostImageCopyDevicePerformanceQuery& decoded_value = *data->decoded_value;
        const Decoded_VkHostImageCopyDevicePerformanceQuery& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["optimalDeviceAccess"] = static_cast<bool>(decoded_value.optimalDeviceAccess);
        jdata["identicalMemoryLayout"] = static_cast<bool>(decoded_value.identicalMemoryLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkHostImageCopyDevicePerformanceQuery* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkHostImageCopyDevicePerformanceQuery>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["minImageCount"], decoded_value.minImageCount, options);
        FieldToJsonResolve(jdata["maxImageCount"], decoded_value.maxImageCount, options);
        FieldToJsonResolve(jdata["currentExtent"], meta_struct.currentExtent, options);
        FieldToJsonResolve(jdata["minImageExtent"], meta_struct.minImageExtent, options);
        FieldToJsonResolve(jdata["maxImageExtent"], meta_struct.maxImageExtent, options);
        FieldToJsonResolve(jdata["maxImageArrayLayers"], decoded_value.maxImageArrayLayers, options);
        FieldToJson(VkSurfaceTransformFlagsKHR_t(),jdata["supportedTransforms"], decoded_value.supportedTransforms, options);
        FieldToJsonResolve(jdata["currentTransform"], decoded_value.currentTransform, options);
        FieldToJson(VkCompositeAlphaFlagsKHR_t(),jdata["supportedCompositeAlpha"], decoded_value.supportedCompositeAlpha, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["supportedUsageFlags"], decoded_value.supportedUsageFlags, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceFormatKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFormatKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFormatKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFormatKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["colorSpace"], decoded_value.colorSpace, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFormatKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceFormatKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSwapchainCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["surface"], meta_struct.surface, options);
        FieldToJsonResolve(jdata["minImageCount"], decoded_value.minImageCount, options);
        FieldToJsonResolve(jdata["imageFormat"], decoded_value.imageFormat, options);
        FieldToJsonResolve(jdata["imageColorSpace"], decoded_value.imageColorSpace, options);
        FieldToJsonResolve(jdata["imageExtent"], meta_struct.imageExtent, options);
        FieldToJsonResolve(jdata["imageArrayLayers"], decoded_value.imageArrayLayers, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["imageUsage"], decoded_value.imageUsage, options);
        FieldToJsonResolve(jdata["imageSharingMode"], decoded_value.imageSharingMode, options);
        FieldToJsonResolve(jdata["queueFamilyIndexCount"], decoded_value.queueFamilyIndexCount, options);
        FieldToJsonResolve(jdata["pQueueFamilyIndices"], meta_struct.pQueueFamilyIndices, options);
        FieldToJsonResolve(jdata["preTransform"], decoded_value.preTransform, options);
        FieldToJsonResolve(jdata["compositeAlpha"], decoded_value.compositeAlpha, options);
        FieldToJsonResolve(jdata["presentMode"], decoded_value.presentMode, options);
        jdata["clipped"] = static_cast<bool>(decoded_value.clipped);
        HandleToJson(jdata["oldSwapchain"], meta_struct.oldSwapchain, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreCount"], decoded_value.waitSemaphoreCount, options);
        HandleToJson(jdata["pWaitSemaphores"], &meta_struct.pWaitSemaphores, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        HandleToJson(jdata["pSwapchains"], &meta_struct.pSwapchains, options);
        FieldToJsonResolve(jdata["pImageIndices"], meta_struct.pImageIndices, options);
        FieldToJsonResolve(jdata["pResults"], meta_struct.pResults, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageSwapchainCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageSwapchainCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImageSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["swapchain"], meta_struct.swapchain, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageSwapchainCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageSwapchainCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindImageMemorySwapchainInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemorySwapchainInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindImageMemorySwapchainInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkBindImageMemorySwapchainInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["swapchain"], meta_struct.swapchain, options);
        FieldToJsonResolve(jdata["imageIndex"], decoded_value.imageIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindImageMemorySwapchainInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindImageMemorySwapchainInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAcquireNextImageInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAcquireNextImageInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAcquireNextImageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAcquireNextImageInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["swapchain"], meta_struct.swapchain, options);
        FieldToJsonResolve(jdata["timeout"], decoded_value.timeout, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        HandleToJson(jdata["fence"], meta_struct.fence, options);
        FieldToJsonResolve(jdata["deviceMask"], decoded_value.deviceMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAcquireNextImageInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAcquireNextImageInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupPresentCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupPresentCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupPresentCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupPresentCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentMask"], &meta_struct.presentMask, options);
        FieldToJson(VkDeviceGroupPresentModeFlagsKHR_t(),jdata["modes"], decoded_value.modes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupPresentCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupPresentCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupPresentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupPresentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupPresentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pDeviceMasks"], meta_struct.pDeviceMasks, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupPresentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupPresentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceGroupSwapchainCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceGroupSwapchainCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceGroupPresentModeFlagsKHR_t(),jdata["modes"], decoded_value.modes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceGroupSwapchainCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceGroupSwapchainCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayModeParametersKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeParametersKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeParametersKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeParametersKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["visibleRegion"], meta_struct.visibleRegion, options);
        FieldToJsonResolve(jdata["refreshRate"], decoded_value.refreshRate, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeParametersKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayModeParametersKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayModeCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDisplayModeCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["parameters"], meta_struct.parameters, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayModeCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayModePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModePropertiesKHR& meta_struct = *data;

        HandleToJson(jdata["displayMode"], meta_struct.displayMode, options);
        FieldToJsonResolve(jdata["parameters"], meta_struct.parameters, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayModePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPlaneCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneCapabilitiesKHR& meta_struct = *data;

        FieldToJson(VkDisplayPlaneAlphaFlagsKHR_t(),jdata["supportedAlpha"], decoded_value.supportedAlpha, options);
        FieldToJsonResolve(jdata["minSrcPosition"], meta_struct.minSrcPosition, options);
        FieldToJsonResolve(jdata["maxSrcPosition"], meta_struct.maxSrcPosition, options);
        FieldToJsonResolve(jdata["minSrcExtent"], meta_struct.minSrcExtent, options);
        FieldToJsonResolve(jdata["maxSrcExtent"], meta_struct.maxSrcExtent, options);
        FieldToJsonResolve(jdata["minDstPosition"], meta_struct.minDstPosition, options);
        FieldToJsonResolve(jdata["maxDstPosition"], meta_struct.maxDstPosition, options);
        FieldToJsonResolve(jdata["minDstExtent"], meta_struct.minDstExtent, options);
        FieldToJsonResolve(jdata["maxDstExtent"], meta_struct.maxDstExtent, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPlaneCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPlanePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlanePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlanePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlanePropertiesKHR& meta_struct = *data;

        HandleToJson(jdata["currentDisplay"], meta_struct.currentDisplay, options);
        FieldToJsonResolve(jdata["currentStackIndex"], decoded_value.currentStackIndex, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlanePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPlanePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPropertiesKHR& meta_struct = *data;

        HandleToJson(jdata["display"], meta_struct.display, options);
        FieldToJsonResolve(jdata["displayName"], &meta_struct.displayName, options);
        FieldToJsonResolve(jdata["physicalDimensions"], meta_struct.physicalDimensions, options);
        FieldToJsonResolve(jdata["physicalResolution"], meta_struct.physicalResolution, options);
        FieldToJson(VkSurfaceTransformFlagsKHR_t(),jdata["supportedTransforms"], decoded_value.supportedTransforms, options);
        jdata["planeReorderPossible"] = static_cast<bool>(decoded_value.planeReorderPossible);
        jdata["persistentContent"] = static_cast<bool>(decoded_value.persistentContent);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplaySurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplaySurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplaySurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplaySurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDisplaySurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["displayMode"], meta_struct.displayMode, options);
        FieldToJsonResolve(jdata["planeIndex"], decoded_value.planeIndex, options);
        FieldToJsonResolve(jdata["planeStackIndex"], decoded_value.planeStackIndex, options);
        FieldToJsonResolve(jdata["transform"], decoded_value.transform, options);
        FieldToJsonResolve(jdata["globalAlpha"], decoded_value.globalAlpha, options);
        FieldToJsonResolve(jdata["alphaMode"], decoded_value.alphaMode, options);
        FieldToJsonResolve(jdata["imageExtent"], meta_struct.imageExtent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplaySurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplaySurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPresentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPresentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPresentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPresentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcRect"], meta_struct.srcRect, options);
        FieldToJsonResolve(jdata["dstRect"], meta_struct.dstRect, options);
        jdata["persistent"] = static_cast<bool>(decoded_value.persistent);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPresentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPresentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkXlibSurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkXlibSurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkXlibSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkXlibSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkXlibSurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["dpy"], meta_struct.dpy, options);
        FieldToJsonResolve(jdata["window"], decoded_value.window, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkXlibSurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkXlibSurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkXcbSurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkXcbSurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkXcbSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkXcbSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkXcbSurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["connection"], meta_struct.connection, options);
        FieldToJsonResolve(jdata["window"], decoded_value.window, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkXcbSurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkXcbSurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWaylandSurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWaylandSurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWaylandSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWaylandSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkWaylandSurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["display"], meta_struct.display, options);
        FieldToJsonResolve(jdata["surface"], meta_struct.surface, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWaylandSurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWaylandSurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidSurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidSurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidSurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidSurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAndroidSurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["window"], meta_struct.window, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidSurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidSurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWin32SurfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWin32SurfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWin32SurfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWin32SurfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkWin32SurfaceCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["hinstance"], meta_struct.hinstance, options);
        FieldToJsonResolve(jdata["hwnd"], meta_struct.hwnd, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWin32SurfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWin32SurfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyQueryResultStatusPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["queryResultStatusSupport"] = static_cast<bool>(decoded_value.queryResultStatusSupport);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyVideoPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyVideoPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyVideoPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyVideoPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoCodecOperationFlagsKHR_t(),jdata["videoCodecOperations"], decoded_value.videoCodecOperations, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyVideoPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyVideoPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["videoCodecOperation"], decoded_value.videoCodecOperation, options);
        FieldToJson(VkVideoChromaSubsamplingFlagsKHR_t(),jdata["chromaSubsampling"], decoded_value.chromaSubsampling, options);
        FieldToJson(VkVideoComponentBitDepthFlagsKHR_t(),jdata["lumaBitDepth"], decoded_value.lumaBitDepth, options);
        FieldToJson(VkVideoComponentBitDepthFlagsKHR_t(),jdata["chromaBitDepth"], decoded_value.chromaBitDepth, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoProfileListInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoProfileListInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoProfileListInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoProfileListInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["profileCount"], decoded_value.profileCount, options);
        FieldToJsonResolve(jdata["pProfiles"], meta_struct.pProfiles, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoProfileListInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoProfileListInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoCapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["minBitstreamBufferOffsetAlignment"], decoded_value.minBitstreamBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minBitstreamBufferSizeAlignment"], decoded_value.minBitstreamBufferSizeAlignment, options);
        FieldToJsonResolve(jdata["pictureAccessGranularity"], meta_struct.pictureAccessGranularity, options);
        FieldToJsonResolve(jdata["minCodedExtent"], meta_struct.minCodedExtent, options);
        FieldToJsonResolve(jdata["maxCodedExtent"], meta_struct.maxCodedExtent, options);
        FieldToJsonResolve(jdata["maxDpbSlots"], decoded_value.maxDpbSlots, options);
        FieldToJsonResolve(jdata["maxActiveReferencePictures"], decoded_value.maxActiveReferencePictures, options);
        FieldToJsonResolve(jdata["stdHeaderVersion"], meta_struct.stdHeaderVersion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoFormatInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoFormatInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoFormatInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoFormatInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["imageUsage"], decoded_value.imageUsage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoFormatInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoFormatInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoFormatPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["componentMapping"], meta_struct.componentMapping, options);
        FieldToJson(VkImageCreateFlags_t(),jdata["imageCreateFlags"], decoded_value.imageCreateFlags, options);
        FieldToJsonResolve(jdata["imageType"], decoded_value.imageType, options);
        FieldToJsonResolve(jdata["imageTiling"], decoded_value.imageTiling, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["imageUsageFlags"], decoded_value.imageUsageFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoFormatPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoPictureResourceInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoPictureResourceInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoPictureResourceInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoPictureResourceInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["codedOffset"], meta_struct.codedOffset, options);
        FieldToJsonResolve(jdata["codedExtent"], meta_struct.codedExtent, options);
        FieldToJsonResolve(jdata["baseArrayLayer"], decoded_value.baseArrayLayer, options);
        HandleToJson(jdata["imageViewBinding"], meta_struct.imageViewBinding, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoPictureResourceInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoPictureResourceInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoReferenceSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoReferenceSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoReferenceSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoReferenceSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["slotIndex"], decoded_value.slotIndex, options);
        FieldToJsonResolve(jdata["pPictureResource"], meta_struct.pPictureResource, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoReferenceSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoReferenceSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoSessionMemoryRequirementsKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionMemoryRequirementsKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionMemoryRequirementsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionMemoryRequirementsKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryBindIndex"], decoded_value.memoryBindIndex, options);
        FieldToJsonResolve(jdata["memoryRequirements"], meta_struct.memoryRequirements, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionMemoryRequirementsKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoSessionMemoryRequirementsKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindVideoSessionMemoryInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindVideoSessionMemoryInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindVideoSessionMemoryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkBindVideoSessionMemoryInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryBindIndex"], decoded_value.memoryBindIndex, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJsonResolve(jdata["memorySize"], decoded_value.memorySize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindVideoSessionMemoryInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindVideoSessionMemoryInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoSessionCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["queueFamilyIndex"], decoded_value.queueFamilyIndex, options);
        FieldToJson(VkVideoSessionCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pVideoProfile"], meta_struct.pVideoProfile, options);
        FieldToJsonResolve(jdata["pictureFormat"], decoded_value.pictureFormat, options);
        FieldToJsonResolve(jdata["maxCodedExtent"], meta_struct.maxCodedExtent, options);
        FieldToJsonResolve(jdata["referencePictureFormat"], decoded_value.referencePictureFormat, options);
        FieldToJsonResolve(jdata["maxDpbSlots"], decoded_value.maxDpbSlots, options);
        FieldToJsonResolve(jdata["maxActiveReferencePictures"], decoded_value.maxActiveReferencePictures, options);
        FieldToJsonResolve(jdata["pStdHeaderVersion"], meta_struct.pStdHeaderVersion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoSessionCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoSessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoSessionParametersCreateFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["videoSessionParametersTemplate"], meta_struct.videoSessionParametersTemplate, options);
        HandleToJson(jdata["videoSession"], meta_struct.videoSession, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoSessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoSessionParametersUpdateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionParametersUpdateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoSessionParametersUpdateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoSessionParametersUpdateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["updateSequenceCount"], decoded_value.updateSequenceCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoSessionParametersUpdateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoSessionParametersUpdateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoBeginCodingInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoBeginCodingInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoBeginCodingInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoBeginCodingInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoBeginCodingFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["videoSession"], meta_struct.videoSession, options);
        HandleToJson(jdata["videoSessionParameters"], meta_struct.videoSessionParameters, options);
        FieldToJsonResolve(jdata["referenceSlotCount"], decoded_value.referenceSlotCount, options);
        FieldToJsonResolve(jdata["pReferenceSlots"], meta_struct.pReferenceSlots, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoBeginCodingInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoBeginCodingInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEndCodingInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEndCodingInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEndCodingInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEndCodingInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEndCodingFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEndCodingInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEndCodingInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoCodingControlInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoCodingControlInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoCodingControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoCodingControlInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoCodingControlFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoCodingControlInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoCodingControlInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoDecodeCapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeUsageInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeUsageInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeUsageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeUsageInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoDecodeUsageFlagsKHR_t(),jdata["videoUsageHints"], decoded_value.videoUsageHints, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeUsageInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeUsageInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoDecodeFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["srcBuffer"], meta_struct.srcBuffer, options);
        FieldToJsonResolve(jdata["srcBufferOffset"], decoded_value.srcBufferOffset, options);
        FieldToJsonResolve(jdata["srcBufferRange"], decoded_value.srcBufferRange, options);
        FieldToJsonResolve(jdata["dstPictureResource"], meta_struct.dstPictureResource, options);
        FieldToJsonResolve(jdata["pSetupReferenceSlot"], meta_struct.pSetupReferenceSlot, options);
        FieldToJsonResolve(jdata["referenceSlotCount"], decoded_value.referenceSlotCount, options);
        FieldToJsonResolve(jdata["pReferenceSlots"], meta_struct.pReferenceSlots, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH264CapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["maxSliceCount"], decoded_value.maxSliceCount, options);
        FieldToJsonResolve(jdata["maxPPictureL0ReferenceCount"], decoded_value.maxPPictureL0ReferenceCount, options);
        FieldToJsonResolve(jdata["maxBPictureL0ReferenceCount"], decoded_value.maxBPictureL0ReferenceCount, options);
        FieldToJsonResolve(jdata["maxL1ReferenceCount"], decoded_value.maxL1ReferenceCount, options);
        FieldToJsonResolve(jdata["maxTemporalLayerCount"], decoded_value.maxTemporalLayerCount, options);
        jdata["expectDyadicTemporalLayerPattern"] = static_cast<bool>(decoded_value.expectDyadicTemporalLayerPattern);
        FieldToJsonResolve(jdata["minQp"], decoded_value.minQp, options);
        FieldToJsonResolve(jdata["maxQp"], decoded_value.maxQp, options);
        jdata["prefersGopRemainingFrames"] = static_cast<bool>(decoded_value.prefersGopRemainingFrames);
        jdata["requiresGopRemainingFrames"] = static_cast<bool>(decoded_value.requiresGopRemainingFrames);
        FieldToJson(VkVideoEncodeH264StdFlagsKHR_t(),jdata["stdSyntaxFlags"], decoded_value.stdSyntaxFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264QpKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QpKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QpKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QpKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["qpI"], decoded_value.qpI, options);
        FieldToJsonResolve(jdata["qpP"], decoded_value.qpP, options);
        FieldToJsonResolve(jdata["qpB"], decoded_value.qpB, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QpKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264QpKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH264RateControlFlagsKHR_t(),jdata["preferredRateControlFlags"], decoded_value.preferredRateControlFlags, options);
        FieldToJsonResolve(jdata["preferredGopFrameCount"], decoded_value.preferredGopFrameCount, options);
        FieldToJsonResolve(jdata["preferredIdrPeriod"], decoded_value.preferredIdrPeriod, options);
        FieldToJsonResolve(jdata["preferredConsecutiveBFrameCount"], decoded_value.preferredConsecutiveBFrameCount, options);
        FieldToJsonResolve(jdata["preferredTemporalLayerCount"], decoded_value.preferredTemporalLayerCount, options);
        FieldToJsonResolve(jdata["preferredConstantQp"], meta_struct.preferredConstantQp, options);
        FieldToJsonResolve(jdata["preferredMaxL0ReferenceCount"], decoded_value.preferredMaxL0ReferenceCount, options);
        FieldToJsonResolve(jdata["preferredMaxL1ReferenceCount"], decoded_value.preferredMaxL1ReferenceCount, options);
        jdata["preferredStdEntropyCodingModeFlag"] = static_cast<bool>(decoded_value.preferredStdEntropyCodingModeFlag);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMaxLevelIdc"] = static_cast<bool>(decoded_value.useMaxLevelIdc);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdSPSCount"], decoded_value.stdSPSCount, options);
        FieldToJsonResolve(jdata["pStdSPSs"], meta_struct.pStdSPSs, options);
        FieldToJsonResolve(jdata["stdPPSCount"], decoded_value.stdPPSCount, options);
        FieldToJsonResolve(jdata["pStdPPSs"], meta_struct.pStdPPSs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxStdSPSCount"], decoded_value.maxStdSPSCount, options);
        FieldToJsonResolve(jdata["maxStdPPSCount"], decoded_value.maxStdPPSCount, options);
        FieldToJsonResolve(jdata["pParametersAddInfo"], meta_struct.pParametersAddInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["writeStdSPS"] = static_cast<bool>(decoded_value.writeStdSPS);
        jdata["writeStdPPS"] = static_cast<bool>(decoded_value.writeStdPPS);
        FieldToJsonResolve(jdata["stdSPSId"], decoded_value.stdSPSId, options);
        FieldToJsonResolve(jdata["stdPPSId"], decoded_value.stdPPSId, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264SessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hasStdSPSOverrides"] = static_cast<bool>(decoded_value.hasStdSPSOverrides);
        jdata["hasStdPPSOverrides"] = static_cast<bool>(decoded_value.hasStdPPSOverrides);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264NaluSliceInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264NaluSliceInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264NaluSliceInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264NaluSliceInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["constantQp"], decoded_value.constantQp, options);
        FieldToJsonResolve(jdata["pStdSliceHeader"], meta_struct.pStdSliceHeader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264NaluSliceInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264NaluSliceInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["naluSliceEntryCount"], decoded_value.naluSliceEntryCount, options);
        FieldToJsonResolve(jdata["pNaluSliceEntries"], meta_struct.pNaluSliceEntries, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        jdata["generatePrefixNalu"] = static_cast<bool>(decoded_value.generatePrefixNalu);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfileIdc"], decoded_value.stdProfileIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264RateControlInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264RateControlInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264RateControlInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH264RateControlFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["gopFrameCount"], decoded_value.gopFrameCount, options);
        FieldToJsonResolve(jdata["idrPeriod"], decoded_value.idrPeriod, options);
        FieldToJsonResolve(jdata["consecutiveBFrameCount"], decoded_value.consecutiveBFrameCount, options);
        FieldToJsonResolve(jdata["temporalLayerCount"], decoded_value.temporalLayerCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264RateControlInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264RateControlInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264FrameSizeKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264FrameSizeKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264FrameSizeKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["frameISize"], decoded_value.frameISize, options);
        FieldToJsonResolve(jdata["framePSize"], decoded_value.framePSize, options);
        FieldToJsonResolve(jdata["frameBSize"], decoded_value.frameBSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264FrameSizeKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264FrameSizeKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264RateControlLayerInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMinQp"] = static_cast<bool>(decoded_value.useMinQp);
        FieldToJsonResolve(jdata["minQp"], meta_struct.minQp, options);
        jdata["useMaxQp"] = static_cast<bool>(decoded_value.useMaxQp);
        FieldToJsonResolve(jdata["maxQp"], meta_struct.maxQp, options);
        jdata["useMaxFrameSize"] = static_cast<bool>(decoded_value.useMaxFrameSize);
        FieldToJsonResolve(jdata["maxFrameSize"], meta_struct.maxFrameSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264RateControlLayerInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useGopRemainingFrames"] = static_cast<bool>(decoded_value.useGopRemainingFrames);
        FieldToJsonResolve(jdata["gopRemainingI"], decoded_value.gopRemainingI, options);
        FieldToJsonResolve(jdata["gopRemainingP"], decoded_value.gopRemainingP, options);
        FieldToJsonResolve(jdata["gopRemainingB"], decoded_value.gopRemainingB, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH265CapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["maxSliceSegmentCount"], decoded_value.maxSliceSegmentCount, options);
        FieldToJsonResolve(jdata["maxTiles"], meta_struct.maxTiles, options);
        FieldToJson(VkVideoEncodeH265CtbSizeFlagsKHR_t(),jdata["ctbSizes"], decoded_value.ctbSizes, options);
        FieldToJson(VkVideoEncodeH265TransformBlockSizeFlagsKHR_t(),jdata["transformBlockSizes"], decoded_value.transformBlockSizes, options);
        FieldToJsonResolve(jdata["maxPPictureL0ReferenceCount"], decoded_value.maxPPictureL0ReferenceCount, options);
        FieldToJsonResolve(jdata["maxBPictureL0ReferenceCount"], decoded_value.maxBPictureL0ReferenceCount, options);
        FieldToJsonResolve(jdata["maxL1ReferenceCount"], decoded_value.maxL1ReferenceCount, options);
        FieldToJsonResolve(jdata["maxSubLayerCount"], decoded_value.maxSubLayerCount, options);
        jdata["expectDyadicTemporalSubLayerPattern"] = static_cast<bool>(decoded_value.expectDyadicTemporalSubLayerPattern);
        FieldToJsonResolve(jdata["minQp"], decoded_value.minQp, options);
        FieldToJsonResolve(jdata["maxQp"], decoded_value.maxQp, options);
        jdata["prefersGopRemainingFrames"] = static_cast<bool>(decoded_value.prefersGopRemainingFrames);
        jdata["requiresGopRemainingFrames"] = static_cast<bool>(decoded_value.requiresGopRemainingFrames);
        FieldToJson(VkVideoEncodeH265StdFlagsKHR_t(),jdata["stdSyntaxFlags"], decoded_value.stdSyntaxFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMaxLevelIdc"] = static_cast<bool>(decoded_value.useMaxLevelIdc);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265QpKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QpKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QpKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QpKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["qpI"], decoded_value.qpI, options);
        FieldToJsonResolve(jdata["qpP"], decoded_value.qpP, options);
        FieldToJsonResolve(jdata["qpB"], decoded_value.qpB, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QpKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265QpKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH265RateControlFlagsKHR_t(),jdata["preferredRateControlFlags"], decoded_value.preferredRateControlFlags, options);
        FieldToJsonResolve(jdata["preferredGopFrameCount"], decoded_value.preferredGopFrameCount, options);
        FieldToJsonResolve(jdata["preferredIdrPeriod"], decoded_value.preferredIdrPeriod, options);
        FieldToJsonResolve(jdata["preferredConsecutiveBFrameCount"], decoded_value.preferredConsecutiveBFrameCount, options);
        FieldToJsonResolve(jdata["preferredSubLayerCount"], decoded_value.preferredSubLayerCount, options);
        FieldToJsonResolve(jdata["preferredConstantQp"], meta_struct.preferredConstantQp, options);
        FieldToJsonResolve(jdata["preferredMaxL0ReferenceCount"], decoded_value.preferredMaxL0ReferenceCount, options);
        FieldToJsonResolve(jdata["preferredMaxL1ReferenceCount"], decoded_value.preferredMaxL1ReferenceCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdVPSCount"], decoded_value.stdVPSCount, options);
        FieldToJsonResolve(jdata["pStdVPSs"], meta_struct.pStdVPSs, options);
        FieldToJsonResolve(jdata["stdSPSCount"], decoded_value.stdSPSCount, options);
        FieldToJsonResolve(jdata["pStdSPSs"], meta_struct.pStdSPSs, options);
        FieldToJsonResolve(jdata["stdPPSCount"], decoded_value.stdPPSCount, options);
        FieldToJsonResolve(jdata["pStdPPSs"], meta_struct.pStdPPSs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxStdVPSCount"], decoded_value.maxStdVPSCount, options);
        FieldToJsonResolve(jdata["maxStdSPSCount"], decoded_value.maxStdSPSCount, options);
        FieldToJsonResolve(jdata["maxStdPPSCount"], decoded_value.maxStdPPSCount, options);
        FieldToJsonResolve(jdata["pParametersAddInfo"], meta_struct.pParametersAddInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["writeStdVPS"] = static_cast<bool>(decoded_value.writeStdVPS);
        jdata["writeStdSPS"] = static_cast<bool>(decoded_value.writeStdSPS);
        jdata["writeStdPPS"] = static_cast<bool>(decoded_value.writeStdPPS);
        FieldToJsonResolve(jdata["stdVPSId"], decoded_value.stdVPSId, options);
        FieldToJsonResolve(jdata["stdSPSId"], decoded_value.stdSPSId, options);
        FieldToJsonResolve(jdata["stdPPSId"], decoded_value.stdPPSId, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265SessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hasStdVPSOverrides"] = static_cast<bool>(decoded_value.hasStdVPSOverrides);
        jdata["hasStdSPSOverrides"] = static_cast<bool>(decoded_value.hasStdSPSOverrides);
        jdata["hasStdPPSOverrides"] = static_cast<bool>(decoded_value.hasStdPPSOverrides);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265NaluSliceSegmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["constantQp"], decoded_value.constantQp, options);
        FieldToJsonResolve(jdata["pStdSliceSegmentHeader"], meta_struct.pStdSliceSegmentHeader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265NaluSliceSegmentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["naluSliceSegmentEntryCount"], decoded_value.naluSliceSegmentEntryCount, options);
        FieldToJsonResolve(jdata["pNaluSliceSegmentEntries"], meta_struct.pNaluSliceSegmentEntries, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfileIdc"], decoded_value.stdProfileIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265RateControlInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265RateControlInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265RateControlInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH265RateControlFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["gopFrameCount"], decoded_value.gopFrameCount, options);
        FieldToJsonResolve(jdata["idrPeriod"], decoded_value.idrPeriod, options);
        FieldToJsonResolve(jdata["consecutiveBFrameCount"], decoded_value.consecutiveBFrameCount, options);
        FieldToJsonResolve(jdata["subLayerCount"], decoded_value.subLayerCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265RateControlInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265RateControlInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265FrameSizeKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265FrameSizeKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265FrameSizeKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["frameISize"], decoded_value.frameISize, options);
        FieldToJsonResolve(jdata["framePSize"], decoded_value.framePSize, options);
        FieldToJsonResolve(jdata["frameBSize"], decoded_value.frameBSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265FrameSizeKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265FrameSizeKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265RateControlLayerInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMinQp"] = static_cast<bool>(decoded_value.useMinQp);
        FieldToJsonResolve(jdata["minQp"], meta_struct.minQp, options);
        jdata["useMaxQp"] = static_cast<bool>(decoded_value.useMaxQp);
        FieldToJsonResolve(jdata["maxQp"], meta_struct.maxQp, options);
        jdata["useMaxFrameSize"] = static_cast<bool>(decoded_value.useMaxFrameSize);
        FieldToJsonResolve(jdata["maxFrameSize"], meta_struct.maxFrameSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265RateControlLayerInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useGopRemainingFrames"] = static_cast<bool>(decoded_value.useGopRemainingFrames);
        FieldToJsonResolve(jdata["gopRemainingI"], decoded_value.gopRemainingI, options);
        FieldToJsonResolve(jdata["gopRemainingP"], decoded_value.gopRemainingP, options);
        FieldToJsonResolve(jdata["gopRemainingB"], decoded_value.gopRemainingB, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfileIdc"], decoded_value.stdProfileIdc, options);
        FieldToJsonResolve(jdata["pictureLayout"], decoded_value.pictureLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["fieldOffsetGranularity"], meta_struct.fieldOffsetGranularity, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdSPSCount"], decoded_value.stdSPSCount, options);
        FieldToJsonResolve(jdata["pStdSPSs"], meta_struct.pStdSPSs, options);
        FieldToJsonResolve(jdata["stdPPSCount"], decoded_value.stdPPSCount, options);
        FieldToJsonResolve(jdata["pStdPPSs"], meta_struct.pStdPPSs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxStdSPSCount"], decoded_value.maxStdSPSCount, options);
        FieldToJsonResolve(jdata["maxStdPPSCount"], decoded_value.maxStdPPSCount, options);
        FieldToJsonResolve(jdata["pParametersAddInfo"], meta_struct.pParametersAddInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["sliceCount"], decoded_value.sliceCount, options);
        FieldToJsonResolve(jdata["pSliceOffsets"], meta_struct.pSliceOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], meta_struct.handle, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportMemoryWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pAttributes"], meta_struct.pAttributes, options);
        FieldToJsonResolve(jdata["dwAccess"], decoded_value.dwAccess, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportMemoryWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryWin32HandlePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryWin32HandlePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryWin32HandlePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryWin32HandlePropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryWin32HandlePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryWin32HandlePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["fd"], decoded_value.fd, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryFdPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryFdPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryFdPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryFdPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryFdPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryFdPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWin32KeyedMutexAcquireReleaseInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["acquireCount"], decoded_value.acquireCount, options);
        HandleToJson(jdata["pAcquireSyncs"], &meta_struct.pAcquireSyncs, options);
        FieldToJsonResolve(jdata["pAcquireKeys"], meta_struct.pAcquireKeys, options);
        FieldToJsonResolve(jdata["pAcquireTimeouts"], meta_struct.pAcquireTimeouts, options);
        FieldToJsonResolve(jdata["releaseCount"], decoded_value.releaseCount, options);
        HandleToJson(jdata["pReleaseSyncs"], &meta_struct.pReleaseSyncs, options);
        FieldToJsonResolve(jdata["pReleaseKeys"], meta_struct.pReleaseKeys, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportSemaphoreWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJson(VkSemaphoreImportFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], meta_struct.handle, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportSemaphoreWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportSemaphoreWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportSemaphoreWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportSemaphoreWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportSemaphoreWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pAttributes"], meta_struct.pAttributes, options);
        FieldToJsonResolve(jdata["dwAccess"], decoded_value.dwAccess, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportSemaphoreWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportSemaphoreWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkD3D12FenceSubmitInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkD3D12FenceSubmitInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkD3D12FenceSubmitInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkD3D12FenceSubmitInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["waitSemaphoreValuesCount"], decoded_value.waitSemaphoreValuesCount, options);
        FieldToJsonResolve(jdata["pWaitSemaphoreValues"], meta_struct.pWaitSemaphoreValues, options);
        FieldToJsonResolve(jdata["signalSemaphoreValuesCount"], decoded_value.signalSemaphoreValuesCount, options);
        FieldToJsonResolve(jdata["pSignalSemaphoreValues"], meta_struct.pSignalSemaphoreValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkD3D12FenceSubmitInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkD3D12FenceSubmitInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreGetWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreGetWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportSemaphoreFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJson(VkSemaphoreImportFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["fd"], decoded_value.fd, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportSemaphoreFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreGetFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreGetFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRectLayerKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRectLayerKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRectLayerKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRectLayerKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["offset"], meta_struct.offset, options);
        FieldToJsonResolve(jdata["extent"], meta_struct.extent, options);
        FieldToJsonResolve(jdata["layer"], decoded_value.layer, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRectLayerKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRectLayerKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentRegionKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentRegionKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentRegionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentRegionKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["rectangleCount"], decoded_value.rectangleCount, options);
        FieldToJsonResolve(jdata["pRectangles"], meta_struct.pRectangles, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentRegionKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentRegionKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentRegionsKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentRegionsKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentRegionsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentRegionsKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentRegionsKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentRegionsKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSharedPresentSurfaceCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSharedPresentSurfaceCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["sharedPresentSupportedUsageFlags"], decoded_value.sharedPresentSupportedUsageFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSharedPresentSurfaceCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSharedPresentSurfaceCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportFenceWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportFenceWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportFenceWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportFenceWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["fence"], meta_struct.fence, options);
        FieldToJson(VkFenceImportFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], meta_struct.handle, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportFenceWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportFenceWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportFenceWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportFenceWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportFenceWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkExportFenceWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pAttributes"], meta_struct.pAttributes, options);
        FieldToJsonResolve(jdata["dwAccess"], decoded_value.dwAccess, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportFenceWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportFenceWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFenceGetWin32HandleInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFenceGetWin32HandleInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFenceGetWin32HandleInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFenceGetWin32HandleInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["fence"], meta_struct.fence, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFenceGetWin32HandleInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFenceGetWin32HandleInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportFenceFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportFenceFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportFenceFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkImportFenceFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["fence"], meta_struct.fence, options);
        FieldToJson(VkFenceImportFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["fd"], decoded_value.fd, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportFenceFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportFenceFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFenceGetFdInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFenceGetFdInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFenceGetFdInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFenceGetFdInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["fence"], meta_struct.fence, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFenceGetFdInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFenceGetFdInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerformanceQueryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["performanceCounterQueryPools"] = static_cast<bool>(decoded_value.performanceCounterQueryPools);
        jdata["performanceCounterMultipleQueryPools"] = static_cast<bool>(decoded_value.performanceCounterMultipleQueryPools);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerformanceQueryPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["allowCommandBufferQueryCopies"] = static_cast<bool>(decoded_value.allowCommandBufferQueryCopies);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceCounterKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceCounterKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceCounterKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceCounterKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["unit"], decoded_value.unit, options);
        FieldToJsonResolve(jdata["scope"], decoded_value.scope, options);
        FieldToJsonResolve(jdata["storage"], decoded_value.storage, options);
        FieldToJsonResolve(jdata["uuid"], uuid_to_string(sizeof(decoded_value.uuid), decoded_value.uuid), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceCounterKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceCounterKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceCounterDescriptionKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceCounterDescriptionKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceCounterDescriptionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceCounterDescriptionKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPerformanceCounterDescriptionFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["category"], &meta_struct.category, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceCounterDescriptionKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceCounterDescriptionKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueryPoolPerformanceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolPerformanceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolPerformanceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolPerformanceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["queueFamilyIndex"], decoded_value.queueFamilyIndex, options);
        FieldToJsonResolve(jdata["counterIndexCount"], decoded_value.counterIndexCount, options);
        FieldToJsonResolve(jdata["pCounterIndices"], meta_struct.pCounterIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolPerformanceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueryPoolPerformanceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAcquireProfilingLockInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAcquireProfilingLockInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAcquireProfilingLockInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAcquireProfilingLockInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAcquireProfilingLockFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["timeout"], decoded_value.timeout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAcquireProfilingLockInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAcquireProfilingLockInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceQuerySubmitInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceQuerySubmitInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceQuerySubmitInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceQuerySubmitInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["counterPassIndex"], decoded_value.counterPassIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceQuerySubmitInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceQuerySubmitInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSurfaceInfo2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSurfaceInfo2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["surface"], meta_struct.surface, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSurfaceInfo2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilities2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilities2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilities2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilities2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["surfaceCapabilities"], meta_struct.surfaceCapabilities, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilities2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilities2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceFormat2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFormat2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFormat2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFormat2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["surfaceFormat"], meta_struct.surfaceFormat, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFormat2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceFormat2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayProperties2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayProperties2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayProperties2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displayProperties"], meta_struct.displayProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayProperties2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayProperties2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPlaneProperties2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneProperties2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneProperties2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displayPlaneProperties"], meta_struct.displayPlaneProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneProperties2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPlaneProperties2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayModeProperties2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeProperties2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeProperties2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeProperties2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displayModeProperties"], meta_struct.displayModeProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeProperties2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayModeProperties2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPlaneInfo2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneInfo2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneInfo2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneInfo2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["mode"], meta_struct.mode, options);
        FieldToJsonResolve(jdata["planeIndex"], decoded_value.planeIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneInfo2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPlaneInfo2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPlaneCapabilities2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneCapabilities2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPlaneCapabilities2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPlaneCapabilities2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["capabilities"], meta_struct.capabilities, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPlaneCapabilities2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPlaneCapabilities2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderBfloat16FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderBFloat16Type"] = static_cast<bool>(decoded_value.shaderBFloat16Type);
        jdata["shaderBFloat16DotProduct"] = static_cast<bool>(decoded_value.shaderBFloat16DotProduct);
        jdata["shaderBFloat16CooperativeMatrix"] = static_cast<bool>(decoded_value.shaderBFloat16CooperativeMatrix);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePortabilitySubsetFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["constantAlphaColorBlendFactors"] = static_cast<bool>(decoded_value.constantAlphaColorBlendFactors);
        jdata["events"] = static_cast<bool>(decoded_value.events);
        jdata["imageViewFormatReinterpretation"] = static_cast<bool>(decoded_value.imageViewFormatReinterpretation);
        jdata["imageViewFormatSwizzle"] = static_cast<bool>(decoded_value.imageViewFormatSwizzle);
        jdata["imageView2DOn3DImage"] = static_cast<bool>(decoded_value.imageView2DOn3DImage);
        jdata["multisampleArrayImage"] = static_cast<bool>(decoded_value.multisampleArrayImage);
        jdata["mutableComparisonSamplers"] = static_cast<bool>(decoded_value.mutableComparisonSamplers);
        jdata["pointPolygons"] = static_cast<bool>(decoded_value.pointPolygons);
        jdata["samplerMipLodBias"] = static_cast<bool>(decoded_value.samplerMipLodBias);
        jdata["separateStencilMaskRef"] = static_cast<bool>(decoded_value.separateStencilMaskRef);
        jdata["shaderSampleRateInterpolationFunctions"] = static_cast<bool>(decoded_value.shaderSampleRateInterpolationFunctions);
        jdata["tessellationIsolines"] = static_cast<bool>(decoded_value.tessellationIsolines);
        jdata["tessellationPointMode"] = static_cast<bool>(decoded_value.tessellationPointMode);
        jdata["triangleFans"] = static_cast<bool>(decoded_value.triangleFans);
        jdata["vertexAttributeAccessBeyondStride"] = static_cast<bool>(decoded_value.vertexAttributeAccessBeyondStride);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePortabilitySubsetPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minVertexInputBindingStrideAlignment"], decoded_value.minVertexInputBindingStrideAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderClockFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderClockFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderSubgroupClock"] = static_cast<bool>(decoded_value.shaderSubgroupClock);
        jdata["shaderDeviceClock"] = static_cast<bool>(decoded_value.shaderDeviceClock);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderClockFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfileIdc"], decoded_value.stdProfileIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxLevelIdc"], decoded_value.maxLevelIdc, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265SessionParametersAddInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdVPSCount"], decoded_value.stdVPSCount, options);
        FieldToJsonResolve(jdata["pStdVPSs"], meta_struct.pStdVPSs, options);
        FieldToJsonResolve(jdata["stdSPSCount"], decoded_value.stdSPSCount, options);
        FieldToJsonResolve(jdata["pStdSPSs"], meta_struct.pStdSPSs, options);
        FieldToJsonResolve(jdata["stdPPSCount"], decoded_value.stdPPSCount, options);
        FieldToJsonResolve(jdata["pStdPPSs"], meta_struct.pStdPPSs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxStdVPSCount"], decoded_value.maxStdVPSCount, options);
        FieldToJsonResolve(jdata["maxStdSPSCount"], decoded_value.maxStdSPSCount, options);
        FieldToJsonResolve(jdata["maxStdPPSCount"], decoded_value.maxStdPPSCount, options);
        FieldToJsonResolve(jdata["pParametersAddInfo"], meta_struct.pParametersAddInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["sliceSegmentCount"], decoded_value.sliceSegmentCount, options);
        FieldToJsonResolve(jdata["pSliceSegmentOffsets"], meta_struct.pSliceSegmentOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFragmentShadingRateAttachmentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFragmentShadingRateAttachmentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFragmentShadingRateAttachmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkFragmentShadingRateAttachmentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pFragmentShadingRateAttachment"], meta_struct.pFragmentShadingRateAttachment, options);
        FieldToJsonResolve(jdata["shadingRateAttachmentTexelSize"], meta_struct.shadingRateAttachmentTexelSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFragmentShadingRateAttachmentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFragmentShadingRateAttachmentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineFragmentShadingRateStateCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["fragmentSize"], meta_struct.fragmentSize, options);
        FieldToJsonResolve(jdata["combinerOps"], &meta_struct.combinerOps, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineFragmentShadingRate"] = static_cast<bool>(decoded_value.pipelineFragmentShadingRate);
        jdata["primitiveFragmentShadingRate"] = static_cast<bool>(decoded_value.primitiveFragmentShadingRate);
        jdata["attachmentFragmentShadingRate"] = static_cast<bool>(decoded_value.attachmentFragmentShadingRate);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRatePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minFragmentShadingRateAttachmentTexelSize"], meta_struct.minFragmentShadingRateAttachmentTexelSize, options);
        FieldToJsonResolve(jdata["maxFragmentShadingRateAttachmentTexelSize"], meta_struct.maxFragmentShadingRateAttachmentTexelSize, options);
        FieldToJsonResolve(jdata["maxFragmentShadingRateAttachmentTexelSizeAspectRatio"], decoded_value.maxFragmentShadingRateAttachmentTexelSizeAspectRatio, options);
        jdata["primitiveFragmentShadingRateWithMultipleViewports"] = static_cast<bool>(decoded_value.primitiveFragmentShadingRateWithMultipleViewports);
        jdata["layeredShadingRateAttachments"] = static_cast<bool>(decoded_value.layeredShadingRateAttachments);
        jdata["fragmentShadingRateNonTrivialCombinerOps"] = static_cast<bool>(decoded_value.fragmentShadingRateNonTrivialCombinerOps);
        FieldToJsonResolve(jdata["maxFragmentSize"], meta_struct.maxFragmentSize, options);
        FieldToJsonResolve(jdata["maxFragmentSizeAspectRatio"], decoded_value.maxFragmentSizeAspectRatio, options);
        FieldToJsonResolve(jdata["maxFragmentShadingRateCoverageSamples"], decoded_value.maxFragmentShadingRateCoverageSamples, options);
        FieldToJsonResolve(jdata["maxFragmentShadingRateRasterizationSamples"], decoded_value.maxFragmentShadingRateRasterizationSamples, options);
        jdata["fragmentShadingRateWithShaderDepthStencilWrites"] = static_cast<bool>(decoded_value.fragmentShadingRateWithShaderDepthStencilWrites);
        jdata["fragmentShadingRateWithSampleMask"] = static_cast<bool>(decoded_value.fragmentShadingRateWithSampleMask);
        jdata["fragmentShadingRateWithShaderSampleMask"] = static_cast<bool>(decoded_value.fragmentShadingRateWithShaderSampleMask);
        jdata["fragmentShadingRateWithConservativeRasterization"] = static_cast<bool>(decoded_value.fragmentShadingRateWithConservativeRasterization);
        jdata["fragmentShadingRateWithFragmentShaderInterlock"] = static_cast<bool>(decoded_value.fragmentShadingRateWithFragmentShaderInterlock);
        jdata["fragmentShadingRateWithCustomSampleLocations"] = static_cast<bool>(decoded_value.fragmentShadingRateWithCustomSampleLocations);
        jdata["fragmentShadingRateStrictMultiplyCombiner"] = static_cast<bool>(decoded_value.fragmentShadingRateStrictMultiplyCombiner);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampleCounts"], decoded_value.sampleCounts, options);
        FieldToJsonResolve(jdata["fragmentSize"], meta_struct.fragmentSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingFragmentShadingRateAttachmentInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["imageView"], meta_struct.imageView, options);
        FieldToJsonResolve(jdata["imageLayout"], decoded_value.imageLayout, options);
        FieldToJsonResolve(jdata["shadingRateAttachmentTexelSize"], meta_struct.shadingRateAttachmentTexelSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderQuadControlFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderQuadControl"] = static_cast<bool>(decoded_value.shaderQuadControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceProtectedCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceProtectedCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceProtectedCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceProtectedCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["supportsProtected"] = static_cast<bool>(decoded_value.supportsProtected);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceProtectedCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceProtectedCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentWaitFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentWaitFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentWait"] = static_cast<bool>(decoded_value.presentWait);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentWaitFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineExecutableInfo"] = static_cast<bool>(decoded_value.pipelineExecutableInfo);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineExecutablePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutablePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutablePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutablePropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stages"], decoded_value.stages, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["subgroupSize"], decoded_value.subgroupSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutablePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineExecutablePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineExecutableInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutableInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutableInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutableInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["executableIndex"], decoded_value.executableIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutableInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineExecutableInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineExecutableInternalRepresentationKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutableInternalRepresentationKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineExecutableInternalRepresentationKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineExecutableInternalRepresentationKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["name"], &meta_struct.name, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        jdata["isText"] = static_cast<bool>(decoded_value.isText);
        FieldToJsonResolve(jdata["dataSize"], decoded_value.dataSize, options);
        FieldToJsonResolve(jdata["pData"], meta_struct.pData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineExecutableInternalRepresentationKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineExecutableInternalRepresentationKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineLibraryCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineLibraryCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineLibraryCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineLibraryCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["libraryCount"], decoded_value.libraryCount, options);
        HandleToJson(jdata["pLibraries"], &meta_struct.pLibraries, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineLibraryCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineLibraryCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentIdKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentIdKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentIdKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentIdKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pPresentIds"], meta_struct.pPresentIds, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentIdKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentIdKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentIdFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentIdFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentIdFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentIdFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentId"] = static_cast<bool>(decoded_value.presentId);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentIdFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentIdFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        HandleToJson(jdata["dstBuffer"], meta_struct.dstBuffer, options);
        FieldToJsonResolve(jdata["dstBufferOffset"], decoded_value.dstBufferOffset, options);
        FieldToJsonResolve(jdata["dstBufferRange"], decoded_value.dstBufferRange, options);
        FieldToJsonResolve(jdata["srcPictureResource"], meta_struct.srcPictureResource, options);
        FieldToJsonResolve(jdata["pSetupReferenceSlot"], meta_struct.pSetupReferenceSlot, options);
        FieldToJsonResolve(jdata["referenceSlotCount"], decoded_value.referenceSlotCount, options);
        FieldToJsonResolve(jdata["pReferenceSlots"], meta_struct.pReferenceSlots, options);
        FieldToJsonResolve(jdata["precedingExternallyEncodedBytes"], decoded_value.precedingExternallyEncodedBytes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeCapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJson(VkVideoEncodeRateControlModeFlagsKHR_t(),jdata["rateControlModes"], decoded_value.rateControlModes, options);
        FieldToJsonResolve(jdata["maxRateControlLayers"], decoded_value.maxRateControlLayers, options);
        FieldToJsonResolve(jdata["maxBitrate"], decoded_value.maxBitrate, options);
        FieldToJsonResolve(jdata["maxQualityLevels"], decoded_value.maxQualityLevels, options);
        FieldToJsonResolve(jdata["encodeInputPictureGranularity"], meta_struct.encodeInputPictureGranularity, options);
        FieldToJson(VkVideoEncodeFeedbackFlagsKHR_t(),jdata["supportedEncodeFeedbackFlags"], decoded_value.supportedEncodeFeedbackFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeFeedbackFlagsKHR_t(),jdata["encodeFeedbackFlags"], decoded_value.encodeFeedbackFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeUsageInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeUsageInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeUsageInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeUsageInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeUsageFlagsKHR_t(),jdata["videoUsageHints"], decoded_value.videoUsageHints, options);
        FieldToJson(VkVideoEncodeContentFlagsKHR_t(),jdata["videoContentHints"], decoded_value.videoContentHints, options);
        FieldToJsonResolve(jdata["tuningMode"], decoded_value.tuningMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeUsageInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeUsageInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeRateControlLayerInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeRateControlLayerInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeRateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeRateControlLayerInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["averageBitrate"], decoded_value.averageBitrate, options);
        FieldToJsonResolve(jdata["maxBitrate"], decoded_value.maxBitrate, options);
        FieldToJsonResolve(jdata["frameRateNumerator"], decoded_value.frameRateNumerator, options);
        FieldToJsonResolve(jdata["frameRateDenominator"], decoded_value.frameRateDenominator, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeRateControlLayerInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeRateControlLayerInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeRateControlInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeRateControlInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeRateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeRateControlInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeRateControlFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["rateControlMode"], decoded_value.rateControlMode, options);
        FieldToJsonResolve(jdata["layerCount"], decoded_value.layerCount, options);
        FieldToJsonResolve(jdata["pLayers"], meta_struct.pLayers, options);
        FieldToJsonResolve(jdata["virtualBufferSizeInMs"], decoded_value.virtualBufferSizeInMs, options);
        FieldToJsonResolve(jdata["initialVirtualBufferSizeInMs"], decoded_value.initialVirtualBufferSizeInMs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeRateControlInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeRateControlInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pVideoProfile"], meta_struct.pVideoProfile, options);
        FieldToJsonResolve(jdata["qualityLevel"], decoded_value.qualityLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeQualityLevelPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQualityLevelPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQualityLevelPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["preferredRateControlMode"], decoded_value.preferredRateControlMode, options);
        FieldToJsonResolve(jdata["preferredRateControlLayerCount"], decoded_value.preferredRateControlLayerCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQualityLevelPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeQualityLevelPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeQualityLevelInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQualityLevelInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQualityLevelInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQualityLevelInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["qualityLevel"], decoded_value.qualityLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQualityLevelInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeQualityLevelInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeSessionParametersGetInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionParametersGetInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeSessionParametersGetInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeSessionParametersGetInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["videoSessionParameters"], meta_struct.videoSessionParameters, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionParametersGetInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeSessionParametersGetInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeSessionParametersFeedbackInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hasOverrides"] = static_cast<bool>(decoded_value.hasOverrides);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentShaderBarycentric"] = static_cast<bool>(decoded_value.fragmentShaderBarycentric);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["triStripVertexOrderIndependentOfProvokingVertex"] = static_cast<bool>(decoded_value.triStripVertexOrderIndependentOfProvokingVertex);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderSubgroupUniformControlFlow"] = static_cast<bool>(decoded_value.shaderSubgroupUniformControlFlow);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["workgroupMemoryExplicitLayout"] = static_cast<bool>(decoded_value.workgroupMemoryExplicitLayout);
        jdata["workgroupMemoryExplicitLayoutScalarBlockLayout"] = static_cast<bool>(decoded_value.workgroupMemoryExplicitLayoutScalarBlockLayout);
        jdata["workgroupMemoryExplicitLayout8BitAccess"] = static_cast<bool>(decoded_value.workgroupMemoryExplicitLayout8BitAccess);
        jdata["workgroupMemoryExplicitLayout16BitAccess"] = static_cast<bool>(decoded_value.workgroupMemoryExplicitLayout16BitAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingMaintenance1"] = static_cast<bool>(decoded_value.rayTracingMaintenance1);
        jdata["rayTracingPipelineTraceRaysIndirect2"] = static_cast<bool>(decoded_value.rayTracingPipelineTraceRaysIndirect2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTraceRaysIndirectCommand2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTraceRaysIndirectCommand2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTraceRaysIndirectCommand2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkTraceRaysIndirectCommand2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["raygenShaderRecordAddress"], to_hex_variable_width(decoded_value.raygenShaderRecordAddress), options);
        FieldToJsonResolve(jdata["raygenShaderRecordSize"], decoded_value.raygenShaderRecordSize, options);
        FieldToJsonResolve(jdata["missShaderBindingTableAddress"], to_hex_variable_width(decoded_value.missShaderBindingTableAddress), options);
        FieldToJsonResolve(jdata["missShaderBindingTableSize"], decoded_value.missShaderBindingTableSize, options);
        FieldToJsonResolve(jdata["missShaderBindingTableStride"], decoded_value.missShaderBindingTableStride, options);
        FieldToJsonResolve(jdata["hitShaderBindingTableAddress"], to_hex_variable_width(decoded_value.hitShaderBindingTableAddress), options);
        FieldToJsonResolve(jdata["hitShaderBindingTableSize"], decoded_value.hitShaderBindingTableSize, options);
        FieldToJsonResolve(jdata["hitShaderBindingTableStride"], decoded_value.hitShaderBindingTableStride, options);
        FieldToJsonResolve(jdata["callableShaderBindingTableAddress"], to_hex_variable_width(decoded_value.callableShaderBindingTableAddress), options);
        FieldToJsonResolve(jdata["callableShaderBindingTableSize"], decoded_value.callableShaderBindingTableSize, options);
        FieldToJsonResolve(jdata["callableShaderBindingTableStride"], decoded_value.callableShaderBindingTableStride, options);
        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["depth"], decoded_value.depth, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTraceRaysIndirectCommand2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTraceRaysIndirectCommand2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderMaximalReconvergence"] = static_cast<bool>(decoded_value.shaderMaximalReconvergence);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentId2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentId2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesPresentId2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesPresentId2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentId2Supported"] = static_cast<bool>(decoded_value.presentId2Supported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentId2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentId2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentId2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentId2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentId2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentId2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pPresentIds"], meta_struct.pPresentIds, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentId2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentId2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentId2FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentId2FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentId2FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentId2FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentId2"] = static_cast<bool>(decoded_value.presentId2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentId2FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentId2FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentWait2KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentWait2KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesPresentWait2KHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesPresentWait2KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentWait2Supported"] = static_cast<bool>(decoded_value.presentWait2Supported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentWait2KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentWait2KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentWait2FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentWait2FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentWait2FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentWait2FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentWait2"] = static_cast<bool>(decoded_value.presentWait2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentWait2FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentWait2FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentWait2InfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentWait2InfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentWait2InfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPresentWait2InfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentId"], decoded_value.presentId, options);
        FieldToJsonResolve(jdata["timeout"], decoded_value.timeout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentWait2InfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentWait2InfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingPositionFetch"] = static_cast<bool>(decoded_value.rayTracingPositionFetch);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineBinaryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineBinaries"] = static_cast<bool>(decoded_value.pipelineBinaries);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineBinaryPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineBinaryInternalCache"] = static_cast<bool>(decoded_value.pipelineBinaryInternalCache);
        jdata["pipelineBinaryInternalCacheControl"] = static_cast<bool>(decoded_value.pipelineBinaryInternalCacheControl);
        jdata["pipelineBinaryPrefersInternalCache"] = static_cast<bool>(decoded_value.pipelineBinaryPrefersInternalCache);
        jdata["pipelineBinaryPrecompiledInternalCache"] = static_cast<bool>(decoded_value.pipelineBinaryPrecompiledInternalCache);
        jdata["pipelineBinaryCompressedData"] = static_cast<bool>(decoded_value.pipelineBinaryCompressedData);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDevicePipelineBinaryInternalCacheControlKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDevicePipelineBinaryInternalCacheControlKHR& decoded_value = *data->decoded_value;
        const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["disableInternalCache"] = static_cast<bool>(decoded_value.disableInternalCache);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDevicePipelineBinaryInternalCacheControlKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryKeyKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryKeyKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryKeyKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryKeyKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["keySize"], decoded_value.keySize, options);
        FieldToJsonResolve(jdata["key"], &meta_struct.key, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryKeyKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryKeyKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryDataKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryDataKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryDataKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["dataSize"], decoded_value.dataSize, options);
        FieldToJsonResolve(jdata["pData"], meta_struct.pData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryDataKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryDataKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryKeysAndDataKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryKeysAndDataKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryKeysAndDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryKeysAndDataKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["binaryCount"], decoded_value.binaryCount, options);
        FieldToJsonResolve(jdata["pPipelineBinaryKeys"], meta_struct.pPipelineBinaryKeys, options);
        FieldToJsonResolve(jdata["pPipelineBinaryData"], meta_struct.pPipelineBinaryData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryKeysAndDataKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryKeysAndDataKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pKeysAndDataInfo"], meta_struct.pKeysAndDataInfo, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pPipelineCreateInfo"], meta_struct.pPipelineCreateInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["binaryCount"], decoded_value.binaryCount, options);
        HandleToJson(jdata["pPipelineBinaries"], &meta_struct.pPipelineBinaries, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkReleaseCapturedPipelineDataInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkReleaseCapturedPipelineDataInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkReleaseCapturedPipelineDataInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkReleaseCapturedPipelineDataInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkReleaseCapturedPipelineDataInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkReleaseCapturedPipelineDataInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryDataInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryDataInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryDataInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryDataInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["pipelineBinary"], meta_struct.pipelineBinary, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryDataInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryDataInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineBinaryHandlesInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryHandlesInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineBinaryHandlesInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineBinaryHandlesInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pipelineBinaryCount"], decoded_value.pipelineBinaryCount, options);
        HandleToJson(jdata["pPipelineBinaries"], &meta_struct.pPipelineBinaries, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineBinaryHandlesInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineBinaryHandlesInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfacePresentModeKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentModeKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentModeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentModeKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentMode"], decoded_value.presentMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentModeKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfacePresentModeKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfacePresentScalingCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentScalingCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentScalingCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentScalingCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPresentScalingFlagsKHR_t(),jdata["supportedPresentScaling"], decoded_value.supportedPresentScaling, options);
        FieldToJson(VkPresentGravityFlagsKHR_t(),jdata["supportedPresentGravityX"], decoded_value.supportedPresentGravityX, options);
        FieldToJson(VkPresentGravityFlagsKHR_t(),jdata["supportedPresentGravityY"], decoded_value.supportedPresentGravityY, options);
        FieldToJsonResolve(jdata["minScaledImageExtent"], meta_struct.minScaledImageExtent, options);
        FieldToJsonResolve(jdata["maxScaledImageExtent"], meta_struct.maxScaledImageExtent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentScalingCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfacePresentScalingCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfacePresentModeCompatibilityKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentModeCompatibilityKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfacePresentModeCompatibilityKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSurfacePresentModeCompatibilityKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentModeCount"], decoded_value.presentModeCount, options);
        FieldToJsonResolve(jdata["pPresentModes"], meta_struct.pPresentModes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfacePresentModeCompatibilityKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfacePresentModeCompatibilityKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["swapchainMaintenance1"] = static_cast<bool>(decoded_value.swapchainMaintenance1);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainPresentFenceInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentFenceInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentFenceInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentFenceInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        HandleToJson(jdata["pFences"], &meta_struct.pFences, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentFenceInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainPresentFenceInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainPresentModesCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentModesCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentModesCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentModesCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentModeCount"], decoded_value.presentModeCount, options);
        FieldToJsonResolve(jdata["pPresentModes"], meta_struct.pPresentModes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentModesCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainPresentModesCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainPresentModeInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentModeInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentModeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentModeInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pPresentModes"], meta_struct.pPresentModes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentModeInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainPresentModeInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainPresentScalingCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentScalingCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentScalingCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentScalingCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPresentScalingFlagsKHR_t(),jdata["scalingBehavior"], decoded_value.scalingBehavior, options);
        FieldToJson(VkPresentGravityFlagsKHR_t(),jdata["presentGravityX"], decoded_value.presentGravityX, options);
        FieldToJson(VkPresentGravityFlagsKHR_t(),jdata["presentGravityY"], decoded_value.presentGravityY, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentScalingCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainPresentScalingCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkReleaseSwapchainImagesInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkReleaseSwapchainImagesInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkReleaseSwapchainImagesInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkReleaseSwapchainImagesInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["swapchain"], meta_struct.swapchain, options);
        FieldToJsonResolve(jdata["imageIndexCount"], decoded_value.imageIndexCount, options);
        FieldToJsonResolve(jdata["pImageIndices"], meta_struct.pImageIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkReleaseSwapchainImagesInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkReleaseSwapchainImagesInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCooperativeMatrixPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["MSize"], decoded_value.MSize, options);
        FieldToJsonResolve(jdata["NSize"], decoded_value.NSize, options);
        FieldToJsonResolve(jdata["KSize"], decoded_value.KSize, options);
        FieldToJsonResolve(jdata["AType"], decoded_value.AType, options);
        FieldToJsonResolve(jdata["BType"], decoded_value.BType, options);
        FieldToJsonResolve(jdata["CType"], decoded_value.CType, options);
        FieldToJsonResolve(jdata["ResultType"], decoded_value.ResultType, options);
        jdata["saturatingAccumulation"] = static_cast<bool>(decoded_value.saturatingAccumulation);
        FieldToJsonResolve(jdata["scope"], decoded_value.scope, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCooperativeMatrixPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cooperativeMatrix"] = static_cast<bool>(decoded_value.cooperativeMatrix);
        jdata["cooperativeMatrixRobustBufferAccess"] = static_cast<bool>(decoded_value.cooperativeMatrixRobustBufferAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["cooperativeMatrixSupportedStages"], decoded_value.cooperativeMatrixSupportedStages, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["computeDerivativeGroupQuads"] = static_cast<bool>(decoded_value.computeDerivativeGroupQuads);
        jdata["computeDerivativeGroupLinear"] = static_cast<bool>(decoded_value.computeDerivativeGroupLinear);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["meshAndTaskShaderDerivatives"] = static_cast<bool>(decoded_value.meshAndTaskShaderDerivatives);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfile"], decoded_value.stdProfile, options);
        jdata["filmGrainSupport"] = static_cast<bool>(decoded_value.filmGrainSupport);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxLevel"], decoded_value.maxLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdSequenceHeader"], meta_struct.pStdSequenceHeader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["referenceNameSlotIndices"], &meta_struct.referenceNameSlotIndices, options);
        FieldToJsonResolve(jdata["frameHeaderOffset"], decoded_value.frameHeaderOffset, options);
        FieldToJsonResolve(jdata["tileCount"], decoded_value.tileCount, options);
        FieldToJsonResolve(jdata["pTileOffsets"], meta_struct.pTileOffsets, options);
        FieldToJsonResolve(jdata["pTileSizes"], meta_struct.pTileSizes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoEncodeAV1"] = static_cast<bool>(decoded_value.videoEncodeAV1);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeAV1CapabilityFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["maxLevel"], decoded_value.maxLevel, options);
        FieldToJsonResolve(jdata["codedPictureAlignment"], meta_struct.codedPictureAlignment, options);
        FieldToJsonResolve(jdata["maxTiles"], meta_struct.maxTiles, options);
        FieldToJsonResolve(jdata["minTileSize"], meta_struct.minTileSize, options);
        FieldToJsonResolve(jdata["maxTileSize"], meta_struct.maxTileSize, options);
        FieldToJson(VkVideoEncodeAV1SuperblockSizeFlagsKHR_t(),jdata["superblockSizes"], decoded_value.superblockSizes, options);
        FieldToJsonResolve(jdata["maxSingleReferenceCount"], decoded_value.maxSingleReferenceCount, options);
        FieldToJsonResolve(jdata["singleReferenceNameMask"], decoded_value.singleReferenceNameMask, options);
        FieldToJsonResolve(jdata["maxUnidirectionalCompoundReferenceCount"], decoded_value.maxUnidirectionalCompoundReferenceCount, options);
        FieldToJsonResolve(jdata["maxUnidirectionalCompoundGroup1ReferenceCount"], decoded_value.maxUnidirectionalCompoundGroup1ReferenceCount, options);
        FieldToJsonResolve(jdata["unidirectionalCompoundReferenceNameMask"], decoded_value.unidirectionalCompoundReferenceNameMask, options);
        FieldToJsonResolve(jdata["maxBidirectionalCompoundReferenceCount"], decoded_value.maxBidirectionalCompoundReferenceCount, options);
        FieldToJsonResolve(jdata["maxBidirectionalCompoundGroup1ReferenceCount"], decoded_value.maxBidirectionalCompoundGroup1ReferenceCount, options);
        FieldToJsonResolve(jdata["maxBidirectionalCompoundGroup2ReferenceCount"], decoded_value.maxBidirectionalCompoundGroup2ReferenceCount, options);
        FieldToJsonResolve(jdata["bidirectionalCompoundReferenceNameMask"], decoded_value.bidirectionalCompoundReferenceNameMask, options);
        FieldToJsonResolve(jdata["maxTemporalLayerCount"], decoded_value.maxTemporalLayerCount, options);
        FieldToJsonResolve(jdata["maxSpatialLayerCount"], decoded_value.maxSpatialLayerCount, options);
        FieldToJsonResolve(jdata["maxOperatingPoints"], decoded_value.maxOperatingPoints, options);
        FieldToJsonResolve(jdata["minQIndex"], decoded_value.minQIndex, options);
        FieldToJsonResolve(jdata["maxQIndex"], decoded_value.maxQIndex, options);
        jdata["prefersGopRemainingFrames"] = static_cast<bool>(decoded_value.prefersGopRemainingFrames);
        jdata["requiresGopRemainingFrames"] = static_cast<bool>(decoded_value.requiresGopRemainingFrames);
        FieldToJson(VkVideoEncodeAV1StdFlagsKHR_t(),jdata["stdSyntaxFlags"], decoded_value.stdSyntaxFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1QIndexKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QIndexKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QIndexKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QIndexKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["intraQIndex"], decoded_value.intraQIndex, options);
        FieldToJsonResolve(jdata["predictiveQIndex"], decoded_value.predictiveQIndex, options);
        FieldToJsonResolve(jdata["bipredictiveQIndex"], decoded_value.bipredictiveQIndex, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QIndexKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1QIndexKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QualityLevelPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeAV1RateControlFlagsKHR_t(),jdata["preferredRateControlFlags"], decoded_value.preferredRateControlFlags, options);
        FieldToJsonResolve(jdata["preferredGopFrameCount"], decoded_value.preferredGopFrameCount, options);
        FieldToJsonResolve(jdata["preferredKeyFramePeriod"], decoded_value.preferredKeyFramePeriod, options);
        FieldToJsonResolve(jdata["preferredConsecutiveBipredictiveFrameCount"], decoded_value.preferredConsecutiveBipredictiveFrameCount, options);
        FieldToJsonResolve(jdata["preferredTemporalLayerCount"], decoded_value.preferredTemporalLayerCount, options);
        FieldToJsonResolve(jdata["preferredConstantQIndex"], meta_struct.preferredConstantQIndex, options);
        FieldToJsonResolve(jdata["preferredMaxSingleReferenceCount"], decoded_value.preferredMaxSingleReferenceCount, options);
        FieldToJsonResolve(jdata["preferredSingleReferenceNameMask"], decoded_value.preferredSingleReferenceNameMask, options);
        FieldToJsonResolve(jdata["preferredMaxUnidirectionalCompoundReferenceCount"], decoded_value.preferredMaxUnidirectionalCompoundReferenceCount, options);
        FieldToJsonResolve(jdata["preferredMaxUnidirectionalCompoundGroup1ReferenceCount"], decoded_value.preferredMaxUnidirectionalCompoundGroup1ReferenceCount, options);
        FieldToJsonResolve(jdata["preferredUnidirectionalCompoundReferenceNameMask"], decoded_value.preferredUnidirectionalCompoundReferenceNameMask, options);
        FieldToJsonResolve(jdata["preferredMaxBidirectionalCompoundReferenceCount"], decoded_value.preferredMaxBidirectionalCompoundReferenceCount, options);
        FieldToJsonResolve(jdata["preferredMaxBidirectionalCompoundGroup1ReferenceCount"], decoded_value.preferredMaxBidirectionalCompoundGroup1ReferenceCount, options);
        FieldToJsonResolve(jdata["preferredMaxBidirectionalCompoundGroup2ReferenceCount"], decoded_value.preferredMaxBidirectionalCompoundGroup2ReferenceCount, options);
        FieldToJsonResolve(jdata["preferredBidirectionalCompoundReferenceNameMask"], decoded_value.preferredBidirectionalCompoundReferenceNameMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1SessionCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1SessionCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMaxLevel"] = static_cast<bool>(decoded_value.useMaxLevel);
        FieldToJsonResolve(jdata["maxLevel"], decoded_value.maxLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1SessionCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1SessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdSequenceHeader"], meta_struct.pStdSequenceHeader, options);
        FieldToJsonResolve(jdata["pStdDecoderModelInfo"], meta_struct.pStdDecoderModelInfo, options);
        FieldToJsonResolve(jdata["stdOperatingPointCount"], decoded_value.stdOperatingPointCount, options);
        FieldToJsonResolve(jdata["pStdOperatingPoints"], meta_struct.pStdOperatingPoints, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["predictionMode"], decoded_value.predictionMode, options);
        FieldToJsonResolve(jdata["rateControlGroup"], decoded_value.rateControlGroup, options);
        FieldToJsonResolve(jdata["constantQIndex"], decoded_value.constantQIndex, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["referenceNameSlotIndices"], &meta_struct.referenceNameSlotIndices, options);
        jdata["primaryReferenceCdfOnly"] = static_cast<bool>(decoded_value.primaryReferenceCdfOnly);
        jdata["generateObuExtensionHeader"] = static_cast<bool>(decoded_value.generateObuExtensionHeader);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1DpbSlotInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1DpbSlotInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdReferenceInfo"], meta_struct.pStdReferenceInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1DpbSlotInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfile"], decoded_value.stdProfile, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1FrameSizeKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1FrameSizeKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1FrameSizeKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1FrameSizeKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["intraFrameSize"], decoded_value.intraFrameSize, options);
        FieldToJsonResolve(jdata["predictiveFrameSize"], decoded_value.predictiveFrameSize, options);
        FieldToJsonResolve(jdata["bipredictiveFrameSize"], decoded_value.bipredictiveFrameSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1FrameSizeKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1FrameSizeKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1GopRemainingFrameInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useGopRemainingFrames"] = static_cast<bool>(decoded_value.useGopRemainingFrames);
        FieldToJsonResolve(jdata["gopRemainingIntra"], decoded_value.gopRemainingIntra, options);
        FieldToJsonResolve(jdata["gopRemainingPredictive"], decoded_value.gopRemainingPredictive, options);
        FieldToJsonResolve(jdata["gopRemainingBipredictive"], decoded_value.gopRemainingBipredictive, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1RateControlInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1RateControlInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1RateControlInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1RateControlInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeAV1RateControlFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["gopFrameCount"], decoded_value.gopFrameCount, options);
        FieldToJsonResolve(jdata["keyFramePeriod"], decoded_value.keyFramePeriod, options);
        FieldToJsonResolve(jdata["consecutiveBipredictiveFrameCount"], decoded_value.consecutiveBipredictiveFrameCount, options);
        FieldToJsonResolve(jdata["temporalLayerCount"], decoded_value.temporalLayerCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1RateControlInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1RateControlInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1RateControlLayerInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["useMinQIndex"] = static_cast<bool>(decoded_value.useMinQIndex);
        FieldToJsonResolve(jdata["minQIndex"], meta_struct.minQIndex, options);
        jdata["useMaxQIndex"] = static_cast<bool>(decoded_value.useMaxQIndex);
        FieldToJsonResolve(jdata["maxQIndex"], meta_struct.maxQIndex, options);
        jdata["useMaxFrameSize"] = static_cast<bool>(decoded_value.useMaxFrameSize);
        FieldToJsonResolve(jdata["maxFrameSize"], meta_struct.maxFrameSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoDecodeVP9"] = static_cast<bool>(decoded_value.videoDecodeVP9);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeVP9ProfileInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9ProfileInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeVP9ProfileInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeVP9ProfileInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stdProfile"], decoded_value.stdProfile, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9ProfileInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeVP9ProfileInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeVP9CapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9CapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeVP9CapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeVP9CapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxLevel"], decoded_value.maxLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9CapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeVP9CapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeVP9PictureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9PictureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeVP9PictureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeVP9PictureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdPictureInfo"], meta_struct.pStdPictureInfo, options);
        FieldToJsonResolve(jdata["referenceNameSlotIndices"], &meta_struct.referenceNameSlotIndices, options);
        FieldToJsonResolve(jdata["uncompressedHeaderOffset"], decoded_value.uncompressedHeaderOffset, options);
        FieldToJsonResolve(jdata["compressedHeaderOffset"], decoded_value.compressedHeaderOffset, options);
        FieldToJsonResolve(jdata["tilesOffset"], decoded_value.tilesOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeVP9PictureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeVP9PictureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoMaintenance1FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoMaintenance1"] = static_cast<bool>(decoded_value.videoMaintenance1);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoInlineQueryInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoInlineQueryInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoInlineQueryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoInlineQueryInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["queryPool"], meta_struct.queryPool, options);
        FieldToJsonResolve(jdata["firstQuery"], decoded_value.firstQuery, options);
        FieldToJsonResolve(jdata["queryCount"], decoded_value.queryCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoInlineQueryInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoInlineQueryInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["unifiedImageLayouts"] = static_cast<bool>(decoded_value.unifiedImageLayouts);
        jdata["unifiedImageLayoutsVideo"] = static_cast<bool>(decoded_value.unifiedImageLayoutsVideo);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentFeedbackLoopInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentFeedbackLoopInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentFeedbackLoopInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentFeedbackLoopInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["feedbackLoopEnable"] = static_cast<bool>(decoded_value.feedbackLoopEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentFeedbackLoopInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentFeedbackLoopInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCalibratedTimestampInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCalibratedTimestampInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCalibratedTimestampInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCalibratedTimestampInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["timeDomain"], decoded_value.timeDomain, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCalibratedTimestampInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCalibratedTimestampInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSetDescriptorBufferOffsetsInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSetDescriptorBufferOffsetsInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSetDescriptorBufferOffsetsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSetDescriptorBufferOffsetsInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        FieldToJsonResolve(jdata["firstSet"], decoded_value.firstSet, options);
        FieldToJsonResolve(jdata["setCount"], decoded_value.setCount, options);
        FieldToJsonResolve(jdata["pBufferIndices"], meta_struct.pBufferIndices, options);
        FieldToJsonResolve(jdata["pOffsets"], meta_struct.pOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSetDescriptorBufferOffsetsInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSetDescriptorBufferOffsetsInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindDescriptorBufferEmbeddedSamplersInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["stageFlags"], decoded_value.stageFlags, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        FieldToJsonResolve(jdata["set"], decoded_value.set, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeIntraRefreshCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeIntraRefreshModeFlagsKHR_t(),jdata["intraRefreshModes"], decoded_value.intraRefreshModes, options);
        FieldToJsonResolve(jdata["maxIntraRefreshCycleDuration"], decoded_value.maxIntraRefreshCycleDuration, options);
        FieldToJsonResolve(jdata["maxIntraRefreshActiveReferencePictures"], decoded_value.maxIntraRefreshActiveReferencePictures, options);
        jdata["partitionIndependentIntraRefreshRegions"] = static_cast<bool>(decoded_value.partitionIndependentIntraRefreshRegions);
        jdata["nonRectangularIntraRefreshRegions"] = static_cast<bool>(decoded_value.nonRectangularIntraRefreshRegions);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeSessionIntraRefreshCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["intraRefreshMode"], decoded_value.intraRefreshMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeIntraRefreshInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeIntraRefreshInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeIntraRefreshInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeIntraRefreshInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["intraRefreshCycleDuration"], decoded_value.intraRefreshCycleDuration, options);
        FieldToJsonResolve(jdata["intraRefreshIndex"], decoded_value.intraRefreshIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeIntraRefreshInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeIntraRefreshInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoReferenceIntraRefreshInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoReferenceIntraRefreshInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoReferenceIntraRefreshInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoReferenceIntraRefreshInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["dirtyIntraRefreshRegions"], decoded_value.dirtyIntraRefreshRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoReferenceIntraRefreshInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoReferenceIntraRefreshInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoEncodeIntraRefresh"] = static_cast<bool>(decoded_value.videoEncodeIntraRefresh);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxQuantizationMapExtent"], meta_struct.maxQuantizationMapExtent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoFormatQuantizationMapPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatQuantizationMapPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatQuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatQuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["quantizationMapTexelSize"], meta_struct.quantizationMapTexelSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatQuantizationMapPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoFormatQuantizationMapPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["quantizationMap"], meta_struct.quantizationMap, options);
        FieldToJsonResolve(jdata["quantizationMapExtent"], meta_struct.quantizationMapExtent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["quantizationMapTexelSize"], meta_struct.quantizationMapTexelSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoEncodeQuantizationMap"] = static_cast<bool>(decoded_value.videoEncodeQuantizationMap);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH264QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minQpDelta"], decoded_value.minQpDelta, options);
        FieldToJsonResolve(jdata["maxQpDelta"], decoded_value.maxQpDelta, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeH265QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minQpDelta"], decoded_value.minQpDelta, options);
        FieldToJsonResolve(jdata["maxQpDelta"], decoded_value.maxQpDelta, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatH265QuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeH265CtbSizeFlagsKHR_t(),jdata["compatibleCtbSizes"], decoded_value.compatibleCtbSizes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minQIndexDelta"], decoded_value.minQIndexDelta, options);
        FieldToJsonResolve(jdata["maxQIndexDelta"], decoded_value.maxQIndexDelta, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoFormatAV1QuantizationMapPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkVideoEncodeAV1SuperblockSizeFlagsKHR_t(),jdata["compatibleSuperblockSizes"], decoded_value.compatibleSuperblockSizes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderRelaxedExtendedInstruction"] = static_cast<bool>(decoded_value.shaderRelaxedExtendedInstruction);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance7FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance7"] = static_cast<bool>(decoded_value.maintenance7);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance7PropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["robustFragmentShadingRateAttachmentAccess"] = static_cast<bool>(decoded_value.robustFragmentShadingRateAttachmentAccess);
        jdata["separateDepthStencilAttachmentAccess"] = static_cast<bool>(decoded_value.separateDepthStencilAttachmentAccess);
        FieldToJsonResolve(jdata["maxDescriptorSetTotalUniformBuffersDynamic"], decoded_value.maxDescriptorSetTotalUniformBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetTotalStorageBuffersDynamic"], decoded_value.maxDescriptorSetTotalStorageBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetTotalBuffersDynamic"], decoded_value.maxDescriptorSetTotalBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindTotalBuffersDynamic"], decoded_value.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vendorID"], decoded_value.vendorID, options);
        FieldToJsonResolve(jdata["deviceID"], decoded_value.deviceID, options);
        FieldToJsonResolve(jdata["layeredAPI"], decoded_value.layeredAPI, options);
        FieldToJsonResolve(jdata["deviceName"], &meta_struct.deviceName, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiPropertiesListKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["layeredApiCount"], decoded_value.layeredApiCount, options);
        FieldToJsonResolve(jdata["pLayeredApis"], meta_struct.pLayeredApis, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["properties"], meta_struct.properties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance8FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance8"] = static_cast<bool>(decoded_value.maintenance8);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryBarrierAccessFlags3KHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrierAccessFlags3KHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryBarrierAccessFlags3KHR& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryBarrierAccessFlags3KHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAccessFlags3KHR_t(),jdata["srcAccessMask3"], decoded_value.srcAccessMask3, options);
        FieldToJson(VkAccessFlags3KHR_t(),jdata["dstAccessMask3"], decoded_value.dstAccessMask3, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryBarrierAccessFlags3KHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryBarrierAccessFlags3KHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance9FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["maintenance9"] = static_cast<bool>(decoded_value.maintenance9);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMaintenance9PropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["image2DViewOf3DSparse"] = static_cast<bool>(decoded_value.image2DViewOf3DSparse);
        FieldToJsonResolve(jdata["defaultVertexAttributeValue"], decoded_value.defaultVertexAttributeValue, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyOwnershipTransferPropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["optimalImageTransferToQueueFamilies"], decoded_value.optimalImageTransferToQueueFamilies, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVideoMaintenance2FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["videoMaintenance2"] = static_cast<bool>(decoded_value.videoMaintenance2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH264InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdSPS"], meta_struct.pStdSPS, options);
        FieldToJsonResolve(jdata["pStdPPS"], meta_struct.pStdPPS, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeH265InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdVPS"], meta_struct.pStdVPS, options);
        FieldToJsonResolve(jdata["pStdSPS"], meta_struct.pStdSPS, options);
        FieldToJsonResolve(jdata["pStdPPS"], meta_struct.pStdPPS, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVideoDecodeAV1InlineSessionParametersInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pStdSequenceHeader"], meta_struct.pStdSequenceHeader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["depthClampZeroOne"] = static_cast<bool>(decoded_value.depthClampZeroOne);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRobustness2FeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRobustness2FeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRobustness2FeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRobustness2FeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["robustBufferAccess2"] = static_cast<bool>(decoded_value.robustBufferAccess2);
        jdata["robustImageAccess2"] = static_cast<bool>(decoded_value.robustImageAccess2);
        jdata["nullDescriptor"] = static_cast<bool>(decoded_value.nullDescriptor);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRobustness2FeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRobustness2FeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRobustness2PropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRobustness2PropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRobustness2PropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRobustness2PropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["robustStorageBufferAccessSizeAlignment"], decoded_value.robustStorageBufferAccessSizeAlignment, options);
        FieldToJsonResolve(jdata["robustUniformBufferAccessSizeAlignment"], decoded_value.robustUniformBufferAccessSizeAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRobustness2PropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRobustness2PropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentModeFifoLatestReady"] = static_cast<bool>(decoded_value.presentModeFifoLatestReady);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugReportCallbackCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugReportCallbackCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugReportCallbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugReportCallbackCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDebugReportFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pfnCallback"], to_hex_variable_width(meta_struct.pfnCallback), options);
        FieldToJsonResolve(jdata["pUserData"], to_hex_variable_width(meta_struct.pUserData), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugReportCallbackCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugReportCallbackCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationStateRasterizationOrderAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateRasterizationOrderAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["rasterizationOrder"], decoded_value.rasterizationOrder, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationStateRasterizationOrderAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugMarkerObjectNameInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerObjectNameInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerObjectNameInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerObjectNameInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["objectType"], decoded_value.objectType, options);
        FieldToJsonResolve(jdata["object"], decoded_value.object, options);
        FieldToJsonResolve(jdata["pObjectName"], &meta_struct.pObjectName, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerObjectNameInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugMarkerObjectNameInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugMarkerObjectTagInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerObjectTagInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerObjectTagInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerObjectTagInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["objectType"], decoded_value.objectType, options);
        FieldToJsonResolve(jdata["object"], decoded_value.object, options);
        FieldToJsonResolve(jdata["tagName"], decoded_value.tagName, options);
        FieldToJsonResolve(jdata["tagSize"], decoded_value.tagSize, options);
        FieldToJsonResolve(jdata["pTag"], meta_struct.pTag, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerObjectTagInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugMarkerObjectTagInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugMarkerMarkerInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerMarkerInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugMarkerMarkerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugMarkerMarkerInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pMarkerName"], &meta_struct.pMarkerName, options);
        FieldToJsonResolve(jdata["color"], &meta_struct.color, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugMarkerMarkerInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugMarkerMarkerInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDedicatedAllocationImageCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationImageCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationImageCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationImageCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dedicatedAllocation"] = static_cast<bool>(decoded_value.dedicatedAllocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationImageCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDedicatedAllocationImageCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDedicatedAllocationBufferCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationBufferCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationBufferCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationBufferCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dedicatedAllocation"] = static_cast<bool>(decoded_value.dedicatedAllocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationBufferCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDedicatedAllocationBufferCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDedicatedAllocationMemoryAllocateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDedicatedAllocationMemoryAllocateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["image"], meta_struct.image, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDedicatedAllocationMemoryAllocateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTransformFeedbackFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["transformFeedback"] = static_cast<bool>(decoded_value.transformFeedback);
        jdata["geometryStreams"] = static_cast<bool>(decoded_value.geometryStreams);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTransformFeedbackPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackStreams"], decoded_value.maxTransformFeedbackStreams, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackBuffers"], decoded_value.maxTransformFeedbackBuffers, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackBufferSize"], decoded_value.maxTransformFeedbackBufferSize, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackStreamDataSize"], decoded_value.maxTransformFeedbackStreamDataSize, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackBufferDataSize"], decoded_value.maxTransformFeedbackBufferDataSize, options);
        FieldToJsonResolve(jdata["maxTransformFeedbackBufferDataStride"], decoded_value.maxTransformFeedbackBufferDataStride, options);
        jdata["transformFeedbackQueries"] = static_cast<bool>(decoded_value.transformFeedbackQueries);
        jdata["transformFeedbackStreamsLinesTriangles"] = static_cast<bool>(decoded_value.transformFeedbackStreamsLinesTriangles);
        jdata["transformFeedbackRasterizationStreamSelect"] = static_cast<bool>(decoded_value.transformFeedbackRasterizationStreamSelect);
        jdata["transformFeedbackDraw"] = static_cast<bool>(decoded_value.transformFeedbackDraw);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationStateStreamCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineRasterizationStateStreamCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["rasterizationStream"], decoded_value.rasterizationStream, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewHandleInfoNVX>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewHandleInfoNVX* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewHandleInfoNVX& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewHandleInfoNVX& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["imageView"], meta_struct.imageView, options);
        FieldToJsonResolve(jdata["descriptorType"], decoded_value.descriptorType, options);
        HandleToJson(jdata["sampler"], meta_struct.sampler, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewHandleInfoNVX* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewHandleInfoNVX>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewAddressPropertiesNVX>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewAddressPropertiesNVX* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewAddressPropertiesNVX& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewAddressPropertiesNVX& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewAddressPropertiesNVX* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewAddressPropertiesNVX>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTextureLODGatherFormatPropertiesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTextureLODGatherFormatPropertiesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTextureLODGatherFormatPropertiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkTextureLODGatherFormatPropertiesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["supportsTextureGatherLODBiasAMD"] = static_cast<bool>(decoded_value.supportsTextureGatherLODBiasAMD);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTextureLODGatherFormatPropertiesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTextureLODGatherFormatPropertiesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShaderResourceUsageAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShaderResourceUsageAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShaderResourceUsageAMD& decoded_value = *data->decoded_value;
        const Decoded_VkShaderResourceUsageAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["numUsedVgprs"], decoded_value.numUsedVgprs, options);
        FieldToJsonResolve(jdata["numUsedSgprs"], decoded_value.numUsedSgprs, options);
        FieldToJsonResolve(jdata["ldsSizePerLocalWorkGroup"], decoded_value.ldsSizePerLocalWorkGroup, options);
        FieldToJsonResolve(jdata["ldsUsageSizeInBytes"], decoded_value.ldsUsageSizeInBytes, options);
        FieldToJsonResolve(jdata["scratchMemUsageInBytes"], decoded_value.scratchMemUsageInBytes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShaderResourceUsageAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShaderResourceUsageAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShaderStatisticsInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShaderStatisticsInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShaderStatisticsInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkShaderStatisticsInfoAMD& meta_struct = *data;

        FieldToJson(VkShaderStageFlags_t(),jdata["shaderStageMask"], decoded_value.shaderStageMask, options);
        FieldToJsonResolve(jdata["resourceUsage"], meta_struct.resourceUsage, options);
        FieldToJsonResolve(jdata["numPhysicalVgprs"], decoded_value.numPhysicalVgprs, options);
        FieldToJsonResolve(jdata["numPhysicalSgprs"], decoded_value.numPhysicalSgprs, options);
        FieldToJsonResolve(jdata["numAvailableVgprs"], decoded_value.numAvailableVgprs, options);
        FieldToJsonResolve(jdata["numAvailableSgprs"], decoded_value.numAvailableSgprs, options);
        FieldToJsonResolve(jdata["computeWorkGroupSize"], &meta_struct.computeWorkGroupSize, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShaderStatisticsInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShaderStatisticsInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkStreamDescriptorSurfaceCreateInfoGGP& decoded_value = *data->decoded_value;
        const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkStreamDescriptorSurfaceCreateFlagsGGP_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["streamDescriptor"], decoded_value.streamDescriptor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCornerSampledImageFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cornerSampledImage"] = static_cast<bool>(decoded_value.cornerSampledImage);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalImageFormatPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalImageFormatPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalImageFormatPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkExternalImageFormatPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["imageFormatProperties"], meta_struct.imageFormatProperties, options);
        FieldToJson(VkExternalMemoryFeatureFlagsNV_t(),jdata["externalMemoryFeatures"], decoded_value.externalMemoryFeatures, options);
        FieldToJson(VkExternalMemoryHandleTypeFlagsNV_t(),jdata["exportFromImportedHandleTypes"], decoded_value.exportFromImportedHandleTypes, options);
        FieldToJson(VkExternalMemoryHandleTypeFlagsNV_t(),jdata["compatibleHandleTypes"], decoded_value.compatibleHandleTypes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalImageFormatPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalImageFormatPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalMemoryImageCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryImageCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryImageCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryImageCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlagsNV_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryImageCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalMemoryImageCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportMemoryAllocateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryAllocateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryAllocateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryAllocateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlagsNV_t(),jdata["handleTypes"], decoded_value.handleTypes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryAllocateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportMemoryAllocateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryWin32HandleInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryWin32HandleInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryWin32HandleInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryWin32HandleInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkExternalMemoryHandleTypeFlagsNV_t(),jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], meta_struct.handle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryWin32HandleInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryWin32HandleInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExportMemoryWin32HandleInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryWin32HandleInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExportMemoryWin32HandleInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkExportMemoryWin32HandleInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pAttributes"], meta_struct.pAttributes, options);
        FieldToJsonResolve(jdata["dwAccess"], decoded_value.dwAccess, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExportMemoryWin32HandleInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExportMemoryWin32HandleInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWin32KeyedMutexAcquireReleaseInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["acquireCount"], decoded_value.acquireCount, options);
        HandleToJson(jdata["pAcquireSyncs"], &meta_struct.pAcquireSyncs, options);
        FieldToJsonResolve(jdata["pAcquireKeys"], meta_struct.pAcquireKeys, options);
        FieldToJsonResolve(jdata["pAcquireTimeoutMilliseconds"], meta_struct.pAcquireTimeoutMilliseconds, options);
        FieldToJsonResolve(jdata["releaseCount"], decoded_value.releaseCount, options);
        HandleToJson(jdata["pReleaseSyncs"], &meta_struct.pReleaseSyncs, options);
        FieldToJsonResolve(jdata["pReleaseKeys"], meta_struct.pReleaseKeys, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkValidationFlagsEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkValidationFlagsEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkValidationFlagsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationFlagsEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["disabledValidationCheckCount"], decoded_value.disabledValidationCheckCount, options);
        FieldToJsonResolve(jdata["pDisabledValidationChecks"], meta_struct.pDisabledValidationChecks, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkValidationFlagsEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkValidationFlagsEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkViSurfaceCreateInfoNN>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkViSurfaceCreateInfoNN* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkViSurfaceCreateInfoNN& decoded_value = *data->decoded_value;
        const Decoded_VkViSurfaceCreateInfoNN& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkViSurfaceCreateFlagsNN_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["window"], meta_struct.window, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkViSurfaceCreateInfoNN* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkViSurfaceCreateInfoNN>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewASTCDecodeModeEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewASTCDecodeModeEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewASTCDecodeModeEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewASTCDecodeModeEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["decodeMode"], decoded_value.decodeMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewASTCDecodeModeEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewASTCDecodeModeEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceASTCDecodeFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["decodeModeSharedExponent"] = static_cast<bool>(decoded_value.decodeModeSharedExponent);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkConditionalRenderingBeginInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkConditionalRenderingBeginInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkConditionalRenderingBeginInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkConditionalRenderingBeginInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJson(VkConditionalRenderingFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkConditionalRenderingBeginInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkConditionalRenderingBeginInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceConditionalRenderingFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["conditionalRendering"] = static_cast<bool>(decoded_value.conditionalRendering);
        jdata["inheritedConditionalRendering"] = static_cast<bool>(decoded_value.inheritedConditionalRendering);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceConditionalRenderingInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["conditionalRenderingEnable"] = static_cast<bool>(decoded_value.conditionalRenderingEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkViewportWScalingNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkViewportWScalingNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkViewportWScalingNV& decoded_value = *data->decoded_value;
        const Decoded_VkViewportWScalingNV& meta_struct = *data;

        FieldToJsonResolve(jdata["xcoeff"], decoded_value.xcoeff, options);
        FieldToJsonResolve(jdata["ycoeff"], decoded_value.ycoeff, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkViewportWScalingNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkViewportWScalingNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportWScalingStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportWScalingStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["viewportWScalingEnable"] = static_cast<bool>(decoded_value.viewportWScalingEnable);
        FieldToJsonResolve(jdata["viewportCount"], decoded_value.viewportCount, options);
        FieldToJsonResolve(jdata["pViewportWScalings"], meta_struct.pViewportWScalings, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportWScalingStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportWScalingStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilities2EXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilities2EXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilities2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilities2EXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minImageCount"], decoded_value.minImageCount, options);
        FieldToJsonResolve(jdata["maxImageCount"], decoded_value.maxImageCount, options);
        FieldToJsonResolve(jdata["currentExtent"], meta_struct.currentExtent, options);
        FieldToJsonResolve(jdata["minImageExtent"], meta_struct.minImageExtent, options);
        FieldToJsonResolve(jdata["maxImageExtent"], meta_struct.maxImageExtent, options);
        FieldToJsonResolve(jdata["maxImageArrayLayers"], decoded_value.maxImageArrayLayers, options);
        FieldToJson(VkSurfaceTransformFlagsKHR_t(),jdata["supportedTransforms"], decoded_value.supportedTransforms, options);
        FieldToJsonResolve(jdata["currentTransform"], decoded_value.currentTransform, options);
        FieldToJson(VkCompositeAlphaFlagsKHR_t(),jdata["supportedCompositeAlpha"], decoded_value.supportedCompositeAlpha, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["supportedUsageFlags"], decoded_value.supportedUsageFlags, options);
        FieldToJson(VkSurfaceCounterFlagsEXT_t(),jdata["supportedSurfaceCounters"], decoded_value.supportedSurfaceCounters, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilities2EXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilities2EXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayPowerInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPowerInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayPowerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayPowerInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["powerState"], decoded_value.powerState, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayPowerInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayPowerInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceEventInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceEventInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceEventInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceEventInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceEvent"], decoded_value.deviceEvent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceEventInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceEventInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayEventInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayEventInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayEventInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayEventInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displayEvent"], decoded_value.displayEvent, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayEventInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayEventInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainCounterCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainCounterCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainCounterCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainCounterCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSurfaceCounterFlagsEXT_t(),jdata["surfaceCounters"], decoded_value.surfaceCounters, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainCounterCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainCounterCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRefreshCycleDurationGOOGLE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRefreshCycleDurationGOOGLE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRefreshCycleDurationGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkRefreshCycleDurationGOOGLE& meta_struct = *data;

        FieldToJsonResolve(jdata["refreshDuration"], decoded_value.refreshDuration, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRefreshCycleDurationGOOGLE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRefreshCycleDurationGOOGLE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPastPresentationTimingGOOGLE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPastPresentationTimingGOOGLE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPastPresentationTimingGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPastPresentationTimingGOOGLE& meta_struct = *data;

        FieldToJsonResolve(jdata["presentID"], decoded_value.presentID, options);
        FieldToJsonResolve(jdata["desiredPresentTime"], decoded_value.desiredPresentTime, options);
        FieldToJsonResolve(jdata["actualPresentTime"], decoded_value.actualPresentTime, options);
        FieldToJsonResolve(jdata["earliestPresentTime"], decoded_value.earliestPresentTime, options);
        FieldToJsonResolve(jdata["presentMargin"], decoded_value.presentMargin, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPastPresentationTimingGOOGLE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPastPresentationTimingGOOGLE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentTimeGOOGLE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentTimeGOOGLE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentTimeGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPresentTimeGOOGLE& meta_struct = *data;

        FieldToJsonResolve(jdata["presentID"], decoded_value.presentID, options);
        FieldToJsonResolve(jdata["desiredPresentTime"], decoded_value.desiredPresentTime, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentTimeGOOGLE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentTimeGOOGLE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentTimesInfoGOOGLE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentTimesInfoGOOGLE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentTimesInfoGOOGLE& decoded_value = *data->decoded_value;
        const Decoded_VkPresentTimesInfoGOOGLE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["swapchainCount"], decoded_value.swapchainCount, options);
        FieldToJsonResolve(jdata["pTimes"], meta_struct.pTimes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentTimesInfoGOOGLE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentTimesInfoGOOGLE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["perViewPositionAllComponents"] = static_cast<bool>(decoded_value.perViewPositionAllComponents);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultiviewPerViewAttributesInfoNVX>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultiviewPerViewAttributesInfoNVX* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultiviewPerViewAttributesInfoNVX& decoded_value = *data->decoded_value;
        const Decoded_VkMultiviewPerViewAttributesInfoNVX& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["perViewAttributes"] = static_cast<bool>(decoded_value.perViewAttributes);
        jdata["perViewAttributesPositionXOnly"] = static_cast<bool>(decoded_value.perViewAttributesPositionXOnly);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultiviewPerViewAttributesInfoNVX* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultiviewPerViewAttributesInfoNVX>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkViewportSwizzleNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkViewportSwizzleNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkViewportSwizzleNV& decoded_value = *data->decoded_value;
        const Decoded_VkViewportSwizzleNV& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
        FieldToJsonResolve(jdata["z"], decoded_value.z, options);
        FieldToJsonResolve(jdata["w"], decoded_value.w, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkViewportSwizzleNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkViewportSwizzleNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportSwizzleStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportSwizzleStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineViewportSwizzleStateCreateFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["viewportCount"], decoded_value.viewportCount, options);
        FieldToJsonResolve(jdata["pViewportSwizzles"], meta_struct.pViewportSwizzles, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportSwizzleStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDiscardRectanglePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxDiscardRectangles"], decoded_value.maxDiscardRectangles, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineDiscardRectangleStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineDiscardRectangleStateCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["discardRectangleMode"], decoded_value.discardRectangleMode, options);
        FieldToJsonResolve(jdata["discardRectangleCount"], decoded_value.discardRectangleCount, options);
        FieldToJsonResolve(jdata["pDiscardRectangles"], meta_struct.pDiscardRectangles, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["primitiveOverestimationSize"], decoded_value.primitiveOverestimationSize, options);
        FieldToJsonResolve(jdata["maxExtraPrimitiveOverestimationSize"], decoded_value.maxExtraPrimitiveOverestimationSize, options);
        FieldToJsonResolve(jdata["extraPrimitiveOverestimationSizeGranularity"], decoded_value.extraPrimitiveOverestimationSizeGranularity, options);
        jdata["primitiveUnderestimation"] = static_cast<bool>(decoded_value.primitiveUnderestimation);
        jdata["conservativePointAndLineRasterization"] = static_cast<bool>(decoded_value.conservativePointAndLineRasterization);
        jdata["degenerateTrianglesRasterized"] = static_cast<bool>(decoded_value.degenerateTrianglesRasterized);
        jdata["degenerateLinesRasterized"] = static_cast<bool>(decoded_value.degenerateLinesRasterized);
        jdata["fullyCoveredFragmentShaderInputVariable"] = static_cast<bool>(decoded_value.fullyCoveredFragmentShaderInputVariable);
        jdata["conservativeRasterizationPostDepthCoverage"] = static_cast<bool>(decoded_value.conservativeRasterizationPostDepthCoverage);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationConservativeStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineRasterizationConservativeStateCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["conservativeRasterizationMode"], decoded_value.conservativeRasterizationMode, options);
        FieldToJsonResolve(jdata["extraPrimitiveOverestimationSize"], decoded_value.extraPrimitiveOverestimationSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClipEnableFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["depthClipEnable"] = static_cast<bool>(decoded_value.depthClipEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationDepthClipStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineRasterizationDepthClipStateCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        jdata["depthClipEnable"] = static_cast<bool>(decoded_value.depthClipEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkXYColorEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkXYColorEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkXYColorEXT& decoded_value = *data->decoded_value;
        const Decoded_VkXYColorEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkXYColorEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkXYColorEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkHdrMetadataEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkHdrMetadataEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkHdrMetadataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkHdrMetadataEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displayPrimaryRed"], meta_struct.displayPrimaryRed, options);
        FieldToJsonResolve(jdata["displayPrimaryGreen"], meta_struct.displayPrimaryGreen, options);
        FieldToJsonResolve(jdata["displayPrimaryBlue"], meta_struct.displayPrimaryBlue, options);
        FieldToJsonResolve(jdata["whitePoint"], meta_struct.whitePoint, options);
        FieldToJsonResolve(jdata["maxLuminance"], decoded_value.maxLuminance, options);
        FieldToJsonResolve(jdata["minLuminance"], decoded_value.minLuminance, options);
        FieldToJsonResolve(jdata["maxContentLightLevel"], decoded_value.maxContentLightLevel, options);
        FieldToJsonResolve(jdata["maxFrameAverageLightLevel"], decoded_value.maxFrameAverageLightLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkHdrMetadataEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkHdrMetadataEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["relaxedLineRasterization"] = static_cast<bool>(decoded_value.relaxedLineRasterization);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIOSSurfaceCreateInfoMVK>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIOSSurfaceCreateInfoMVK* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIOSSurfaceCreateInfoMVK& decoded_value = *data->decoded_value;
        const Decoded_VkIOSSurfaceCreateInfoMVK& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkIOSSurfaceCreateFlagsMVK_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pView"], meta_struct.pView, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIOSSurfaceCreateInfoMVK* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIOSSurfaceCreateInfoMVK>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMacOSSurfaceCreateInfoMVK>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMacOSSurfaceCreateInfoMVK* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMacOSSurfaceCreateInfoMVK& decoded_value = *data->decoded_value;
        const Decoded_VkMacOSSurfaceCreateInfoMVK& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMacOSSurfaceCreateFlagsMVK_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pView"], meta_struct.pView, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMacOSSurfaceCreateInfoMVK* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMacOSSurfaceCreateInfoMVK>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugUtilsLabelEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsLabelEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsLabelEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsLabelEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pLabelName"], &meta_struct.pLabelName, options);
        FieldToJsonResolve(jdata["color"], &meta_struct.color, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsLabelEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugUtilsLabelEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugUtilsObjectNameInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsObjectNameInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsObjectNameInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsObjectNameInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["objectType"], decoded_value.objectType, options);
        HandleToJson(jdata["objectHandle"], meta_struct.objectHandle, options);
        FieldToJsonResolve(jdata["pObjectName"], &meta_struct.pObjectName, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsObjectNameInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugUtilsObjectNameInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugUtilsMessengerCallbackDataEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsMessengerCallbackDataEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsMessengerCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsMessengerCallbackDataEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDebugUtilsMessengerCallbackDataFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pMessageIdName"], &meta_struct.pMessageIdName, options);
        FieldToJsonResolve(jdata["messageIdNumber"], decoded_value.messageIdNumber, options);
        FieldToJsonResolve(jdata["pMessage"], &meta_struct.pMessage, options);
        FieldToJsonResolve(jdata["queueLabelCount"], decoded_value.queueLabelCount, options);
        FieldToJsonResolve(jdata["pQueueLabels"], meta_struct.pQueueLabels, options);
        FieldToJsonResolve(jdata["cmdBufLabelCount"], decoded_value.cmdBufLabelCount, options);
        FieldToJsonResolve(jdata["pCmdBufLabels"], meta_struct.pCmdBufLabels, options);
        FieldToJsonResolve(jdata["objectCount"], decoded_value.objectCount, options);
        FieldToJsonResolve(jdata["pObjects"], meta_struct.pObjects, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsMessengerCallbackDataEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugUtilsMessengerCallbackDataEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugUtilsMessengerCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsMessengerCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsMessengerCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsMessengerCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDebugUtilsMessengerCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJson(VkDebugUtilsMessageSeverityFlagsEXT_t(),jdata["messageSeverity"], decoded_value.messageSeverity, options);
        FieldToJson(VkDebugUtilsMessageTypeFlagsEXT_t(),jdata["messageType"], decoded_value.messageType, options);
        FieldToJsonResolve(jdata["pfnUserCallback"], to_hex_variable_width(meta_struct.pfnUserCallback), options);
        FieldToJsonResolve(jdata["pUserData"], to_hex_variable_width(meta_struct.pUserData), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsMessengerCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugUtilsMessengerCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDebugUtilsObjectTagInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsObjectTagInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDebugUtilsObjectTagInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDebugUtilsObjectTagInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["objectType"], decoded_value.objectType, options);
        HandleToJson(jdata["objectHandle"], meta_struct.objectHandle, options);
        FieldToJsonResolve(jdata["tagName"], decoded_value.tagName, options);
        FieldToJsonResolve(jdata["tagSize"], decoded_value.tagSize, options);
        FieldToJsonResolve(jdata["pTag"], meta_struct.pTag, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDebugUtilsObjectTagInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDebugUtilsObjectTagInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidHardwareBufferUsageANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferUsageANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferUsageANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferUsageANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["androidHardwareBufferUsage"], decoded_value.androidHardwareBufferUsage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferUsageANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidHardwareBufferUsageANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidHardwareBufferPropertiesANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferPropertiesANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferPropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferPropertiesANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["allocationSize"], decoded_value.allocationSize, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferPropertiesANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidHardwareBufferPropertiesANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatPropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["externalFormat"], decoded_value.externalFormat, options);
        FieldToJson(VkFormatFeatureFlags_t(),jdata["formatFeatures"], decoded_value.formatFeatures, options);
        FieldToJsonResolve(jdata["samplerYcbcrConversionComponents"], meta_struct.samplerYcbcrConversionComponents, options);
        FieldToJsonResolve(jdata["suggestedYcbcrModel"], decoded_value.suggestedYcbcrModel, options);
        FieldToJsonResolve(jdata["suggestedYcbcrRange"], decoded_value.suggestedYcbcrRange, options);
        FieldToJsonResolve(jdata["suggestedXChromaOffset"], decoded_value.suggestedXChromaOffset, options);
        FieldToJsonResolve(jdata["suggestedYChromaOffset"], decoded_value.suggestedYChromaOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportAndroidHardwareBufferInfoANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportAndroidHardwareBufferInfoANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportAndroidHardwareBufferInfoANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkImportAndroidHardwareBufferInfoANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportAndroidHardwareBufferInfoANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportAndroidHardwareBufferInfoANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetAndroidHardwareBufferInfoANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalFormatANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalFormatANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalFormatANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkExternalFormatANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["externalFormat"], decoded_value.externalFormat, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalFormatANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalFormatANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatProperties2ANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["externalFormat"], decoded_value.externalFormat, options);
        FieldToJson(VkFormatFeatureFlags2_t(),jdata["formatFeatures"], decoded_value.formatFeatures, options);
        FieldToJsonResolve(jdata["samplerYcbcrConversionComponents"], meta_struct.samplerYcbcrConversionComponents, options);
        FieldToJsonResolve(jdata["suggestedYcbcrModel"], decoded_value.suggestedYcbcrModel, options);
        FieldToJsonResolve(jdata["suggestedYcbcrRange"], decoded_value.suggestedYcbcrRange, options);
        FieldToJsonResolve(jdata["suggestedXChromaOffset"], decoded_value.suggestedXChromaOffset, options);
        FieldToJsonResolve(jdata["suggestedYChromaOffset"], decoded_value.suggestedYChromaOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentSampleCountInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentSampleCountInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentSampleCountInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentSampleCountInfoAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["colorAttachmentCount"], decoded_value.colorAttachmentCount, options);
        FieldToJsonResolve(jdata["pColorAttachmentSamples"], meta_struct.pColorAttachmentSamples, options);
        FieldToJsonResolve(jdata["depthStencilAttachmentSamples"], decoded_value.depthStencilAttachmentSamples, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentSampleCountInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentSampleCountInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSampleLocationEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSampleLocationEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSampleLocationEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSampleLocationEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["x"], decoded_value.x, options);
        FieldToJsonResolve(jdata["y"], decoded_value.y, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSampleLocationEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSampleLocationEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSampleLocationsInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSampleLocationsInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSampleLocationsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSampleLocationsInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["sampleLocationsPerPixel"], decoded_value.sampleLocationsPerPixel, options);
        FieldToJsonResolve(jdata["sampleLocationGridSize"], meta_struct.sampleLocationGridSize, options);
        FieldToJsonResolve(jdata["sampleLocationsCount"], decoded_value.sampleLocationsCount, options);
        FieldToJsonResolve(jdata["pSampleLocations"], meta_struct.pSampleLocations, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSampleLocationsInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSampleLocationsInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAttachmentSampleLocationsEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentSampleLocationsEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAttachmentSampleLocationsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkAttachmentSampleLocationsEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["attachmentIndex"], decoded_value.attachmentIndex, options);
        FieldToJsonResolve(jdata["sampleLocationsInfo"], meta_struct.sampleLocationsInfo, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAttachmentSampleLocationsEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAttachmentSampleLocationsEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassSampleLocationsEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassSampleLocationsEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassSampleLocationsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassSampleLocationsEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["subpassIndex"], decoded_value.subpassIndex, options);
        FieldToJsonResolve(jdata["sampleLocationsInfo"], meta_struct.sampleLocationsInfo, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassSampleLocationsEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassSampleLocationsEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSampleLocationsBeginInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSampleLocationsBeginInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["attachmentInitialSampleLocationsCount"], decoded_value.attachmentInitialSampleLocationsCount, options);
        FieldToJsonResolve(jdata["pAttachmentInitialSampleLocations"], meta_struct.pAttachmentInitialSampleLocations, options);
        FieldToJsonResolve(jdata["postSubpassSampleLocationsCount"], decoded_value.postSubpassSampleLocationsCount, options);
        FieldToJsonResolve(jdata["pPostSubpassSampleLocations"], meta_struct.pPostSubpassSampleLocations, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSampleLocationsBeginInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassSampleLocationsBeginInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineSampleLocationsStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["sampleLocationsEnable"] = static_cast<bool>(decoded_value.sampleLocationsEnable);
        FieldToJsonResolve(jdata["sampleLocationsInfo"], meta_struct.sampleLocationsInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineSampleLocationsStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSampleLocationsPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["sampleLocationSampleCounts"], decoded_value.sampleLocationSampleCounts, options);
        FieldToJsonResolve(jdata["maxSampleLocationGridSize"], meta_struct.maxSampleLocationGridSize, options);
        FieldToJsonResolve(jdata["sampleLocationCoordinateRange"], &meta_struct.sampleLocationCoordinateRange, options);
        FieldToJsonResolve(jdata["sampleLocationSubPixelBits"], decoded_value.sampleLocationSubPixelBits, options);
        jdata["variableSampleLocations"] = static_cast<bool>(decoded_value.variableSampleLocations);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultisamplePropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultisamplePropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultisamplePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultisamplePropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxSampleLocationGridSize"], meta_struct.maxSampleLocationGridSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultisamplePropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultisamplePropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["advancedBlendCoherentOperations"] = static_cast<bool>(decoded_value.advancedBlendCoherentOperations);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["advancedBlendMaxColorAttachments"], decoded_value.advancedBlendMaxColorAttachments, options);
        jdata["advancedBlendIndependentBlend"] = static_cast<bool>(decoded_value.advancedBlendIndependentBlend);
        jdata["advancedBlendNonPremultipliedSrcColor"] = static_cast<bool>(decoded_value.advancedBlendNonPremultipliedSrcColor);
        jdata["advancedBlendNonPremultipliedDstColor"] = static_cast<bool>(decoded_value.advancedBlendNonPremultipliedDstColor);
        jdata["advancedBlendCorrelatedOverlap"] = static_cast<bool>(decoded_value.advancedBlendCorrelatedOverlap);
        jdata["advancedBlendAllOperations"] = static_cast<bool>(decoded_value.advancedBlendAllOperations);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorBlendAdvancedStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["srcPremultiplied"] = static_cast<bool>(decoded_value.srcPremultiplied);
        jdata["dstPremultiplied"] = static_cast<bool>(decoded_value.dstPremultiplied);
        FieldToJsonResolve(jdata["blendOverlap"], decoded_value.blendOverlap, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCoverageToColorStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageToColorStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageToColorStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCoverageToColorStateCreateFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        jdata["coverageToColorEnable"] = static_cast<bool>(decoded_value.coverageToColorEnable);
        FieldToJsonResolve(jdata["coverageToColorLocation"], decoded_value.coverageToColorLocation, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageToColorStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCoverageToColorStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCoverageModulationStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageModulationStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageModulationStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCoverageModulationStateCreateFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["coverageModulationMode"], decoded_value.coverageModulationMode, options);
        jdata["coverageModulationTableEnable"] = static_cast<bool>(decoded_value.coverageModulationTableEnable);
        FieldToJsonResolve(jdata["coverageModulationTableCount"], decoded_value.coverageModulationTableCount, options);
        FieldToJsonResolve(jdata["pCoverageModulationTable"], meta_struct.pCoverageModulationTable, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageModulationStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCoverageModulationStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderSMCount"], decoded_value.shaderSMCount, options);
        FieldToJsonResolve(jdata["shaderWarpsPerSM"], decoded_value.shaderWarpsPerSM, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderSMBuiltins"] = static_cast<bool>(decoded_value.shaderSMBuiltins);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["drmFormatModifier"], decoded_value.drmFormatModifier, options);
        FieldToJsonResolve(jdata["drmFormatModifierPlaneCount"], decoded_value.drmFormatModifierPlaneCount, options);
        FieldToJson(VkFormatFeatureFlags_t(),jdata["drmFormatModifierTilingFeatures"], decoded_value.drmFormatModifierTilingFeatures, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesListEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesListEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesListEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesListEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifierCount"], decoded_value.drmFormatModifierCount, options);
        FieldToJsonResolve(jdata["pDrmFormatModifierProperties"], meta_struct.pDrmFormatModifierProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesListEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesListEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifier"], decoded_value.drmFormatModifier, options);
        FieldToJsonResolve(jdata["sharingMode"], decoded_value.sharingMode, options);
        FieldToJsonResolve(jdata["queueFamilyIndexCount"], decoded_value.queueFamilyIndexCount, options);
        FieldToJsonResolve(jdata["pQueueFamilyIndices"], meta_struct.pQueueFamilyIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierListCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierListCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifierCount"], decoded_value.drmFormatModifierCount, options);
        FieldToJsonResolve(jdata["pDrmFormatModifiers"], meta_struct.pDrmFormatModifiers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierListCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageDrmFormatModifierListCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierExplicitCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifier"], decoded_value.drmFormatModifier, options);
        FieldToJsonResolve(jdata["drmFormatModifierPlaneCount"], decoded_value.drmFormatModifierPlaneCount, options);
        FieldToJsonResolve(jdata["pPlaneLayouts"], meta_struct.pPlaneLayouts, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageDrmFormatModifierPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageDrmFormatModifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageDrmFormatModifierPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifier"], decoded_value.drmFormatModifier, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageDrmFormatModifierPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageDrmFormatModifierPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrmFormatModifierProperties2EXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierProperties2EXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierProperties2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierProperties2EXT& meta_struct = *data;

        FieldToJsonResolve(jdata["drmFormatModifier"], decoded_value.drmFormatModifier, options);
        FieldToJsonResolve(jdata["drmFormatModifierPlaneCount"], decoded_value.drmFormatModifierPlaneCount, options);
        FieldToJson(VkFormatFeatureFlags2_t(),jdata["drmFormatModifierTilingFeatures"], decoded_value.drmFormatModifierTilingFeatures, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierProperties2EXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrmFormatModifierProperties2EXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesList2EXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesList2EXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrmFormatModifierPropertiesList2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrmFormatModifierPropertiesList2EXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["drmFormatModifierCount"], decoded_value.drmFormatModifierCount, options);
        FieldToJsonResolve(jdata["pDrmFormatModifierProperties"], meta_struct.pDrmFormatModifierProperties, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrmFormatModifierPropertiesList2EXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrmFormatModifierPropertiesList2EXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkValidationCacheCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkValidationCacheCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkValidationCacheCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationCacheCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkValidationCacheCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["initialDataSize"], decoded_value.initialDataSize, options);
        FieldToJsonResolve(jdata["pInitialData"], meta_struct.pInitialData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkValidationCacheCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkValidationCacheCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShaderModuleValidationCacheCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderModuleValidationCacheCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["validationCache"], meta_struct.validationCache, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShaderModuleValidationCacheCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShaderModuleValidationCacheCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShadingRatePaletteNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShadingRatePaletteNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShadingRatePaletteNV& decoded_value = *data->decoded_value;
        const Decoded_VkShadingRatePaletteNV& meta_struct = *data;

        FieldToJsonResolve(jdata["shadingRatePaletteEntryCount"], decoded_value.shadingRatePaletteEntryCount, options);
        FieldToJsonResolve(jdata["pShadingRatePaletteEntries"], meta_struct.pShadingRatePaletteEntries, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShadingRatePaletteNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShadingRatePaletteNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportShadingRateImageStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shadingRateImageEnable"] = static_cast<bool>(decoded_value.shadingRateImageEnable);
        FieldToJsonResolve(jdata["viewportCount"], decoded_value.viewportCount, options);
        FieldToJsonResolve(jdata["pShadingRatePalettes"], meta_struct.pShadingRatePalettes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShadingRateImageFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shadingRateImage"] = static_cast<bool>(decoded_value.shadingRateImage);
        jdata["shadingRateCoarseSampleOrder"] = static_cast<bool>(decoded_value.shadingRateCoarseSampleOrder);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShadingRateImagePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shadingRateTexelSize"], meta_struct.shadingRateTexelSize, options);
        FieldToJsonResolve(jdata["shadingRatePaletteSize"], decoded_value.shadingRatePaletteSize, options);
        FieldToJsonResolve(jdata["shadingRateMaxCoarseSamples"], decoded_value.shadingRateMaxCoarseSamples, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCoarseSampleLocationNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCoarseSampleLocationNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCoarseSampleLocationNV& decoded_value = *data->decoded_value;
        const Decoded_VkCoarseSampleLocationNV& meta_struct = *data;

        FieldToJsonResolve(jdata["pixelX"], decoded_value.pixelX, options);
        FieldToJsonResolve(jdata["pixelY"], decoded_value.pixelY, options);
        FieldToJsonResolve(jdata["sample"], decoded_value.sample, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCoarseSampleLocationNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCoarseSampleLocationNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCoarseSampleOrderCustomNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCoarseSampleOrderCustomNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCoarseSampleOrderCustomNV& decoded_value = *data->decoded_value;
        const Decoded_VkCoarseSampleOrderCustomNV& meta_struct = *data;

        FieldToJsonResolve(jdata["shadingRate"], decoded_value.shadingRate, options);
        FieldToJsonResolve(jdata["sampleCount"], decoded_value.sampleCount, options);
        FieldToJsonResolve(jdata["sampleLocationCount"], decoded_value.sampleLocationCount, options);
        FieldToJsonResolve(jdata["pSampleLocations"], meta_struct.pSampleLocations, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCoarseSampleOrderCustomNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCoarseSampleOrderCustomNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["sampleOrderType"], decoded_value.sampleOrderType, options);
        FieldToJsonResolve(jdata["customSampleOrderCount"], decoded_value.customSampleOrderCount, options);
        FieldToJsonResolve(jdata["pCustomSampleOrders"], meta_struct.pCustomSampleOrders, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRayTracingShaderGroupCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingShaderGroupCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingShaderGroupCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingShaderGroupCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["generalShader"], decoded_value.generalShader, options);
        FieldToJsonResolve(jdata["closestHitShader"], decoded_value.closestHitShader, options);
        FieldToJsonResolve(jdata["anyHitShader"], decoded_value.anyHitShader, options);
        FieldToJsonResolve(jdata["intersectionShader"], decoded_value.intersectionShader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingShaderGroupCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRayTracingShaderGroupCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRayTracingPipelineCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stageCount"], decoded_value.stageCount, options);
        FieldToJsonResolve(jdata["pStages"], meta_struct.pStages, options);
        FieldToJsonResolve(jdata["groupCount"], decoded_value.groupCount, options);
        FieldToJsonResolve(jdata["pGroups"], meta_struct.pGroups, options);
        FieldToJsonResolve(jdata["maxRecursionDepth"], decoded_value.maxRecursionDepth, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        HandleToJson(jdata["basePipelineHandle"], meta_struct.basePipelineHandle, options);
        FieldToJsonResolve(jdata["basePipelineIndex"], decoded_value.basePipelineIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRayTracingPipelineCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeometryTrianglesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeometryTrianglesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeometryTrianglesNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryTrianglesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["vertexData"], meta_struct.vertexData, options);
        FieldToJsonResolve(jdata["vertexOffset"], decoded_value.vertexOffset, options);
        FieldToJsonResolve(jdata["vertexCount"], decoded_value.vertexCount, options);
        FieldToJsonResolve(jdata["vertexStride"], decoded_value.vertexStride, options);
        FieldToJsonResolve(jdata["vertexFormat"], decoded_value.vertexFormat, options);
        HandleToJson(jdata["indexData"], meta_struct.indexData, options);
        FieldToJsonResolve(jdata["indexOffset"], decoded_value.indexOffset, options);
        FieldToJsonResolve(jdata["indexCount"], decoded_value.indexCount, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        HandleToJson(jdata["transformData"], meta_struct.transformData, options);
        FieldToJsonResolve(jdata["transformOffset"], decoded_value.transformOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeometryTrianglesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeometryTrianglesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeometryAABBNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeometryAABBNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeometryAABBNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryAABBNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["aabbData"], meta_struct.aabbData, options);
        FieldToJsonResolve(jdata["numAABBs"], decoded_value.numAABBs, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeometryAABBNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeometryAABBNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeometryDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeometryDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeometryDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["triangles"], meta_struct.triangles, options);
        FieldToJsonResolve(jdata["aabbs"], meta_struct.aabbs, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeometryDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeometryDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeometryNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeometryNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeometryNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeometryNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["geometryType"], decoded_value.geometryType, options);
        FieldToJsonResolve(jdata["geometry"], meta_struct.geometry, options);
        FieldToJson(VkGeometryFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeometryNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeometryNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJson(VkBuildAccelerationStructureFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["instanceCount"], decoded_value.instanceCount, options);
        FieldToJsonResolve(jdata["geometryCount"], decoded_value.geometryCount, options);
        FieldToJsonResolve(jdata["pGeometries"], meta_struct.pGeometries, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["compactedSize"], decoded_value.compactedSize, options);
        FieldToJsonResolve(jdata["info"], meta_struct.info, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindAccelerationStructureMemoryInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindAccelerationStructureMemoryInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindAccelerationStructureMemoryInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindAccelerationStructureMemoryInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["accelerationStructure"], meta_struct.accelerationStructure, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["memoryOffset"], decoded_value.memoryOffset, options);
        FieldToJsonResolve(jdata["deviceIndexCount"], decoded_value.deviceIndexCount, options);
        FieldToJsonResolve(jdata["pDeviceIndices"], meta_struct.pDeviceIndices, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindAccelerationStructureMemoryInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindAccelerationStructureMemoryInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteDescriptorSetAccelerationStructureNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetAccelerationStructureNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetAccelerationStructureNV& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetAccelerationStructureNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["accelerationStructureCount"], decoded_value.accelerationStructureCount, options);
        HandleToJson(jdata["pAccelerationStructures"], &meta_struct.pAccelerationStructures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetAccelerationStructureNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteDescriptorSetAccelerationStructureNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMemoryRequirementsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        HandleToJson(jdata["accelerationStructure"], meta_struct.accelerationStructure, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderGroupHandleSize"], decoded_value.shaderGroupHandleSize, options);
        FieldToJsonResolve(jdata["maxRecursionDepth"], decoded_value.maxRecursionDepth, options);
        FieldToJsonResolve(jdata["maxShaderGroupStride"], decoded_value.maxShaderGroupStride, options);
        FieldToJsonResolve(jdata["shaderGroupBaseAlignment"], decoded_value.shaderGroupBaseAlignment, options);
        FieldToJsonResolve(jdata["maxGeometryCount"], decoded_value.maxGeometryCount, options);
        FieldToJsonResolve(jdata["maxInstanceCount"], decoded_value.maxInstanceCount, options);
        FieldToJsonResolve(jdata["maxTriangleCount"], decoded_value.maxTriangleCount, options);
        FieldToJsonResolve(jdata["maxDescriptorSetAccelerationStructures"], decoded_value.maxDescriptorSetAccelerationStructures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTransformMatrixKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTransformMatrixKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTransformMatrixKHR& decoded_value = *data->decoded_value;
        const Decoded_VkTransformMatrixKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["matrix"], &meta_struct.matrix, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTransformMatrixKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTransformMatrixKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAabbPositionsKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAabbPositionsKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAabbPositionsKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAabbPositionsKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["minX"], decoded_value.minX, options);
        FieldToJsonResolve(jdata["minY"], decoded_value.minY, options);
        FieldToJsonResolve(jdata["minZ"], decoded_value.minZ, options);
        FieldToJsonResolve(jdata["maxX"], decoded_value.maxX, options);
        FieldToJsonResolve(jdata["maxY"], decoded_value.maxY, options);
        FieldToJsonResolve(jdata["maxZ"], decoded_value.maxZ, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAabbPositionsKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAabbPositionsKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureInstanceKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureInstanceKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureInstanceKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureInstanceKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["transform"], meta_struct.transform, options);
        FieldToJsonResolve(jdata["instanceCustomIndex"], decoded_value.instanceCustomIndex, options);
        FieldToJsonResolve(jdata["mask"], decoded_value.mask, options);
        FieldToJsonResolve(jdata["instanceShaderBindingTableRecordOffset"], decoded_value.instanceShaderBindingTableRecordOffset, options);
        FieldToJson(VkGeometryInstanceFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["accelerationStructureReference"], decoded_value.accelerationStructureReference, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureInstanceKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureInstanceKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["representativeFragmentTest"] = static_cast<bool>(decoded_value.representativeFragmentTest);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["representativeFragmentTestEnable"] = static_cast<bool>(decoded_value.representativeFragmentTestEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageViewImageFormatInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["imageViewType"], decoded_value.imageViewType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFilterCubicImageViewImageFormatPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["filterCubic"] = static_cast<bool>(decoded_value.filterCubic);
        jdata["filterCubicMinmax"] = static_cast<bool>(decoded_value.filterCubicMinmax);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryHostPointerInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryHostPointerInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryHostPointerInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryHostPointerInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pHostPointer"], meta_struct.pHostPointer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryHostPointerInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryHostPointerInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryHostPointerPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryHostPointerPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryHostPointerPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryHostPointerPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryHostPointerPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryHostPointerPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minImportedHostPointerAlignment"], decoded_value.minImportedHostPointerAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCompilerControlCreateInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCompilerControlCreateInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCompilerControlCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCompilerControlCreateInfoAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCompilerControlFlagsAMD_t(),jdata["compilerControlFlags"], decoded_value.compilerControlFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCompilerControlCreateInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCompilerControlCreateInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCorePropertiesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCorePropertiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderEngineCount"], decoded_value.shaderEngineCount, options);
        FieldToJsonResolve(jdata["shaderArraysPerEngineCount"], decoded_value.shaderArraysPerEngineCount, options);
        FieldToJsonResolve(jdata["computeUnitsPerShaderArray"], decoded_value.computeUnitsPerShaderArray, options);
        FieldToJsonResolve(jdata["simdPerComputeUnit"], decoded_value.simdPerComputeUnit, options);
        FieldToJsonResolve(jdata["wavefrontsPerSimd"], decoded_value.wavefrontsPerSimd, options);
        FieldToJsonResolve(jdata["wavefrontSize"], decoded_value.wavefrontSize, options);
        FieldToJsonResolve(jdata["sgprsPerSimd"], decoded_value.sgprsPerSimd, options);
        FieldToJsonResolve(jdata["minSgprAllocation"], decoded_value.minSgprAllocation, options);
        FieldToJsonResolve(jdata["maxSgprAllocation"], decoded_value.maxSgprAllocation, options);
        FieldToJsonResolve(jdata["sgprAllocationGranularity"], decoded_value.sgprAllocationGranularity, options);
        FieldToJsonResolve(jdata["vgprsPerSimd"], decoded_value.vgprsPerSimd, options);
        FieldToJsonResolve(jdata["minVgprAllocation"], decoded_value.minVgprAllocation, options);
        FieldToJsonResolve(jdata["maxVgprAllocation"], decoded_value.maxVgprAllocation, options);
        FieldToJsonResolve(jdata["vgprAllocationGranularity"], decoded_value.vgprAllocationGranularity, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCorePropertiesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceMemoryOverallocationCreateInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryOverallocationCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["overallocationBehavior"], decoded_value.overallocationBehavior, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceMemoryOverallocationCreateInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxVertexAttribDivisor"], decoded_value.maxVertexAttribDivisor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPresentFrameTokenGGP>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPresentFrameTokenGGP* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPresentFrameTokenGGP& decoded_value = *data->decoded_value;
        const Decoded_VkPresentFrameTokenGGP& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["frameToken"], decoded_value.frameToken, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPresentFrameTokenGGP* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPresentFrameTokenGGP>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["taskShader"] = static_cast<bool>(decoded_value.taskShader);
        jdata["meshShader"] = static_cast<bool>(decoded_value.meshShader);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxDrawMeshTasksCount"], decoded_value.maxDrawMeshTasksCount, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupInvocations"], decoded_value.maxTaskWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupSize"], &meta_struct.maxTaskWorkGroupSize, options);
        FieldToJsonResolve(jdata["maxTaskTotalMemorySize"], decoded_value.maxTaskTotalMemorySize, options);
        FieldToJsonResolve(jdata["maxTaskOutputCount"], decoded_value.maxTaskOutputCount, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupInvocations"], decoded_value.maxMeshWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupSize"], &meta_struct.maxMeshWorkGroupSize, options);
        FieldToJsonResolve(jdata["maxMeshTotalMemorySize"], decoded_value.maxMeshTotalMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshOutputVertices"], decoded_value.maxMeshOutputVertices, options);
        FieldToJsonResolve(jdata["maxMeshOutputPrimitives"], decoded_value.maxMeshOutputPrimitives, options);
        FieldToJsonResolve(jdata["maxMeshMultiviewViewCount"], decoded_value.maxMeshMultiviewViewCount, options);
        FieldToJsonResolve(jdata["meshOutputPerVertexGranularity"], decoded_value.meshOutputPerVertexGranularity, options);
        FieldToJsonResolve(jdata["meshOutputPerPrimitiveGranularity"], decoded_value.meshOutputPerPrimitiveGranularity, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrawMeshTasksIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrawMeshTasksIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrawMeshTasksIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkDrawMeshTasksIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["taskCount"], decoded_value.taskCount, options);
        FieldToJsonResolve(jdata["firstTask"], decoded_value.firstTask, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrawMeshTasksIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrawMeshTasksIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderImageFootprintFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imageFootprint"] = static_cast<bool>(decoded_value.imageFootprint);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportExclusiveScissorStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["exclusiveScissorCount"], decoded_value.exclusiveScissorCount, options);
        FieldToJsonResolve(jdata["pExclusiveScissors"], meta_struct.pExclusiveScissors, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExclusiveScissorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["exclusiveScissor"] = static_cast<bool>(decoded_value.exclusiveScissor);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyCheckpointPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyCheckpointPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyCheckpointPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyCheckpointPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags_t(),jdata["checkpointExecutionStageMask"], decoded_value.checkpointExecutionStageMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyCheckpointPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyCheckpointPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCheckpointDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCheckpointDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCheckpointDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkCheckpointDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stage"], decoded_value.stage, options);
        FieldToJsonResolve(jdata["pCheckpointMarker"], meta_struct.pCheckpointMarker, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCheckpointDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCheckpointDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueueFamilyCheckpointProperties2NV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyCheckpointProperties2NV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueueFamilyCheckpointProperties2NV& decoded_value = *data->decoded_value;
        const Decoded_VkQueueFamilyCheckpointProperties2NV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["checkpointExecutionStageMask"], decoded_value.checkpointExecutionStageMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueueFamilyCheckpointProperties2NV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueueFamilyCheckpointProperties2NV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCheckpointData2NV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCheckpointData2NV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCheckpointData2NV& decoded_value = *data->decoded_value;
        const Decoded_VkCheckpointData2NV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineStageFlags2_t(),jdata["stage"], decoded_value.stage, options);
        FieldToJsonResolve(jdata["pCheckpointMarker"], meta_struct.pCheckpointMarker, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCheckpointData2NV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCheckpointData2NV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderIntegerFunctions2"] = static_cast<bool>(decoded_value.shaderIntegerFunctions2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkInitializePerformanceApiInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkInitializePerformanceApiInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkInitializePerformanceApiInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkInitializePerformanceApiInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pUserData"], to_hex_variable_width(meta_struct.pUserData), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkInitializePerformanceApiInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkInitializePerformanceApiInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueryPoolPerformanceQueryCreateInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["performanceCountersSampling"], decoded_value.performanceCountersSampling, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceMarkerInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceMarkerInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceMarkerInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceMarkerInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["marker"], decoded_value.marker, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceMarkerInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceMarkerInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceStreamMarkerInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceStreamMarkerInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceStreamMarkerInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceStreamMarkerInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["marker"], decoded_value.marker, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceStreamMarkerInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceStreamMarkerInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceOverrideInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceOverrideInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceOverrideInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceOverrideInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        jdata["enable"] = static_cast<bool>(decoded_value.enable);
        FieldToJsonResolve(jdata["parameter"], decoded_value.parameter, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceOverrideInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceOverrideInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerformanceConfigurationAcquireInfoINTEL& decoded_value = *data->decoded_value;
        const Decoded_VkPerformanceConfigurationAcquireInfoINTEL& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerformanceConfigurationAcquireInfoINTEL* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePCIBusInfoPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pciDomain"], decoded_value.pciDomain, options);
        FieldToJsonResolve(jdata["pciBus"], decoded_value.pciBus, options);
        FieldToJsonResolve(jdata["pciDevice"], decoded_value.pciDevice, options);
        FieldToJsonResolve(jdata["pciFunction"], decoded_value.pciFunction, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayNativeHdrSurfaceCapabilitiesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["localDimmingSupport"] = static_cast<bool>(decoded_value.localDimmingSupport);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainDisplayNativeHdrCreateInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["localDimmingEnable"] = static_cast<bool>(decoded_value.localDimmingEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImagePipeSurfaceCreateInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImagePipeSurfaceCreateFlagsFUCHSIA_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["imagePipeHandle"], decoded_value.imagePipeHandle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMetalSurfaceCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMetalSurfaceCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMetalSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMetalSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMetalSurfaceCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pLayer"], meta_struct.pLayer, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMetalSurfaceCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMetalSurfaceCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentDensityMap"] = static_cast<bool>(decoded_value.fragmentDensityMap);
        jdata["fragmentDensityMapDynamic"] = static_cast<bool>(decoded_value.fragmentDensityMapDynamic);
        jdata["fragmentDensityMapNonSubsampledImages"] = static_cast<bool>(decoded_value.fragmentDensityMapNonSubsampledImages);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minFragmentDensityTexelSize"], meta_struct.minFragmentDensityTexelSize, options);
        FieldToJsonResolve(jdata["maxFragmentDensityTexelSize"], meta_struct.maxFragmentDensityTexelSize, options);
        jdata["fragmentDensityInvocations"] = static_cast<bool>(decoded_value.fragmentDensityInvocations);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassFragmentDensityMapCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["fragmentDensityMapAttachment"], meta_struct.fragmentDensityMapAttachment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingFragmentDensityMapAttachmentInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["imageView"], meta_struct.imageView, options);
        FieldToJsonResolve(jdata["imageLayout"], decoded_value.imageLayout, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreProperties2AMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreProperties2AMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderCorePropertiesFlagsAMD_t(),jdata["shaderCoreFeatures"], decoded_value.shaderCoreFeatures, options);
        FieldToJsonResolve(jdata["activeComputeUnitCount"], decoded_value.activeComputeUnitCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreProperties2AMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCoherentMemoryFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceCoherentMemory"] = static_cast<bool>(decoded_value.deviceCoherentMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderImageInt64Atomics"] = static_cast<bool>(decoded_value.shaderImageInt64Atomics);
        jdata["sparseImageInt64Atomics"] = static_cast<bool>(decoded_value.sparseImageInt64Atomics);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryBudgetPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["heapBudget"], &meta_struct.heapBudget, options);
        FieldToJsonResolve(jdata["heapUsage"], &meta_struct.heapUsage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMemoryPriorityFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["memoryPriority"] = static_cast<bool>(decoded_value.memoryPriority);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryPriorityAllocateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryPriorityAllocateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryPriorityAllocateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryPriorityAllocateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["priority"], decoded_value.priority, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryPriorityAllocateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryPriorityAllocateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dedicatedAllocationImageAliasing"] = static_cast<bool>(decoded_value.dedicatedAllocationImageAliasing);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["bufferDeviceAddress"] = static_cast<bool>(decoded_value.bufferDeviceAddress);
        jdata["bufferDeviceAddressCaptureReplay"] = static_cast<bool>(decoded_value.bufferDeviceAddressCaptureReplay);
        jdata["bufferDeviceAddressMultiDevice"] = static_cast<bool>(decoded_value.bufferDeviceAddressMultiDevice);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBufferDeviceAddressCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBufferDeviceAddressCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBufferDeviceAddressCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBufferDeviceAddressCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBufferDeviceAddressCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBufferDeviceAddressCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkValidationFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkValidationFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkValidationFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkValidationFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["enabledValidationFeatureCount"], decoded_value.enabledValidationFeatureCount, options);
        FieldToJsonResolve(jdata["pEnabledValidationFeatures"], meta_struct.pEnabledValidationFeatures, options);
        FieldToJsonResolve(jdata["disabledValidationFeatureCount"], decoded_value.disabledValidationFeatureCount, options);
        FieldToJsonResolve(jdata["pDisabledValidationFeatures"], meta_struct.pDisabledValidationFeatures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkValidationFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkValidationFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCooperativeMatrixPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["MSize"], decoded_value.MSize, options);
        FieldToJsonResolve(jdata["NSize"], decoded_value.NSize, options);
        FieldToJsonResolve(jdata["KSize"], decoded_value.KSize, options);
        FieldToJsonResolve(jdata["AType"], decoded_value.AType, options);
        FieldToJsonResolve(jdata["BType"], decoded_value.BType, options);
        FieldToJsonResolve(jdata["CType"], decoded_value.CType, options);
        FieldToJsonResolve(jdata["DType"], decoded_value.DType, options);
        FieldToJsonResolve(jdata["scope"], decoded_value.scope, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCooperativeMatrixPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cooperativeMatrix"] = static_cast<bool>(decoded_value.cooperativeMatrix);
        jdata["cooperativeMatrixRobustBufferAccess"] = static_cast<bool>(decoded_value.cooperativeMatrixRobustBufferAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrixPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["cooperativeMatrixSupportedStages"], decoded_value.cooperativeMatrixSupportedStages, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCoverageReductionModeFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["coverageReductionMode"] = static_cast<bool>(decoded_value.coverageReductionMode);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineCoverageReductionStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineCoverageReductionStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCoverageReductionStateCreateFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["coverageReductionMode"], decoded_value.coverageReductionMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineCoverageReductionStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineCoverageReductionStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFramebufferMixedSamplesCombinationNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferMixedSamplesCombinationNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFramebufferMixedSamplesCombinationNV& decoded_value = *data->decoded_value;
        const Decoded_VkFramebufferMixedSamplesCombinationNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["coverageReductionMode"], decoded_value.coverageReductionMode, options);
        FieldToJsonResolve(jdata["rasterizationSamples"], decoded_value.rasterizationSamples, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["depthStencilSamples"], decoded_value.depthStencilSamples, options);
        FieldToJson(VkSampleCountFlags_t(),jdata["colorSamples"], decoded_value.colorSamples, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFramebufferMixedSamplesCombinationNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFramebufferMixedSamplesCombinationNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentShaderSampleInterlock"] = static_cast<bool>(decoded_value.fragmentShaderSampleInterlock);
        jdata["fragmentShaderPixelInterlock"] = static_cast<bool>(decoded_value.fragmentShaderPixelInterlock);
        jdata["fragmentShaderShadingRateInterlock"] = static_cast<bool>(decoded_value.fragmentShaderShadingRateInterlock);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["ycbcrImageArrays"] = static_cast<bool>(decoded_value.ycbcrImageArrays);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProvokingVertexFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["provokingVertexLast"] = static_cast<bool>(decoded_value.provokingVertexLast);
        jdata["transformFeedbackPreservesProvokingVertex"] = static_cast<bool>(decoded_value.transformFeedbackPreservesProvokingVertex);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceProvokingVertexPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["provokingVertexModePerPipeline"] = static_cast<bool>(decoded_value.provokingVertexModePerPipeline);
        jdata["transformFeedbackPreservesTriangleFanProvokingVertex"] = static_cast<bool>(decoded_value.transformFeedbackPreservesTriangleFanProvokingVertex);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["provokingVertexMode"], decoded_value.provokingVertexMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFullScreenExclusiveInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFullScreenExclusiveInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["fullScreenExclusive"], decoded_value.fullScreenExclusive, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFullScreenExclusiveInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceFullScreenExclusiveInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesFullScreenExclusiveEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fullScreenExclusiveSupported"] = static_cast<bool>(decoded_value.fullScreenExclusiveSupported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceFullScreenExclusiveWin32InfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["hmonitor"], meta_struct.hmonitor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkHeadlessSurfaceCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkHeadlessSurfaceCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkHeadlessSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkHeadlessSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkHeadlessSurfaceCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkHeadlessSurfaceCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkHeadlessSurfaceCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderBufferFloat32Atomics"] = static_cast<bool>(decoded_value.shaderBufferFloat32Atomics);
        jdata["shaderBufferFloat32AtomicAdd"] = static_cast<bool>(decoded_value.shaderBufferFloat32AtomicAdd);
        jdata["shaderBufferFloat64Atomics"] = static_cast<bool>(decoded_value.shaderBufferFloat64Atomics);
        jdata["shaderBufferFloat64AtomicAdd"] = static_cast<bool>(decoded_value.shaderBufferFloat64AtomicAdd);
        jdata["shaderSharedFloat32Atomics"] = static_cast<bool>(decoded_value.shaderSharedFloat32Atomics);
        jdata["shaderSharedFloat32AtomicAdd"] = static_cast<bool>(decoded_value.shaderSharedFloat32AtomicAdd);
        jdata["shaderSharedFloat64Atomics"] = static_cast<bool>(decoded_value.shaderSharedFloat64Atomics);
        jdata["shaderSharedFloat64AtomicAdd"] = static_cast<bool>(decoded_value.shaderSharedFloat64AtomicAdd);
        jdata["shaderImageFloat32Atomics"] = static_cast<bool>(decoded_value.shaderImageFloat32Atomics);
        jdata["shaderImageFloat32AtomicAdd"] = static_cast<bool>(decoded_value.shaderImageFloat32AtomicAdd);
        jdata["sparseImageFloat32Atomics"] = static_cast<bool>(decoded_value.sparseImageFloat32Atomics);
        jdata["sparseImageFloat32AtomicAdd"] = static_cast<bool>(decoded_value.sparseImageFloat32AtomicAdd);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["extendedDynamicState"] = static_cast<bool>(decoded_value.extendedDynamicState);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["memoryMapPlaced"] = static_cast<bool>(decoded_value.memoryMapPlaced);
        jdata["memoryMapRangePlaced"] = static_cast<bool>(decoded_value.memoryMapRangePlaced);
        jdata["memoryUnmapReserve"] = static_cast<bool>(decoded_value.memoryUnmapReserve);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minPlacedMemoryMapAlignment"], decoded_value.minPlacedMemoryMapAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryMapPlacedInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMapPlacedInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMapPlacedInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMapPlacedInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pPlacedAddress"], meta_struct.pPlacedAddress, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMapPlacedInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryMapPlacedInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderBufferFloat16Atomics"] = static_cast<bool>(decoded_value.shaderBufferFloat16Atomics);
        jdata["shaderBufferFloat16AtomicAdd"] = static_cast<bool>(decoded_value.shaderBufferFloat16AtomicAdd);
        jdata["shaderBufferFloat16AtomicMinMax"] = static_cast<bool>(decoded_value.shaderBufferFloat16AtomicMinMax);
        jdata["shaderBufferFloat32AtomicMinMax"] = static_cast<bool>(decoded_value.shaderBufferFloat32AtomicMinMax);
        jdata["shaderBufferFloat64AtomicMinMax"] = static_cast<bool>(decoded_value.shaderBufferFloat64AtomicMinMax);
        jdata["shaderSharedFloat16Atomics"] = static_cast<bool>(decoded_value.shaderSharedFloat16Atomics);
        jdata["shaderSharedFloat16AtomicAdd"] = static_cast<bool>(decoded_value.shaderSharedFloat16AtomicAdd);
        jdata["shaderSharedFloat16AtomicMinMax"] = static_cast<bool>(decoded_value.shaderSharedFloat16AtomicMinMax);
        jdata["shaderSharedFloat32AtomicMinMax"] = static_cast<bool>(decoded_value.shaderSharedFloat32AtomicMinMax);
        jdata["shaderSharedFloat64AtomicMinMax"] = static_cast<bool>(decoded_value.shaderSharedFloat64AtomicMinMax);
        jdata["shaderImageFloat32AtomicMinMax"] = static_cast<bool>(decoded_value.shaderImageFloat32AtomicMinMax);
        jdata["sparseImageFloat32AtomicMinMax"] = static_cast<bool>(decoded_value.sparseImageFloat32AtomicMinMax);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxGraphicsShaderGroupCount"], decoded_value.maxGraphicsShaderGroupCount, options);
        FieldToJsonResolve(jdata["maxIndirectSequenceCount"], decoded_value.maxIndirectSequenceCount, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsTokenCount"], decoded_value.maxIndirectCommandsTokenCount, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsStreamCount"], decoded_value.maxIndirectCommandsStreamCount, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsTokenOffset"], decoded_value.maxIndirectCommandsTokenOffset, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsStreamStride"], decoded_value.maxIndirectCommandsStreamStride, options);
        FieldToJsonResolve(jdata["minSequencesCountBufferOffsetAlignment"], decoded_value.minSequencesCountBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minSequencesIndexBufferOffsetAlignment"], decoded_value.minSequencesIndexBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["minIndirectCommandsBufferOffsetAlignment"], decoded_value.minIndirectCommandsBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceGeneratedCommands"] = static_cast<bool>(decoded_value.deviceGeneratedCommands);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGraphicsShaderGroupCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsShaderGroupCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsShaderGroupCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsShaderGroupCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stageCount"], decoded_value.stageCount, options);
        FieldToJsonResolve(jdata["pStages"], meta_struct.pStages, options);
        FieldToJsonResolve(jdata["pVertexInputState"], meta_struct.pVertexInputState, options);
        FieldToJsonResolve(jdata["pTessellationState"], meta_struct.pTessellationState, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsShaderGroupCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGraphicsShaderGroupCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineShaderGroupsCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["groupCount"], decoded_value.groupCount, options);
        FieldToJsonResolve(jdata["pGroups"], meta_struct.pGroups, options);
        FieldToJsonResolve(jdata["pipelineCount"], decoded_value.pipelineCount, options);
        HandleToJson(jdata["pPipelines"], &meta_struct.pPipelines, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindShaderGroupIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindShaderGroupIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindShaderGroupIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindShaderGroupIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["groupIndex"], decoded_value.groupIndex, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindShaderGroupIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindShaderGroupIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindIndexBufferIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindIndexBufferIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindIndexBufferIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindIndexBufferIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferAddress"], to_hex_variable_width(decoded_value.bufferAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindIndexBufferIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindIndexBufferIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindVertexBufferIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindVertexBufferIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindVertexBufferIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindVertexBufferIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferAddress"], to_hex_variable_width(decoded_value.bufferAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindVertexBufferIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindVertexBufferIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSetStateFlagsIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSetStateFlagsIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSetStateFlagsIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetStateFlagsIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["data"], decoded_value.data, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSetStateFlagsIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSetStateFlagsIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsStreamNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsStreamNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsStreamNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsStreamNV& meta_struct = *data;

        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsStreamNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsStreamNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutTokenNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutTokenNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutTokenNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutTokenNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["tokenType"], decoded_value.tokenType, options);
        FieldToJsonResolve(jdata["stream"], decoded_value.stream, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["vertexBindingUnit"], decoded_value.vertexBindingUnit, options);
        jdata["vertexDynamicStride"] = static_cast<bool>(decoded_value.vertexDynamicStride);
        HandleToJson(jdata["pushconstantPipelineLayout"], meta_struct.pushconstantPipelineLayout, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["pushconstantShaderStageFlags"], decoded_value.pushconstantShaderStageFlags, options);
        FieldToJsonResolve(jdata["pushconstantOffset"], decoded_value.pushconstantOffset, options);
        FieldToJsonResolve(jdata["pushconstantSize"], decoded_value.pushconstantSize, options);
        FieldToJson(VkIndirectStateFlagsNV_t(),jdata["indirectStateFlags"], decoded_value.indirectStateFlags, options);
        FieldToJsonResolve(jdata["indexTypeCount"], decoded_value.indexTypeCount, options);
        FieldToJsonResolve(jdata["pIndexTypes"], meta_struct.pIndexTypes, options);
        FieldToJsonResolve(jdata["pIndexTypeValues"], meta_struct.pIndexTypeValues, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutTokenNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutTokenNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkIndirectCommandsLayoutUsageFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        FieldToJsonResolve(jdata["tokenCount"], decoded_value.tokenCount, options);
        FieldToJsonResolve(jdata["pTokens"], meta_struct.pTokens, options);
        FieldToJsonResolve(jdata["streamCount"], decoded_value.streamCount, options);
        FieldToJsonResolve(jdata["pStreamStrides"], meta_struct.pStreamStrides, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        HandleToJson(jdata["indirectCommandsLayout"], meta_struct.indirectCommandsLayout, options);
        FieldToJsonResolve(jdata["streamCount"], decoded_value.streamCount, options);
        FieldToJsonResolve(jdata["pStreams"], meta_struct.pStreams, options);
        FieldToJsonResolve(jdata["sequencesCount"], decoded_value.sequencesCount, options);
        HandleToJson(jdata["preprocessBuffer"], meta_struct.preprocessBuffer, options);
        FieldToJsonResolve(jdata["preprocessOffset"], decoded_value.preprocessOffset, options);
        FieldToJsonResolve(jdata["preprocessSize"], decoded_value.preprocessSize, options);
        HandleToJson(jdata["sequencesCountBuffer"], meta_struct.sequencesCountBuffer, options);
        FieldToJsonResolve(jdata["sequencesCountOffset"], decoded_value.sequencesCountOffset, options);
        HandleToJson(jdata["sequencesIndexBuffer"], meta_struct.sequencesIndexBuffer, options);
        FieldToJsonResolve(jdata["sequencesIndexOffset"], decoded_value.sequencesIndexOffset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsMemoryRequirementsInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        HandleToJson(jdata["indirectCommandsLayout"], meta_struct.indirectCommandsLayout, options);
        FieldToJsonResolve(jdata["maxSequencesCount"], decoded_value.maxSequencesCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInheritedViewportScissorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["inheritedViewportScissor2D"] = static_cast<bool>(decoded_value.inheritedViewportScissor2D);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferInheritanceViewportScissorInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceViewportScissorInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["viewportScissor2D"] = static_cast<bool>(decoded_value.viewportScissor2D);
        FieldToJsonResolve(jdata["viewportDepthCount"], decoded_value.viewportDepthCount, options);
        FieldToJsonResolve(jdata["pViewportDepths"], meta_struct.pViewportDepths, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferInheritanceViewportScissorInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["texelBufferAlignment"] = static_cast<bool>(decoded_value.texelBufferAlignment);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassTransformBeginInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassTransformBeginInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassTransformBeginInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassTransformBeginInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["transform"], decoded_value.transform, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassTransformBeginInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassTransformBeginInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCommandBufferInheritanceRenderPassTransformInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["transform"], decoded_value.transform, options);
        FieldToJsonResolve(jdata["renderArea"], meta_struct.renderArea, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthBiasControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["depthBiasControl"] = static_cast<bool>(decoded_value.depthBiasControl);
        jdata["leastRepresentableValueForceUnormRepresentation"] = static_cast<bool>(decoded_value.leastRepresentableValueForceUnormRepresentation);
        jdata["floatRepresentation"] = static_cast<bool>(decoded_value.floatRepresentation);
        jdata["depthBiasExact"] = static_cast<bool>(decoded_value.depthBiasExact);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDepthBiasInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDepthBiasInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDepthBiasInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthBiasInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["depthBiasConstantFactor"], decoded_value.depthBiasConstantFactor, options);
        FieldToJsonResolve(jdata["depthBiasClamp"], decoded_value.depthBiasClamp, options);
        FieldToJsonResolve(jdata["depthBiasSlopeFactor"], decoded_value.depthBiasSlopeFactor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDepthBiasInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDepthBiasInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDepthBiasRepresentationInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDepthBiasRepresentationInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDepthBiasRepresentationInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthBiasRepresentationInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["depthBiasRepresentation"], decoded_value.depthBiasRepresentation, options);
        jdata["depthBiasExact"] = static_cast<bool>(decoded_value.depthBiasExact);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDepthBiasRepresentationInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDepthBiasRepresentationInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceMemoryReport"] = static_cast<bool>(decoded_value.deviceMemoryReport);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceMemoryReportCallbackDataEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryReportCallbackDataEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceMemoryReportCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceMemoryReportCallbackDataEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceMemoryReportFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["memoryObjectId"], decoded_value.memoryObjectId, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["objectType"], decoded_value.objectType, options);
        FieldToJsonResolve(jdata["objectHandle"], decoded_value.objectHandle, options);
        FieldToJsonResolve(jdata["heapIndex"], decoded_value.heapIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceMemoryReportCallbackDataEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceMemoryReportCallbackDataEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceDeviceMemoryReportCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceMemoryReportFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pfnUserCallback"], to_hex_variable_width(meta_struct.pfnUserCallback), options);
        FieldToJsonResolve(jdata["pUserData"], to_hex_variable_width(meta_struct.pUserData), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerCustomBorderColorCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCustomBorderColorCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCustomBorderColorCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCustomBorderColorCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["customBorderColor"], meta_struct.customBorderColor, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCustomBorderColorCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerCustomBorderColorCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCustomBorderColorPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxCustomBorderColorSamplers"], decoded_value.maxCustomBorderColorSamplers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCustomBorderColorFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["customBorderColors"] = static_cast<bool>(decoded_value.customBorderColors);
        jdata["customBorderColorWithoutFormat"] = static_cast<bool>(decoded_value.customBorderColorWithoutFormat);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentBarrierFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentBarrierFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentBarrier"] = static_cast<bool>(decoded_value.presentBarrier);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentBarrierFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentBarrierNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentBarrierNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSurfaceCapabilitiesPresentBarrierNV& decoded_value = *data->decoded_value;
        const Decoded_VkSurfaceCapabilitiesPresentBarrierNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentBarrierSupported"] = static_cast<bool>(decoded_value.presentBarrierSupported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSurfaceCapabilitiesPresentBarrierNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSurfaceCapabilitiesPresentBarrierNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainPresentBarrierCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentBarrierCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainPresentBarrierCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainPresentBarrierCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentBarrierEnable"] = static_cast<bool>(decoded_value.presentBarrierEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainPresentBarrierCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainPresentBarrierCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDiagnosticsConfigFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["diagnosticsConfig"] = static_cast<bool>(decoded_value.diagnosticsConfig);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceDiagnosticsConfigCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceDiagnosticsConfigCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceDiagnosticsConfigFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceDiagnosticsConfigCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTileShadingFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["tileShading"] = static_cast<bool>(decoded_value.tileShading);
        jdata["tileShadingFragmentStage"] = static_cast<bool>(decoded_value.tileShadingFragmentStage);
        jdata["tileShadingColorAttachments"] = static_cast<bool>(decoded_value.tileShadingColorAttachments);
        jdata["tileShadingDepthAttachments"] = static_cast<bool>(decoded_value.tileShadingDepthAttachments);
        jdata["tileShadingStencilAttachments"] = static_cast<bool>(decoded_value.tileShadingStencilAttachments);
        jdata["tileShadingInputAttachments"] = static_cast<bool>(decoded_value.tileShadingInputAttachments);
        jdata["tileShadingSampledAttachments"] = static_cast<bool>(decoded_value.tileShadingSampledAttachments);
        jdata["tileShadingPerTileDraw"] = static_cast<bool>(decoded_value.tileShadingPerTileDraw);
        jdata["tileShadingPerTileDispatch"] = static_cast<bool>(decoded_value.tileShadingPerTileDispatch);
        jdata["tileShadingDispatchTile"] = static_cast<bool>(decoded_value.tileShadingDispatchTile);
        jdata["tileShadingApron"] = static_cast<bool>(decoded_value.tileShadingApron);
        jdata["tileShadingAnisotropicApron"] = static_cast<bool>(decoded_value.tileShadingAnisotropicApron);
        jdata["tileShadingAtomicOps"] = static_cast<bool>(decoded_value.tileShadingAtomicOps);
        jdata["tileShadingImageProcessing"] = static_cast<bool>(decoded_value.tileShadingImageProcessing);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTileShadingPropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxApronSize"], decoded_value.maxApronSize, options);
        jdata["preferNonCoherent"] = static_cast<bool>(decoded_value.preferNonCoherent);
        FieldToJsonResolve(jdata["tileGranularity"], meta_struct.tileGranularity, options);
        FieldToJsonResolve(jdata["maxTileShadingRate"], meta_struct.maxTileShadingRate, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassTileShadingCreateInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassTileShadingCreateInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassTileShadingCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassTileShadingCreateInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkTileShadingRenderPassFlagsQCOM_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["tileApronSize"], meta_struct.tileApronSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassTileShadingCreateInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassTileShadingCreateInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerTileBeginInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerTileBeginInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerTileBeginInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPerTileBeginInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerTileBeginInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerTileBeginInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPerTileEndInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPerTileEndInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPerTileEndInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPerTileEndInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPerTileEndInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPerTileEndInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDispatchTileInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDispatchTileInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDispatchTileInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkDispatchTileInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDispatchTileInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDispatchTileInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkQueryLowLatencySupportNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkQueryLowLatencySupportNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkQueryLowLatencySupportNV& decoded_value = *data->decoded_value;
        const Decoded_VkQueryLowLatencySupportNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pQueriedLowLatencyData"], meta_struct.pQueriedLowLatencyData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkQueryLowLatencySupportNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkQueryLowLatencySupportNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["graphicsPipelineLibrary"] = static_cast<bool>(decoded_value.graphicsPipelineLibrary);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["graphicsPipelineLibraryFastLinking"] = static_cast<bool>(decoded_value.graphicsPipelineLibraryFastLinking);
        jdata["graphicsPipelineLibraryIndependentInterpolationDecoration"] = static_cast<bool>(decoded_value.graphicsPipelineLibraryIndependentInterpolationDecoration);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGraphicsPipelineLibraryCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGraphicsPipelineLibraryCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkGraphicsPipelineLibraryFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGraphicsPipelineLibraryCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderEarlyAndLateFragmentTests"] = static_cast<bool>(decoded_value.shaderEarlyAndLateFragmentTests);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentShadingRateEnums"] = static_cast<bool>(decoded_value.fragmentShadingRateEnums);
        jdata["supersampleFragmentShadingRates"] = static_cast<bool>(decoded_value.supersampleFragmentShadingRates);
        jdata["noInvocationFragmentShadingRates"] = static_cast<bool>(decoded_value.noInvocationFragmentShadingRates);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxFragmentShadingRateInvocationCount"], decoded_value.maxFragmentShadingRateInvocationCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineFragmentShadingRateEnumStateCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shadingRateType"], decoded_value.shadingRateType, options);
        FieldToJsonResolve(jdata["shadingRate"], decoded_value.shadingRate, options);
        FieldToJsonResolve(jdata["combinerOps"], &meta_struct.combinerOps, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryMotionTrianglesDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vertexData"], meta_struct.vertexData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureMotionInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMotionInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMotionInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMotionInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxInstances"], decoded_value.maxInstances, options);
        FieldToJson(VkAccelerationStructureMotionInfoFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMotionInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureMotionInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureMatrixMotionInstanceNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMatrixMotionInstanceNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureMatrixMotionInstanceNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureMatrixMotionInstanceNV& meta_struct = *data;

        FieldToJsonResolve(jdata["transformT0"], meta_struct.transformT0, options);
        FieldToJsonResolve(jdata["transformT1"], meta_struct.transformT1, options);
        FieldToJsonResolve(jdata["instanceCustomIndex"], decoded_value.instanceCustomIndex, options);
        FieldToJsonResolve(jdata["mask"], decoded_value.mask, options);
        FieldToJsonResolve(jdata["instanceShaderBindingTableRecordOffset"], decoded_value.instanceShaderBindingTableRecordOffset, options);
        FieldToJson(VkGeometryInstanceFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["accelerationStructureReference"], decoded_value.accelerationStructureReference, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureMatrixMotionInstanceNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureMatrixMotionInstanceNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSRTDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSRTDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSRTDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkSRTDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sx"], decoded_value.sx, options);
        FieldToJsonResolve(jdata["a"], decoded_value.a, options);
        FieldToJsonResolve(jdata["b"], decoded_value.b, options);
        FieldToJsonResolve(jdata["pvx"], decoded_value.pvx, options);
        FieldToJsonResolve(jdata["sy"], decoded_value.sy, options);
        FieldToJsonResolve(jdata["c"], decoded_value.c, options);
        FieldToJsonResolve(jdata["pvy"], decoded_value.pvy, options);
        FieldToJsonResolve(jdata["sz"], decoded_value.sz, options);
        FieldToJsonResolve(jdata["pvz"], decoded_value.pvz, options);
        FieldToJsonResolve(jdata["qx"], decoded_value.qx, options);
        FieldToJsonResolve(jdata["qy"], decoded_value.qy, options);
        FieldToJsonResolve(jdata["qz"], decoded_value.qz, options);
        FieldToJsonResolve(jdata["qw"], decoded_value.qw, options);
        FieldToJsonResolve(jdata["tx"], decoded_value.tx, options);
        FieldToJsonResolve(jdata["ty"], decoded_value.ty, options);
        FieldToJsonResolve(jdata["tz"], decoded_value.tz, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSRTDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSRTDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureSRTMotionInstanceNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureSRTMotionInstanceNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureSRTMotionInstanceNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureSRTMotionInstanceNV& meta_struct = *data;

        FieldToJsonResolve(jdata["transformT0"], meta_struct.transformT0, options);
        FieldToJsonResolve(jdata["transformT1"], meta_struct.transformT1, options);
        FieldToJsonResolve(jdata["instanceCustomIndex"], decoded_value.instanceCustomIndex, options);
        FieldToJsonResolve(jdata["mask"], decoded_value.mask, options);
        FieldToJsonResolve(jdata["instanceShaderBindingTableRecordOffset"], decoded_value.instanceShaderBindingTableRecordOffset, options);
        FieldToJson(VkGeometryInstanceFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["accelerationStructureReference"], decoded_value.accelerationStructureReference, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureSRTMotionInstanceNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureSRTMotionInstanceNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingMotionBlur"] = static_cast<bool>(decoded_value.rayTracingMotionBlur);
        jdata["rayTracingMotionBlurPipelineTraceRaysIndirect"] = static_cast<bool>(decoded_value.rayTracingMotionBlurPipelineTraceRaysIndirect);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["ycbcr2plane444Formats"] = static_cast<bool>(decoded_value.ycbcr2plane444Formats);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentDensityMapDeferred"] = static_cast<bool>(decoded_value.fragmentDensityMapDeferred);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["subsampledLoads"] = static_cast<bool>(decoded_value.subsampledLoads);
        jdata["subsampledCoarseReconstructionEarlyAccess"] = static_cast<bool>(decoded_value.subsampledCoarseReconstructionEarlyAccess);
        FieldToJsonResolve(jdata["maxSubsampledArrayLayers"], decoded_value.maxSubsampledArrayLayers, options);
        FieldToJsonResolve(jdata["maxDescriptorSetSubsampledSamplers"], decoded_value.maxDescriptorSetSubsampledSamplers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyCommandTransformInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyCommandTransformInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyCommandTransformInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkCopyCommandTransformInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["transform"], decoded_value.transform, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyCommandTransformInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyCommandTransformInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageCompressionControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imageCompressionControl"] = static_cast<bool>(decoded_value.imageCompressionControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageCompressionControlEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageCompressionControlEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageCompressionControlEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageCompressionControlEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageCompressionFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["compressionControlPlaneCount"], decoded_value.compressionControlPlaneCount, options);
        FieldToJsonResolve(jdata["pFixedRateFlags"], meta_struct.pFixedRateFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageCompressionControlEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageCompressionControlEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageCompressionPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageCompressionPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageCompressionPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageCompressionPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkImageCompressionFlagsEXT_t(),jdata["imageCompressionFlags"], decoded_value.imageCompressionFlags, options);
        FieldToJson(VkImageCompressionFixedRateFlagsEXT_t(),jdata["imageCompressionFixedRateFlags"], decoded_value.imageCompressionFixedRateFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageCompressionPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageCompressionPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["attachmentFeedbackLoopLayout"] = static_cast<bool>(decoded_value.attachmentFeedbackLoopLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevice4444FormatsFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevice4444FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["formatA4R4G4B4"] = static_cast<bool>(decoded_value.formatA4R4G4B4);
        jdata["formatA4B4G4R4"] = static_cast<bool>(decoded_value.formatA4B4G4R4);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevice4444FormatsFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFaultFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFaultFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFaultFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFaultFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceFault"] = static_cast<bool>(decoded_value.deviceFault);
        jdata["deviceFaultVendorBinary"] = static_cast<bool>(decoded_value.deviceFaultVendorBinary);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFaultFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFaultFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceFaultCountsEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultCountsEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultCountsEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultCountsEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["addressInfoCount"], decoded_value.addressInfoCount, options);
        FieldToJsonResolve(jdata["vendorInfoCount"], decoded_value.vendorInfoCount, options);
        FieldToJsonResolve(jdata["vendorBinarySize"], decoded_value.vendorBinarySize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultCountsEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceFaultCountsEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceFaultAddressInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultAddressInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultAddressInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultAddressInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["addressType"], decoded_value.addressType, options);
        FieldToJsonResolve(jdata["reportedAddress"], to_hex_variable_width(decoded_value.reportedAddress), options);
        FieldToJsonResolve(jdata["addressPrecision"], decoded_value.addressPrecision, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultAddressInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceFaultAddressInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceFaultVendorInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultVendorInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultVendorInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultVendorInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["vendorFaultCode"], decoded_value.vendorFaultCode, options);
        FieldToJsonResolve(jdata["vendorFaultData"], decoded_value.vendorFaultData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultVendorInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceFaultVendorInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceFaultInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["pAddressInfos"], meta_struct.pAddressInfos, options);
        FieldToJsonResolve(jdata["pVendorInfos"], meta_struct.pVendorInfos, options);
        FieldToJsonResolve(jdata["pVendorBinaryData"], meta_struct.pVendorBinaryData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceFaultInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceFaultVendorBinaryHeaderVersionOneEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["headerSize"], decoded_value.headerSize, options);
        FieldToJsonResolve(jdata["headerVersion"], decoded_value.headerVersion, options);
        FieldToJsonResolve(jdata["vendorID"], decoded_value.vendorID, options);
        FieldToJsonResolve(jdata["deviceID"], decoded_value.deviceID, options);
        FieldToJsonResolve(jdata["driverVersion"], decoded_value.driverVersion, options);
        FieldToJsonResolve(jdata["pipelineCacheUUID"], uuid_to_string(sizeof(decoded_value.pipelineCacheUUID), decoded_value.pipelineCacheUUID), options);
        FieldToJsonResolve(jdata["applicationNameOffset"], decoded_value.applicationNameOffset, options);
        FieldToJsonResolve(jdata["applicationVersion"], decoded_value.applicationVersion, options);
        FieldToJsonResolve(jdata["engineNameOffset"], decoded_value.engineNameOffset, options);
        FieldToJsonResolve(jdata["engineVersion"], decoded_value.engineVersion, options);
        FieldToJsonResolve(jdata["apiVersion"], decoded_value.apiVersion, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rasterizationOrderColorAttachmentAccess"] = static_cast<bool>(decoded_value.rasterizationOrderColorAttachmentAccess);
        jdata["rasterizationOrderDepthAttachmentAccess"] = static_cast<bool>(decoded_value.rasterizationOrderDepthAttachmentAccess);
        jdata["rasterizationOrderStencilAttachmentAccess"] = static_cast<bool>(decoded_value.rasterizationOrderStencilAttachmentAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["formatRgba10x6WithoutYCbCrSampler"] = static_cast<bool>(decoded_value.formatRgba10x6WithoutYCbCrSampler);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDirectFBSurfaceCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDirectFBSurfaceCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDirectFBSurfaceCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDirectFBSurfaceCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDirectFBSurfaceCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["dfb"], meta_struct.dfb, options);
        FieldToJsonResolve(jdata["surface"], meta_struct.surface, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDirectFBSurfaceCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDirectFBSurfaceCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["mutableDescriptorType"] = static_cast<bool>(decoded_value.mutableDescriptorType);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMutableDescriptorTypeListEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMutableDescriptorTypeListEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMutableDescriptorTypeListEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMutableDescriptorTypeListEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["descriptorTypeCount"], decoded_value.descriptorTypeCount, options);
        FieldToJsonResolve(jdata["pDescriptorTypes"], meta_struct.pDescriptorTypes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMutableDescriptorTypeListEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMutableDescriptorTypeListEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMutableDescriptorTypeCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMutableDescriptorTypeCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMutableDescriptorTypeCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMutableDescriptorTypeCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["mutableDescriptorTypeListCount"], decoded_value.mutableDescriptorTypeListCount, options);
        FieldToJsonResolve(jdata["pMutableDescriptorTypeLists"], meta_struct.pMutableDescriptorTypeLists, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMutableDescriptorTypeCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMutableDescriptorTypeCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["vertexInputDynamicState"] = static_cast<bool>(decoded_value.vertexInputDynamicState);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVertexInputBindingDescription2EXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDescription2EXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputBindingDescription2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputBindingDescription2EXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["inputRate"], decoded_value.inputRate, options);
        FieldToJsonResolve(jdata["divisor"], decoded_value.divisor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputBindingDescription2EXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVertexInputBindingDescription2EXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkVertexInputAttributeDescription2EXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputAttributeDescription2EXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkVertexInputAttributeDescription2EXT& decoded_value = *data->decoded_value;
        const Decoded_VkVertexInputAttributeDescription2EXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["location"], decoded_value.location, options);
        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkVertexInputAttributeDescription2EXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkVertexInputAttributeDescription2EXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDrmPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDrmPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDrmPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDrmPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hasPrimary"] = static_cast<bool>(decoded_value.hasPrimary);
        jdata["hasRender"] = static_cast<bool>(decoded_value.hasRender);
        FieldToJsonResolve(jdata["primaryMajor"], decoded_value.primaryMajor, options);
        FieldToJsonResolve(jdata["primaryMinor"], decoded_value.primaryMinor, options);
        FieldToJsonResolve(jdata["renderMajor"], decoded_value.renderMajor, options);
        FieldToJsonResolve(jdata["renderMinor"], decoded_value.renderMinor, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDrmPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDrmPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAddressBindingReportFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["reportAddressBinding"] = static_cast<bool>(decoded_value.reportAddressBinding);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceAddressBindingCallbackDataEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceAddressBindingCallbackDataEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceAddressBindingCallbackDataEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceAddressBindingCallbackDataEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDeviceAddressBindingFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["baseAddress"], to_hex_variable_width(decoded_value.baseAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["bindingType"], decoded_value.bindingType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceAddressBindingCallbackDataEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceAddressBindingCallbackDataEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClipControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["depthClipControl"] = static_cast<bool>(decoded_value.depthClipControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportDepthClipControlCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["negativeOneToOne"] = static_cast<bool>(decoded_value.negativeOneToOne);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["primitiveTopologyListRestart"] = static_cast<bool>(decoded_value.primitiveTopologyListRestart);
        jdata["primitiveTopologyPatchListRestart"] = static_cast<bool>(decoded_value.primitiveTopologyPatchListRestart);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryZirconHandleInfoFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], decoded_value.handle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryZirconHandleInfoFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryZirconHandlePropertiesFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryZirconHandlePropertiesFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryZirconHandlePropertiesFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryZirconHandlePropertiesFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetZirconHandleInfoFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetZirconHandleInfoFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportSemaphoreZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJson(VkSemaphoreImportFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["zirconHandle"], decoded_value.zirconHandle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSemaphoreGetZirconHandleInfoFUCHSIA& decoded_value = *data->decoded_value;
        const Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["semaphore"], meta_struct.semaphore, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["invocationMask"] = static_cast<bool>(decoded_value.invocationMask);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetRemoteAddressInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetRemoteAddressInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetRemoteAddressInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetRemoteAddressInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetRemoteAddressInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetRemoteAddressInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["externalMemoryRDMA"] = static_cast<bool>(decoded_value.externalMemoryRDMA);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFrameBoundaryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["frameBoundary"] = static_cast<bool>(decoded_value.frameBoundary);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkFrameBoundaryEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkFrameBoundaryEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkFrameBoundaryEXT& decoded_value = *data->decoded_value;
        const Decoded_VkFrameBoundaryEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkFrameBoundaryFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["frameID"], decoded_value.frameID, options);
        FieldToJsonResolve(jdata["imageCount"], decoded_value.imageCount, options);
        HandleToJson(jdata["pImages"], &meta_struct.pImages, options);
        FieldToJsonResolve(jdata["bufferCount"], decoded_value.bufferCount, options);
        HandleToJson(jdata["pBuffers"], &meta_struct.pBuffers, options);
        FieldToJsonResolve(jdata["tagName"], decoded_value.tagName, options);
        FieldToJsonResolve(jdata["tagSize"], decoded_value.tagSize, options);
        FieldToJsonResolve(jdata["pTag"], meta_struct.pTag, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkFrameBoundaryEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkFrameBoundaryEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multisampledRenderToSingleSampled"] = static_cast<bool>(decoded_value.multisampledRenderToSingleSampled);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSubpassResolvePerformanceQueryEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSubpassResolvePerformanceQueryEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSubpassResolvePerformanceQueryEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSubpassResolvePerformanceQueryEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["optimal"] = static_cast<bool>(decoded_value.optimal);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSubpassResolvePerformanceQueryEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSubpassResolvePerformanceQueryEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultisampledRenderToSingleSampledInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultisampledRenderToSingleSampledInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultisampledRenderToSingleSampledInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultisampledRenderToSingleSampledInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multisampledRenderToSingleSampledEnable"] = static_cast<bool>(decoded_value.multisampledRenderToSingleSampledEnable);
        FieldToJsonResolve(jdata["rasterizationSamples"], decoded_value.rasterizationSamples, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultisampledRenderToSingleSampledInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultisampledRenderToSingleSampledInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["extendedDynamicState2"] = static_cast<bool>(decoded_value.extendedDynamicState2);
        jdata["extendedDynamicState2LogicOp"] = static_cast<bool>(decoded_value.extendedDynamicState2LogicOp);
        jdata["extendedDynamicState2PatchControlPoints"] = static_cast<bool>(decoded_value.extendedDynamicState2PatchControlPoints);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkScreenSurfaceCreateInfoQNX>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkScreenSurfaceCreateInfoQNX* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkScreenSurfaceCreateInfoQNX& decoded_value = *data->decoded_value;
        const Decoded_VkScreenSurfaceCreateInfoQNX& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkScreenSurfaceCreateFlagsQNX_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["context"], meta_struct.context, options);
        FieldToJsonResolve(jdata["window"], meta_struct.window, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkScreenSurfaceCreateInfoQNX* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkScreenSurfaceCreateInfoQNX>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceColorWriteEnableFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["colorWriteEnable"] = static_cast<bool>(decoded_value.colorWriteEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineColorWriteCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorWriteCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineColorWriteCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineColorWriteCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["attachmentCount"], decoded_value.attachmentCount, options);
        FieldToJsonResolve(jdata["pColorWriteEnables"], meta_struct.pColorWriteEnables, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineColorWriteCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineColorWriteCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["primitivesGeneratedQuery"] = static_cast<bool>(decoded_value.primitivesGeneratedQuery);
        jdata["primitivesGeneratedQueryWithRasterizerDiscard"] = static_cast<bool>(decoded_value.primitivesGeneratedQueryWithRasterizerDiscard);
        jdata["primitivesGeneratedQueryWithNonZeroStreams"] = static_cast<bool>(decoded_value.primitivesGeneratedQueryWithNonZeroStreams);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageViewMinLodFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["minLod"] = static_cast<bool>(decoded_value.minLod);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewMinLodCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewMinLodCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewMinLodCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewMinLodCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["minLod"], decoded_value.minLod, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewMinLodCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewMinLodCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiDrawFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multiDraw"] = static_cast<bool>(decoded_value.multiDraw);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiDrawPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxMultiDrawCount"], decoded_value.maxMultiDrawCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultiDrawInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultiDrawInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultiDrawInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultiDrawInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["firstVertex"], decoded_value.firstVertex, options);
        FieldToJsonResolve(jdata["vertexCount"], decoded_value.vertexCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultiDrawInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultiDrawInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultiDrawIndexedInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultiDrawIndexedInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultiDrawIndexedInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMultiDrawIndexedInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["firstIndex"], decoded_value.firstIndex, options);
        FieldToJsonResolve(jdata["indexCount"], decoded_value.indexCount, options);
        FieldToJsonResolve(jdata["vertexOffset"], decoded_value.vertexOffset, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultiDrawIndexedInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultiDrawIndexedInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["image2DViewOf3D"] = static_cast<bool>(decoded_value.image2DViewOf3D);
        jdata["sampler2DViewOf3D"] = static_cast<bool>(decoded_value.sampler2DViewOf3D);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTileImageFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderTileImageColorReadAccess"] = static_cast<bool>(decoded_value.shaderTileImageColorReadAccess);
        jdata["shaderTileImageDepthReadAccess"] = static_cast<bool>(decoded_value.shaderTileImageDepthReadAccess);
        jdata["shaderTileImageStencilReadAccess"] = static_cast<bool>(decoded_value.shaderTileImageStencilReadAccess);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderTileImagePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderTileImageCoherentReadAccelerated"] = static_cast<bool>(decoded_value.shaderTileImageCoherentReadAccelerated);
        jdata["shaderTileImageReadSampleFromPixelRateInvocation"] = static_cast<bool>(decoded_value.shaderTileImageReadSampleFromPixelRateInvocation);
        jdata["shaderTileImageReadFromHelperInvocation"] = static_cast<bool>(decoded_value.shaderTileImageReadFromHelperInvocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapUsageEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapUsageEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapUsageEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapUsageEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["count"], decoded_value.count, options);
        FieldToJsonResolve(jdata["subdivisionLevel"], decoded_value.subdivisionLevel, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapUsageEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapUsageEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapBuildInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapBuildInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapBuildInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapBuildInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJson(VkBuildMicromapFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        HandleToJson(jdata["dstMicromap"], meta_struct.dstMicromap, options);
        FieldToJsonResolve(jdata["usageCountsCount"], decoded_value.usageCountsCount, options);
        FieldToJsonResolve(jdata["pUsageCounts"], meta_struct.pUsageCounts, options);
        FieldToJsonResolve(jdata["ppUsageCounts"], meta_struct.ppUsageCounts, options);
        FieldToJsonResolve(jdata["data"], meta_struct.data, options);
        FieldToJsonResolve(jdata["scratchData"], meta_struct.scratchData, options);
        FieldToJsonResolve(jdata["triangleArray"], meta_struct.triangleArray, options);
        FieldToJsonResolve(jdata["triangleArrayStride"], decoded_value.triangleArrayStride, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapBuildInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapBuildInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkMicromapCreateFlagsEXT_t(),jdata["createFlags"], decoded_value.createFlags, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpacityMicromapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["micromap"] = static_cast<bool>(decoded_value.micromap);
        jdata["micromapCaptureReplay"] = static_cast<bool>(decoded_value.micromapCaptureReplay);
        jdata["micromapHostCommands"] = static_cast<bool>(decoded_value.micromapHostCommands);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpacityMicromapPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxOpacity2StateSubdivisionLevel"], decoded_value.maxOpacity2StateSubdivisionLevel, options);
        FieldToJsonResolve(jdata["maxOpacity4StateSubdivisionLevel"], decoded_value.maxOpacity4StateSubdivisionLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapVersionInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapVersionInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapVersionInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapVersionInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pVersionData"], meta_struct.pVersionData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapVersionInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapVersionInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyMicromapToMemoryInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyMicromapToMemoryInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyMicromapToMemoryInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMicromapToMemoryInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["src"], meta_struct.src, options);
        FieldToJsonResolve(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyMicromapToMemoryInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyMicromapToMemoryInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyMemoryToMicromapInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyMemoryToMicromapInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyMemoryToMicromapInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMemoryToMicromapInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["src"], meta_struct.src, options);
        HandleToJson(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyMemoryToMicromapInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyMemoryToMicromapInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyMicromapInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyMicromapInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyMicromapInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMicromapInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["src"], meta_struct.src, options);
        HandleToJson(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyMicromapInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyMicromapInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapBuildSizesInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapBuildSizesInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapBuildSizesInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapBuildSizesInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["micromapSize"], decoded_value.micromapSize, options);
        FieldToJsonResolve(jdata["buildScratchSize"], decoded_value.buildScratchSize, options);
        jdata["discardable"] = static_cast<bool>(decoded_value.discardable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapBuildSizesInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapBuildSizesInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureTrianglesOpacityMicromapEXT& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        FieldToJsonResolve(jdata["indexBuffer"], meta_struct.indexBuffer, options);
        FieldToJsonResolve(jdata["indexStride"], decoded_value.indexStride, options);
        FieldToJsonResolve(jdata["baseTriangle"], decoded_value.baseTriangle, options);
        FieldToJsonResolve(jdata["usageCountsCount"], decoded_value.usageCountsCount, options);
        FieldToJsonResolve(jdata["pUsageCounts"], meta_struct.pUsageCounts, options);
        FieldToJsonResolve(jdata["ppUsageCounts"], meta_struct.ppUsageCounts, options);
        HandleToJson(jdata["micromap"], meta_struct.micromap, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMicromapTriangleEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMicromapTriangleEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMicromapTriangleEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMicromapTriangleEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["dataOffset"], decoded_value.dataOffset, options);
        FieldToJsonResolve(jdata["subdivisionLevel"], decoded_value.subdivisionLevel, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMicromapTriangleEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMicromapTriangleEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDisplacementMicromapFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["displacementMicromap"] = static_cast<bool>(decoded_value.displacementMicromap);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDisplacementMicromapPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxDisplacementMicromapSubdivisionLevel"], decoded_value.maxDisplacementMicromapSubdivisionLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureTrianglesDisplacementMicromapNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["displacementBiasAndScaleFormat"], decoded_value.displacementBiasAndScaleFormat, options);
        FieldToJsonResolve(jdata["displacementVectorFormat"], decoded_value.displacementVectorFormat, options);
        FieldToJsonResolve(jdata["displacementBiasAndScaleBuffer"], meta_struct.displacementBiasAndScaleBuffer, options);
        FieldToJsonResolve(jdata["displacementBiasAndScaleStride"], decoded_value.displacementBiasAndScaleStride, options);
        FieldToJsonResolve(jdata["displacementVectorBuffer"], meta_struct.displacementVectorBuffer, options);
        FieldToJsonResolve(jdata["displacementVectorStride"], decoded_value.displacementVectorStride, options);
        FieldToJsonResolve(jdata["displacedMicromapPrimitiveFlags"], meta_struct.displacedMicromapPrimitiveFlags, options);
        FieldToJsonResolve(jdata["displacedMicromapPrimitiveFlagsStride"], decoded_value.displacedMicromapPrimitiveFlagsStride, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        FieldToJsonResolve(jdata["indexBuffer"], meta_struct.indexBuffer, options);
        FieldToJsonResolve(jdata["indexStride"], decoded_value.indexStride, options);
        FieldToJsonResolve(jdata["baseTriangle"], decoded_value.baseTriangle, options);
        FieldToJsonResolve(jdata["usageCountsCount"], decoded_value.usageCountsCount, options);
        FieldToJsonResolve(jdata["pUsageCounts"], meta_struct.pUsageCounts, options);
        FieldToJsonResolve(jdata["ppUsageCounts"], meta_struct.ppUsageCounts, options);
        HandleToJson(jdata["micromap"], meta_struct.micromap, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["clustercullingShader"] = static_cast<bool>(decoded_value.clustercullingShader);
        jdata["multiviewClusterCullingShader"] = static_cast<bool>(decoded_value.multiviewClusterCullingShader);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxWorkGroupCount"], &meta_struct.maxWorkGroupCount, options);
        FieldToJsonResolve(jdata["maxWorkGroupSize"], &meta_struct.maxWorkGroupSize, options);
        FieldToJsonResolve(jdata["maxOutputClusterCount"], decoded_value.maxOutputClusterCount, options);
        FieldToJsonResolve(jdata["indirectBufferOffsetAlignment"], decoded_value.indirectBufferOffsetAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["clusterShadingRate"] = static_cast<bool>(decoded_value.clusterShadingRate);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["borderColorSwizzle"] = static_cast<bool>(decoded_value.borderColorSwizzle);
        jdata["borderColorSwizzleFromImage"] = static_cast<bool>(decoded_value.borderColorSwizzleFromImage);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerBorderColorComponentMappingCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["components"], meta_struct.components, options);
        jdata["srgb"] = static_cast<bool>(decoded_value.srgb);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pageableDeviceLocalMemory"] = static_cast<bool>(decoded_value.pageableDeviceLocalMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCorePropertiesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCorePropertiesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCorePropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCorePropertiesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pixelRate"], decoded_value.pixelRate, options);
        FieldToJsonResolve(jdata["texelRate"], decoded_value.texelRate, options);
        FieldToJsonResolve(jdata["fmaRate"], decoded_value.fmaRate, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCorePropertiesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCorePropertiesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDeviceQueueShaderCoreControlCreateInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderCoreCount"], decoded_value.shaderCoreCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSchedulingControlsFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["schedulingControls"] = static_cast<bool>(decoded_value.schedulingControls);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSchedulingControlsPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPhysicalDeviceSchedulingControlsFlagsARM_t(),jdata["schedulingControlsFlags"], decoded_value.schedulingControlsFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imageSlicedViewOf3D"] = static_cast<bool>(decoded_value.imageSlicedViewOf3D);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewSlicedCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewSlicedCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewSlicedCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewSlicedCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["sliceOffset"], decoded_value.sliceOffset, options);
        FieldToJsonResolve(jdata["sliceCount"], decoded_value.sliceCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewSlicedCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewSlicedCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["descriptorSetHostMapping"] = static_cast<bool>(decoded_value.descriptorSetHostMapping);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetBindingReferenceVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetBindingReferenceVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetBindingReferenceVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetBindingReferenceVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["descriptorSetLayout"], meta_struct.descriptorSetLayout, options);
        FieldToJsonResolve(jdata["binding"], decoded_value.binding, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetBindingReferenceVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetBindingReferenceVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDescriptorSetLayoutHostMappingInfoVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["descriptorOffset"], decoded_value.descriptorOffset, options);
        FieldToJsonResolve(jdata["descriptorSize"], decoded_value.descriptorSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["nonSeamlessCubeMap"] = static_cast<bool>(decoded_value.nonSeamlessCubeMap);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRenderPassStripedFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["renderPassStriped"] = static_cast<bool>(decoded_value.renderPassStriped);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRenderPassStripedPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["renderPassStripeGranularity"], meta_struct.renderPassStripeGranularity, options);
        FieldToJsonResolve(jdata["maxRenderPassStripes"], decoded_value.maxRenderPassStripes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassStripeInfoARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeInfoARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeInfoARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stripeArea"], meta_struct.stripeArea, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeInfoARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassStripeInfoARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassStripeBeginInfoARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeBeginInfoARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeBeginInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeBeginInfoARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stripeInfoCount"], decoded_value.stripeInfoCount, options);
        FieldToJsonResolve(jdata["pStripeInfos"], meta_struct.pStripeInfos, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeBeginInfoARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassStripeBeginInfoARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassStripeSubmitInfoARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeSubmitInfoARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassStripeSubmitInfoARM& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassStripeSubmitInfoARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stripeSemaphoreInfoCount"], decoded_value.stripeSemaphoreInfoCount, options);
        FieldToJsonResolve(jdata["pStripeSemaphoreInfos"], meta_struct.pStripeSemaphoreInfos, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassStripeSubmitInfoARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassStripeSubmitInfoARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentDensityMapOffset"] = static_cast<bool>(decoded_value.fragmentDensityMapOffset);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["fragmentDensityOffsetGranularity"], meta_struct.fragmentDensityOffsetGranularity, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassFragmentDensityMapOffsetEndInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["fragmentDensityOffsetCount"], decoded_value.fragmentDensityOffsetCount, options);
        FieldToJsonResolve(jdata["pFragmentDensityOffsets"], meta_struct.pFragmentDensityOffsets, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceGeneratedCompute"] = static_cast<bool>(decoded_value.deviceGeneratedCompute);
        jdata["deviceGeneratedComputePipelines"] = static_cast<bool>(decoded_value.deviceGeneratedComputePipelines);
        jdata["deviceGeneratedComputeCaptureReplay"] = static_cast<bool>(decoded_value.deviceGeneratedComputeCaptureReplay);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkComputePipelineIndirectBufferInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkComputePipelineIndirectBufferInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkComputePipelineIndirectBufferInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkComputePipelineIndirectBufferInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pipelineDeviceAddressCaptureReplay"], to_hex_variable_width(decoded_value.pipelineDeviceAddressCaptureReplay), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkComputePipelineIndirectBufferInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkComputePipelineIndirectBufferInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineIndirectDeviceAddressInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineIndirectDeviceAddressInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineIndirectDeviceAddressInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineIndirectDeviceAddressInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pipelineBindPoint"], decoded_value.pipelineBindPoint, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineIndirectDeviceAddressInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineIndirectDeviceAddressInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindPipelineIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindPipelineIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindPipelineIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBindPipelineIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["pipelineAddress"], to_hex_variable_width(decoded_value.pipelineAddress), options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindPipelineIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindPipelineIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["spheres"] = static_cast<bool>(decoded_value.spheres);
        jdata["linearSweptSpheres"] = static_cast<bool>(decoded_value.linearSweptSpheres);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryLinearSweptSpheresDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vertexFormat"], decoded_value.vertexFormat, options);
        FieldToJsonResolve(jdata["vertexData"], meta_struct.vertexData, options);
        FieldToJsonResolve(jdata["vertexStride"], decoded_value.vertexStride, options);
        FieldToJsonResolve(jdata["radiusFormat"], decoded_value.radiusFormat, options);
        FieldToJsonResolve(jdata["radiusData"], meta_struct.radiusData, options);
        FieldToJsonResolve(jdata["radiusStride"], decoded_value.radiusStride, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        FieldToJsonResolve(jdata["indexData"], meta_struct.indexData, options);
        FieldToJsonResolve(jdata["indexStride"], decoded_value.indexStride, options);
        FieldToJsonResolve(jdata["indexingMode"], decoded_value.indexingMode, options);
        FieldToJsonResolve(jdata["endCapsMode"], decoded_value.endCapsMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometrySpheresDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometrySpheresDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometrySpheresDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometrySpheresDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vertexFormat"], decoded_value.vertexFormat, options);
        FieldToJsonResolve(jdata["vertexData"], meta_struct.vertexData, options);
        FieldToJsonResolve(jdata["vertexStride"], decoded_value.vertexStride, options);
        FieldToJsonResolve(jdata["radiusFormat"], decoded_value.radiusFormat, options);
        FieldToJsonResolve(jdata["radiusData"], meta_struct.radiusData, options);
        FieldToJsonResolve(jdata["radiusStride"], decoded_value.radiusStride, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        FieldToJsonResolve(jdata["indexData"], meta_struct.indexData, options);
        FieldToJsonResolve(jdata["indexStride"], decoded_value.indexStride, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometrySpheresDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometrySpheresDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLinearColorAttachmentFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["linearColorAttachment"] = static_cast<bool>(decoded_value.linearColorAttachment);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imageCompressionControlSwapchain"] = static_cast<bool>(decoded_value.imageCompressionControlSwapchain);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageViewSampleWeightCreateInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageViewSampleWeightCreateInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageViewSampleWeightCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkImageViewSampleWeightCreateInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["filterCenter"], meta_struct.filterCenter, options);
        FieldToJsonResolve(jdata["filterSize"], meta_struct.filterSize, options);
        FieldToJsonResolve(jdata["numPhases"], decoded_value.numPhases, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageViewSampleWeightCreateInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageViewSampleWeightCreateInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessingFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["textureSampleWeighted"] = static_cast<bool>(decoded_value.textureSampleWeighted);
        jdata["textureBoxFilter"] = static_cast<bool>(decoded_value.textureBoxFilter);
        jdata["textureBlockMatch"] = static_cast<bool>(decoded_value.textureBlockMatch);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessingPropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxWeightFilterPhases"], decoded_value.maxWeightFilterPhases, options);
        FieldToJsonResolve(jdata["maxWeightFilterDimension"], meta_struct.maxWeightFilterDimension, options);
        FieldToJsonResolve(jdata["maxBlockMatchRegion"], meta_struct.maxBlockMatchRegion, options);
        FieldToJsonResolve(jdata["maxBoxFilterBlockSize"], meta_struct.maxBoxFilterBlockSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNestedCommandBufferFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["nestedCommandBuffer"] = static_cast<bool>(decoded_value.nestedCommandBuffer);
        jdata["nestedCommandBufferRendering"] = static_cast<bool>(decoded_value.nestedCommandBufferRendering);
        jdata["nestedCommandBufferSimultaneousUse"] = static_cast<bool>(decoded_value.nestedCommandBufferSimultaneousUse);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceNestedCommandBufferPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxCommandBufferNestingLevel"], decoded_value.maxCommandBufferNestingLevel, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkExternalMemoryAcquireUnmodifiedEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryAcquireUnmodifiedEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkExternalMemoryAcquireUnmodifiedEXT& decoded_value = *data->decoded_value;
        const Decoded_VkExternalMemoryAcquireUnmodifiedEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["acquireUnmodifiedMemory"] = static_cast<bool>(decoded_value.acquireUnmodifiedMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkExternalMemoryAcquireUnmodifiedEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkExternalMemoryAcquireUnmodifiedEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["extendedDynamicState3TessellationDomainOrigin"] = static_cast<bool>(decoded_value.extendedDynamicState3TessellationDomainOrigin);
        jdata["extendedDynamicState3DepthClampEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3DepthClampEnable);
        jdata["extendedDynamicState3PolygonMode"] = static_cast<bool>(decoded_value.extendedDynamicState3PolygonMode);
        jdata["extendedDynamicState3RasterizationSamples"] = static_cast<bool>(decoded_value.extendedDynamicState3RasterizationSamples);
        jdata["extendedDynamicState3SampleMask"] = static_cast<bool>(decoded_value.extendedDynamicState3SampleMask);
        jdata["extendedDynamicState3AlphaToCoverageEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3AlphaToCoverageEnable);
        jdata["extendedDynamicState3AlphaToOneEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3AlphaToOneEnable);
        jdata["extendedDynamicState3LogicOpEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3LogicOpEnable);
        jdata["extendedDynamicState3ColorBlendEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3ColorBlendEnable);
        jdata["extendedDynamicState3ColorBlendEquation"] = static_cast<bool>(decoded_value.extendedDynamicState3ColorBlendEquation);
        jdata["extendedDynamicState3ColorWriteMask"] = static_cast<bool>(decoded_value.extendedDynamicState3ColorWriteMask);
        jdata["extendedDynamicState3RasterizationStream"] = static_cast<bool>(decoded_value.extendedDynamicState3RasterizationStream);
        jdata["extendedDynamicState3ConservativeRasterizationMode"] = static_cast<bool>(decoded_value.extendedDynamicState3ConservativeRasterizationMode);
        jdata["extendedDynamicState3ExtraPrimitiveOverestimationSize"] = static_cast<bool>(decoded_value.extendedDynamicState3ExtraPrimitiveOverestimationSize);
        jdata["extendedDynamicState3DepthClipEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3DepthClipEnable);
        jdata["extendedDynamicState3SampleLocationsEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3SampleLocationsEnable);
        jdata["extendedDynamicState3ColorBlendAdvanced"] = static_cast<bool>(decoded_value.extendedDynamicState3ColorBlendAdvanced);
        jdata["extendedDynamicState3ProvokingVertexMode"] = static_cast<bool>(decoded_value.extendedDynamicState3ProvokingVertexMode);
        jdata["extendedDynamicState3LineRasterizationMode"] = static_cast<bool>(decoded_value.extendedDynamicState3LineRasterizationMode);
        jdata["extendedDynamicState3LineStippleEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3LineStippleEnable);
        jdata["extendedDynamicState3DepthClipNegativeOneToOne"] = static_cast<bool>(decoded_value.extendedDynamicState3DepthClipNegativeOneToOne);
        jdata["extendedDynamicState3ViewportWScalingEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3ViewportWScalingEnable);
        jdata["extendedDynamicState3ViewportSwizzle"] = static_cast<bool>(decoded_value.extendedDynamicState3ViewportSwizzle);
        jdata["extendedDynamicState3CoverageToColorEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageToColorEnable);
        jdata["extendedDynamicState3CoverageToColorLocation"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageToColorLocation);
        jdata["extendedDynamicState3CoverageModulationMode"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageModulationMode);
        jdata["extendedDynamicState3CoverageModulationTableEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageModulationTableEnable);
        jdata["extendedDynamicState3CoverageModulationTable"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageModulationTable);
        jdata["extendedDynamicState3CoverageReductionMode"] = static_cast<bool>(decoded_value.extendedDynamicState3CoverageReductionMode);
        jdata["extendedDynamicState3RepresentativeFragmentTestEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3RepresentativeFragmentTestEnable);
        jdata["extendedDynamicState3ShadingRateImageEnable"] = static_cast<bool>(decoded_value.extendedDynamicState3ShadingRateImageEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dynamicPrimitiveTopologyUnrestricted"] = static_cast<bool>(decoded_value.dynamicPrimitiveTopologyUnrestricted);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkColorBlendEquationEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkColorBlendEquationEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkColorBlendEquationEXT& decoded_value = *data->decoded_value;
        const Decoded_VkColorBlendEquationEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["srcColorBlendFactor"], decoded_value.srcColorBlendFactor, options);
        FieldToJsonResolve(jdata["dstColorBlendFactor"], decoded_value.dstColorBlendFactor, options);
        FieldToJsonResolve(jdata["colorBlendOp"], decoded_value.colorBlendOp, options);
        FieldToJsonResolve(jdata["srcAlphaBlendFactor"], decoded_value.srcAlphaBlendFactor, options);
        FieldToJsonResolve(jdata["dstAlphaBlendFactor"], decoded_value.dstAlphaBlendFactor, options);
        FieldToJsonResolve(jdata["alphaBlendOp"], decoded_value.alphaBlendOp, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkColorBlendEquationEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkColorBlendEquationEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkColorBlendAdvancedEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkColorBlendAdvancedEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkColorBlendAdvancedEXT& decoded_value = *data->decoded_value;
        const Decoded_VkColorBlendAdvancedEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["advancedBlendOp"], decoded_value.advancedBlendOp, options);
        jdata["srcPremultiplied"] = static_cast<bool>(decoded_value.srcPremultiplied);
        jdata["dstPremultiplied"] = static_cast<bool>(decoded_value.dstPremultiplied);
        FieldToJsonResolve(jdata["blendOverlap"], decoded_value.blendOverlap, options);
        jdata["clampResults"] = static_cast<bool>(decoded_value.clampResults);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkColorBlendAdvancedEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkColorBlendAdvancedEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["subpassMergeFeedback"] = static_cast<bool>(decoded_value.subpassMergeFeedback);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassCreationControlEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationControlEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationControlEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationControlEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["disallowMerging"] = static_cast<bool>(decoded_value.disallowMerging);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationControlEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassCreationControlEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassCreationFeedbackInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationFeedbackInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationFeedbackInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationFeedbackInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["postMergeSubpassCount"], decoded_value.postMergeSubpassCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationFeedbackInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassCreationFeedbackInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassCreationFeedbackCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassCreationFeedbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pRenderPassFeedback"], meta_struct.pRenderPassFeedback, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassCreationFeedbackCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassSubpassFeedbackInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSubpassFeedbackInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSubpassFeedbackInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSubpassFeedbackInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["subpassMergeStatus"], decoded_value.subpassMergeStatus, options);
        FieldToJsonResolve(jdata["description"], &meta_struct.description, options);
        FieldToJsonResolve(jdata["postMergeIndex"], decoded_value.postMergeIndex, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSubpassFeedbackInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassSubpassFeedbackInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderPassSubpassFeedbackCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pSubpassFeedback"], meta_struct.pSubpassFeedback, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDirectDriverLoadingInfoLUNARG>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDirectDriverLoadingInfoLUNARG* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDirectDriverLoadingInfoLUNARG& decoded_value = *data->decoded_value;
        const Decoded_VkDirectDriverLoadingInfoLUNARG& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkDirectDriverLoadingFlagsLUNARG_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pfnGetInstanceProcAddr"], to_hex_variable_width(meta_struct.pfnGetInstanceProcAddr), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDirectDriverLoadingInfoLUNARG* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDirectDriverLoadingInfoLUNARG>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDirectDriverLoadingListLUNARG>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDirectDriverLoadingListLUNARG* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDirectDriverLoadingListLUNARG& decoded_value = *data->decoded_value;
        const Decoded_VkDirectDriverLoadingListLUNARG& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["driverCount"], decoded_value.driverCount, options);
        FieldToJsonResolve(jdata["pDrivers"], meta_struct.pDrivers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDirectDriverLoadingListLUNARG* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDirectDriverLoadingListLUNARG>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderModuleIdentifier"] = static_cast<bool>(decoded_value.shaderModuleIdentifier);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderModuleIdentifierAlgorithmUUID"], uuid_to_string(sizeof(decoded_value.shaderModuleIdentifierAlgorithmUUID), decoded_value.shaderModuleIdentifierAlgorithmUUID), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineShaderStageModuleIdentifierCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["identifierSize"], decoded_value.identifierSize, options);
        FieldToJsonResolve(jdata["pIdentifier"], meta_struct.pIdentifier, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShaderModuleIdentifierEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShaderModuleIdentifierEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShaderModuleIdentifierEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderModuleIdentifierEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["identifierSize"], decoded_value.identifierSize, options);
        FieldToJsonResolve(jdata["identifier"], &meta_struct.identifier, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShaderModuleIdentifierEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShaderModuleIdentifierEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpticalFlowFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["opticalFlow"] = static_cast<bool>(decoded_value.opticalFlow);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceOpticalFlowPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkOpticalFlowGridSizeFlagsNV_t(),jdata["supportedOutputGridSizes"], decoded_value.supportedOutputGridSizes, options);
        FieldToJson(VkOpticalFlowGridSizeFlagsNV_t(),jdata["supportedHintGridSizes"], decoded_value.supportedHintGridSizes, options);
        jdata["hintSupported"] = static_cast<bool>(decoded_value.hintSupported);
        jdata["costSupported"] = static_cast<bool>(decoded_value.costSupported);
        jdata["bidirectionalFlowSupported"] = static_cast<bool>(decoded_value.bidirectionalFlowSupported);
        jdata["globalFlowSupported"] = static_cast<bool>(decoded_value.globalFlowSupported);
        FieldToJsonResolve(jdata["minWidth"], decoded_value.minWidth, options);
        FieldToJsonResolve(jdata["minHeight"], decoded_value.minHeight, options);
        FieldToJsonResolve(jdata["maxWidth"], decoded_value.maxWidth, options);
        FieldToJsonResolve(jdata["maxHeight"], decoded_value.maxHeight, options);
        FieldToJsonResolve(jdata["maxNumRegionsOfInterest"], decoded_value.maxNumRegionsOfInterest, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOpticalFlowImageFormatInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowImageFormatInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowImageFormatInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowImageFormatInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkOpticalFlowUsageFlagsNV_t(),jdata["usage"], decoded_value.usage, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowImageFormatInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOpticalFlowImageFormatInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOpticalFlowImageFormatPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowImageFormatPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowImageFormatPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowImageFormatPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["format"], decoded_value.format, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowImageFormatPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOpticalFlowImageFormatPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOpticalFlowSessionCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowSessionCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowSessionCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowSessionCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["imageFormat"], decoded_value.imageFormat, options);
        FieldToJsonResolve(jdata["flowVectorFormat"], decoded_value.flowVectorFormat, options);
        FieldToJsonResolve(jdata["costFormat"], decoded_value.costFormat, options);
        FieldToJson(VkOpticalFlowGridSizeFlagsNV_t(),jdata["outputGridSize"], decoded_value.outputGridSize, options);
        FieldToJson(VkOpticalFlowGridSizeFlagsNV_t(),jdata["hintGridSize"], decoded_value.hintGridSize, options);
        FieldToJsonResolve(jdata["performanceLevel"], decoded_value.performanceLevel, options);
        FieldToJson(VkOpticalFlowSessionCreateFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowSessionCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOpticalFlowSessionCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowSessionCreatePrivateDataInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["id"], decoded_value.id, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pPrivateData"], meta_struct.pPrivateData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOpticalFlowExecuteInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowExecuteInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOpticalFlowExecuteInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOpticalFlowExecuteInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkOpticalFlowExecuteFlagsNV_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["regionCount"], decoded_value.regionCount, options);
        FieldToJsonResolve(jdata["pRegions"], meta_struct.pRegions, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOpticalFlowExecuteInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOpticalFlowExecuteInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyDitheringFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["legacyDithering"] = static_cast<bool>(decoded_value.legacyDithering);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["externalFormatResolve"] = static_cast<bool>(decoded_value.externalFormatResolve);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["nullColorAttachmentWithExternalFormatResolve"] = static_cast<bool>(decoded_value.nullColorAttachmentWithExternalFormatResolve);
        FieldToJsonResolve(jdata["externalFormatResolveChromaOffsetX"], decoded_value.externalFormatResolveChromaOffsetX, options);
        FieldToJsonResolve(jdata["externalFormatResolveChromaOffsetY"], decoded_value.externalFormatResolveChromaOffsetY, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAndroidHardwareBufferFormatResolvePropertiesANDROID& decoded_value = *data->decoded_value;
        const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["colorAttachmentFormat"], decoded_value.colorAttachmentFormat, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAntiLagFeaturesAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAntiLagFeaturesAMD& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["antiLag"] = static_cast<bool>(decoded_value.antiLag);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAntiLagFeaturesAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAntiLagPresentationInfoAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAntiLagPresentationInfoAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAntiLagPresentationInfoAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAntiLagPresentationInfoAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stage"], decoded_value.stage, options);
        FieldToJsonResolve(jdata["frameIndex"], decoded_value.frameIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAntiLagPresentationInfoAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAntiLagPresentationInfoAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAntiLagDataAMD>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAntiLagDataAMD* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAntiLagDataAMD& decoded_value = *data->decoded_value;
        const Decoded_VkAntiLagDataAMD& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["maxFPS"], decoded_value.maxFPS, options);
        FieldToJsonResolve(jdata["pPresentationInfo"], meta_struct.pPresentationInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAntiLagDataAMD* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAntiLagDataAMD>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderObjectFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderObject"] = static_cast<bool>(decoded_value.shaderObject);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderObjectPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderBinaryUUID"], uuid_to_string(sizeof(decoded_value.shaderBinaryUUID), decoded_value.shaderBinaryUUID), options);
        FieldToJsonResolve(jdata["shaderBinaryVersion"], decoded_value.shaderBinaryVersion, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkShaderCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkShaderCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkShaderCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkShaderCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderCreateFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stage"], decoded_value.stage, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["nextStage"], decoded_value.nextStage, options);
        FieldToJsonResolve(jdata["codeType"], decoded_value.codeType, options);
        FieldToJsonResolve(jdata["codeSize"], decoded_value.codeSize, options);
        FieldToJsonResolve(jdata["pCode"], meta_struct.pCode, options);
        FieldToJsonResolve(jdata["pName"], &meta_struct.pName, options);
        FieldToJsonResolve(jdata["setLayoutCount"], decoded_value.setLayoutCount, options);
        HandleToJson(jdata["pSetLayouts"], &meta_struct.pSetLayouts, options);
        FieldToJsonResolve(jdata["pushConstantRangeCount"], decoded_value.pushConstantRangeCount, options);
        FieldToJsonResolve(jdata["pPushConstantRanges"], meta_struct.pPushConstantRanges, options);
        FieldToJsonResolve(jdata["pSpecializationInfo"], meta_struct.pSpecializationInfo, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkShaderCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkShaderCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDepthClampRangeEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDepthClampRangeEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDepthClampRangeEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDepthClampRangeEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["minDepthClamp"], decoded_value.minDepthClamp, options);
        FieldToJsonResolve(jdata["maxDepthClamp"], decoded_value.maxDepthClamp, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDepthClampRangeEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDepthClampRangeEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTilePropertiesFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["tileProperties"] = static_cast<bool>(decoded_value.tileProperties);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTilePropertiesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTilePropertiesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTilePropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkTilePropertiesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["tileSize"], meta_struct.tileSize, options);
        FieldToJsonResolve(jdata["apronSize"], meta_struct.apronSize, options);
        FieldToJsonResolve(jdata["origin"], meta_struct.origin, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTilePropertiesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTilePropertiesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAmigoProfilingFeaturesSEC& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["amigoProfiling"] = static_cast<bool>(decoded_value.amigoProfiling);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAmigoProfilingSubmitInfoSEC>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAmigoProfilingSubmitInfoSEC* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAmigoProfilingSubmitInfoSEC& decoded_value = *data->decoded_value;
        const Decoded_VkAmigoProfilingSubmitInfoSEC& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["firstDrawTimestamp"], decoded_value.firstDrawTimestamp, options);
        FieldToJsonResolve(jdata["swapBufferTimestamp"], decoded_value.swapBufferTimestamp, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAmigoProfilingSubmitInfoSEC* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAmigoProfilingSubmitInfoSEC>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multiviewPerViewViewports"] = static_cast<bool>(decoded_value.multiviewPerViewViewports);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["rayTracingInvocationReorderReorderingHint"], decoded_value.rayTracingInvocationReorderReorderingHint, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingInvocationReorder"] = static_cast<bool>(decoded_value.rayTracingInvocationReorder);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeVectorPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["cooperativeVectorSupportedStages"], decoded_value.cooperativeVectorSupportedStages, options);
        jdata["cooperativeVectorTrainingFloat16Accumulation"] = static_cast<bool>(decoded_value.cooperativeVectorTrainingFloat16Accumulation);
        jdata["cooperativeVectorTrainingFloat32Accumulation"] = static_cast<bool>(decoded_value.cooperativeVectorTrainingFloat32Accumulation);
        FieldToJsonResolve(jdata["maxCooperativeVectorComponents"], decoded_value.maxCooperativeVectorComponents, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeVectorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cooperativeVector"] = static_cast<bool>(decoded_value.cooperativeVector);
        jdata["cooperativeVectorTraining"] = static_cast<bool>(decoded_value.cooperativeVectorTraining);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCooperativeVectorPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeVectorPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeVectorPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeVectorPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["inputType"], decoded_value.inputType, options);
        FieldToJsonResolve(jdata["inputInterpretation"], decoded_value.inputInterpretation, options);
        FieldToJsonResolve(jdata["matrixInterpretation"], decoded_value.matrixInterpretation, options);
        FieldToJsonResolve(jdata["biasInterpretation"], decoded_value.biasInterpretation, options);
        FieldToJsonResolve(jdata["resultType"], decoded_value.resultType, options);
        jdata["transpose"] = static_cast<bool>(decoded_value.transpose);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeVectorPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCooperativeVectorPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkConvertCooperativeVectorMatrixInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkConvertCooperativeVectorMatrixInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkConvertCooperativeVectorMatrixInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkConvertCooperativeVectorMatrixInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["srcSize"], decoded_value.srcSize, options);
        FieldToJsonResolve(jdata["srcData"], meta_struct.srcData, options);
        FieldToJsonResolve(jdata["pDstSize"], meta_struct.pDstSize, options);
        FieldToJsonResolve(jdata["dstData"], meta_struct.dstData, options);
        FieldToJsonResolve(jdata["srcComponentType"], decoded_value.srcComponentType, options);
        FieldToJsonResolve(jdata["dstComponentType"], decoded_value.dstComponentType, options);
        FieldToJsonResolve(jdata["numRows"], decoded_value.numRows, options);
        FieldToJsonResolve(jdata["numColumns"], decoded_value.numColumns, options);
        FieldToJsonResolve(jdata["srcLayout"], decoded_value.srcLayout, options);
        FieldToJsonResolve(jdata["srcStride"], decoded_value.srcStride, options);
        FieldToJsonResolve(jdata["dstLayout"], decoded_value.dstLayout, options);
        FieldToJsonResolve(jdata["dstStride"], decoded_value.dstStride, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkConvertCooperativeVectorMatrixInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkConvertCooperativeVectorMatrixInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["extendedSparseAddressSpace"] = static_cast<bool>(decoded_value.extendedSparseAddressSpace);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["extendedSparseAddressSpaceSize"], decoded_value.extendedSparseAddressSpaceSize, options);
        FieldToJson(VkImageUsageFlags_t(),jdata["extendedSparseImageUsageFlags"], decoded_value.extendedSparseImageUsageFlags, options);
        FieldToJson(VkBufferUsageFlags_t(),jdata["extendedSparseBufferUsageFlags"], decoded_value.extendedSparseBufferUsageFlags, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["legacyVertexAttributes"] = static_cast<bool>(decoded_value.legacyVertexAttributes);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["nativeUnalignedPerformance"] = static_cast<bool>(decoded_value.nativeUnalignedPerformance);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLayerSettingEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLayerSettingEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLayerSettingEXT& decoded_value = *data->decoded_value;
        const Decoded_VkLayerSettingEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["pLayerName"], &meta_struct.pLayerName, options);
        FieldToJsonResolve(jdata["pSettingName"], &meta_struct.pSettingName, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["valueCount"], decoded_value.valueCount, options);
        FieldToJsonResolve(jdata["pValues"], meta_struct.pValues, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLayerSettingEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLayerSettingEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLayerSettingsCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLayerSettingsCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLayerSettingsCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkLayerSettingsCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["settingCount"], decoded_value.settingCount, options);
        FieldToJsonResolve(jdata["pSettings"], meta_struct.pSettings, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLayerSettingsCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLayerSettingsCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderCoreBuiltins"] = static_cast<bool>(decoded_value.shaderCoreBuiltins);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderCoreMask"], decoded_value.shaderCoreMask, options);
        FieldToJsonResolve(jdata["shaderCoreCount"], decoded_value.shaderCoreCount, options);
        FieldToJsonResolve(jdata["shaderWarpsPerCore"], decoded_value.shaderWarpsPerCore, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineLibraryGroupHandles"] = static_cast<bool>(decoded_value.pipelineLibraryGroupHandles);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["dynamicRenderingUnusedAttachments"] = static_cast<bool>(decoded_value.dynamicRenderingUnusedAttachments);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLatencySleepModeInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLatencySleepModeInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLatencySleepModeInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySleepModeInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["lowLatencyMode"] = static_cast<bool>(decoded_value.lowLatencyMode);
        jdata["lowLatencyBoost"] = static_cast<bool>(decoded_value.lowLatencyBoost);
        FieldToJsonResolve(jdata["minimumIntervalUs"], decoded_value.minimumIntervalUs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLatencySleepModeInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLatencySleepModeInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLatencySleepInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLatencySleepInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLatencySleepInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySleepInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["signalSemaphore"], meta_struct.signalSemaphore, options);
        FieldToJsonResolve(jdata["value"], decoded_value.value, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLatencySleepInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLatencySleepInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSetLatencyMarkerInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSetLatencyMarkerInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSetLatencyMarkerInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetLatencyMarkerInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentID"], decoded_value.presentID, options);
        FieldToJsonResolve(jdata["marker"], decoded_value.marker, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSetLatencyMarkerInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSetLatencyMarkerInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLatencyTimingsFrameReportNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLatencyTimingsFrameReportNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLatencyTimingsFrameReportNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencyTimingsFrameReportNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentID"], decoded_value.presentID, options);
        FieldToJsonResolve(jdata["inputSampleTimeUs"], decoded_value.inputSampleTimeUs, options);
        FieldToJsonResolve(jdata["simStartTimeUs"], decoded_value.simStartTimeUs, options);
        FieldToJsonResolve(jdata["simEndTimeUs"], decoded_value.simEndTimeUs, options);
        FieldToJsonResolve(jdata["renderSubmitStartTimeUs"], decoded_value.renderSubmitStartTimeUs, options);
        FieldToJsonResolve(jdata["renderSubmitEndTimeUs"], decoded_value.renderSubmitEndTimeUs, options);
        FieldToJsonResolve(jdata["presentStartTimeUs"], decoded_value.presentStartTimeUs, options);
        FieldToJsonResolve(jdata["presentEndTimeUs"], decoded_value.presentEndTimeUs, options);
        FieldToJsonResolve(jdata["driverStartTimeUs"], decoded_value.driverStartTimeUs, options);
        FieldToJsonResolve(jdata["driverEndTimeUs"], decoded_value.driverEndTimeUs, options);
        FieldToJsonResolve(jdata["osRenderQueueStartTimeUs"], decoded_value.osRenderQueueStartTimeUs, options);
        FieldToJsonResolve(jdata["osRenderQueueEndTimeUs"], decoded_value.osRenderQueueEndTimeUs, options);
        FieldToJsonResolve(jdata["gpuRenderStartTimeUs"], decoded_value.gpuRenderStartTimeUs, options);
        FieldToJsonResolve(jdata["gpuRenderEndTimeUs"], decoded_value.gpuRenderEndTimeUs, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLatencyTimingsFrameReportNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLatencyTimingsFrameReportNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGetLatencyMarkerInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGetLatencyMarkerInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGetLatencyMarkerInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkGetLatencyMarkerInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["timingCount"], decoded_value.timingCount, options);
        FieldToJsonResolve(jdata["pTimings"], meta_struct.pTimings, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGetLatencyMarkerInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGetLatencyMarkerInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLatencySubmissionPresentIdNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLatencySubmissionPresentIdNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLatencySubmissionPresentIdNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySubmissionPresentIdNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentID"], decoded_value.presentID, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLatencySubmissionPresentIdNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLatencySubmissionPresentIdNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSwapchainLatencyCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainLatencyCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSwapchainLatencyCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkSwapchainLatencyCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["latencyModeEnable"] = static_cast<bool>(decoded_value.latencyModeEnable);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSwapchainLatencyCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSwapchainLatencyCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkOutOfBandQueueTypeInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkOutOfBandQueueTypeInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkOutOfBandQueueTypeInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkOutOfBandQueueTypeInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["queueType"], decoded_value.queueType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkOutOfBandQueueTypeInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkOutOfBandQueueTypeInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkLatencySurfaceCapabilitiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkLatencySurfaceCapabilitiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkLatencySurfaceCapabilitiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkLatencySurfaceCapabilitiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["presentModeCount"], decoded_value.presentModeCount, options);
        FieldToJsonResolve(jdata["pPresentModes"], meta_struct.pPresentModes, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkLatencySurfaceCapabilitiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkLatencySurfaceCapabilitiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["multiviewPerViewRenderAreas"] = static_cast<bool>(decoded_value.multiviewPerViewRenderAreas);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["perViewRenderAreaCount"], decoded_value.perViewRenderAreaCount, options);
        FieldToJsonResolve(jdata["pPerViewRenderAreas"], meta_struct.pPerViewRenderAreas, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePerStageDescriptorSetFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["perStageDescriptorSet"] = static_cast<bool>(decoded_value.perStageDescriptorSet);
        jdata["dynamicPipelineLayout"] = static_cast<bool>(decoded_value.dynamicPipelineLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessing2FeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["textureBlockMatch2"] = static_cast<bool>(decoded_value.textureBlockMatch2);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageProcessing2PropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxBlockMatchWindow"], meta_struct.maxBlockMatchWindow, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerBlockMatchWindowCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["windowExtent"], meta_struct.windowExtent, options);
        FieldToJsonResolve(jdata["windowCompareMode"], decoded_value.windowCompareMode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCubicWeightsFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["selectableCubicWeights"] = static_cast<bool>(decoded_value.selectableCubicWeights);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerCubicWeightsCreateInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCubicWeightsCreateInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerCubicWeightsCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerCubicWeightsCreateInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["cubicWeights"], decoded_value.cubicWeights, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerCubicWeightsCreateInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerCubicWeightsCreateInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBlitImageCubicWeightsInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBlitImageCubicWeightsInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBlitImageCubicWeightsInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkBlitImageCubicWeightsInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["cubicWeights"], decoded_value.cubicWeights, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBlitImageCubicWeightsInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBlitImageCubicWeightsInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["ycbcrDegamma"] = static_cast<bool>(decoded_value.ycbcrDegamma);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["enableYDegamma"] = static_cast<bool>(decoded_value.enableYDegamma);
        jdata["enableCbCrDegamma"] = static_cast<bool>(decoded_value.enableCbCrDegamma);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCubicClampFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cubicRangeClamp"] = static_cast<bool>(decoded_value.cubicRangeClamp);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["attachmentFeedbackLoopDynamicState"] = static_cast<bool>(decoded_value.attachmentFeedbackLoopDynamicState);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceLayeredDriverPropertiesMSFT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["underlyingAPI"], decoded_value.underlyingAPI, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["descriptorPoolOverallocation"] = static_cast<bool>(decoded_value.descriptorPoolOverallocation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["tileMemoryHeap"] = static_cast<bool>(decoded_value.tileMemoryHeap);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["queueSubmitBoundary"] = static_cast<bool>(decoded_value.queueSubmitBoundary);
        jdata["tileBufferTransfers"] = static_cast<bool>(decoded_value.tileBufferTransfers);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTileMemoryRequirementsQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTileMemoryRequirementsQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTileMemoryRequirementsQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkTileMemoryRequirementsQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["alignment"], decoded_value.alignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTileMemoryRequirementsQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTileMemoryRequirementsQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTileMemoryBindInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTileMemoryBindInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTileMemoryBindInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkTileMemoryBindInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTileMemoryBindInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTileMemoryBindInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTileMemorySizeInfoQCOM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTileMemorySizeInfoQCOM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTileMemorySizeInfoQCOM& decoded_value = *data->decoded_value;
        const Decoded_VkTileMemorySizeInfoQCOM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTileMemorySizeInfoQCOM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTileMemorySizeInfoQCOM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplaySurfaceStereoCreateInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplaySurfaceStereoCreateInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplaySurfaceStereoCreateInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkDisplaySurfaceStereoCreateInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["stereoType"], decoded_value.stereoType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplaySurfaceStereoCreateInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplaySurfaceStereoCreateInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDisplayModeStereoPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeStereoPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDisplayModeStereoPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkDisplayModeStereoPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hdmi3DSupported"] = static_cast<bool>(decoded_value.hdmi3DSupported);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDisplayModeStereoPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDisplayModeStereoPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRawAccessChainsFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderRawAccessChains"] = static_cast<bool>(decoded_value.shaderRawAccessChains);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["commandBufferInheritance"] = static_cast<bool>(decoded_value.commandBufferInheritance);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderFloat16VectorAtomics"] = static_cast<bool>(decoded_value.shaderFloat16VectorAtomics);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderReplicatedComposites"] = static_cast<bool>(decoded_value.shaderReplicatedComposites);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceShaderFloat8FeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["shaderFloat8"] = static_cast<bool>(decoded_value.shaderFloat8);
        jdata["shaderFloat8CooperativeMatrix"] = static_cast<bool>(decoded_value.shaderFloat8CooperativeMatrix);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingValidationFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingValidation"] = static_cast<bool>(decoded_value.rayTracingValidation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["partitionedAccelerationStructure"] = static_cast<bool>(decoded_value.partitionedAccelerationStructure);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxPartitionCount"], decoded_value.maxPartitionCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureFlagsNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureFlagsNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureFlagsNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureFlagsNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["enablePartitionTranslation"] = static_cast<bool>(decoded_value.enablePartitionTranslation);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureFlagsNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureFlagsNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkStridedDeviceAddressNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkStridedDeviceAddressNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkStridedDeviceAddressNV& decoded_value = *data->decoded_value;
        const Decoded_VkStridedDeviceAddressNV& meta_struct = *data;

        FieldToJsonResolve(jdata["startAddress"], to_hex_variable_width(decoded_value.startAddress), options);
        FieldToJsonResolve(jdata["strideInBytes"], decoded_value.strideInBytes, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkStridedDeviceAddressNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkStridedDeviceAddressNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBuildPartitionedAccelerationStructureIndirectCommandNV& decoded_value = *data->decoded_value;
        const Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV& meta_struct = *data;

        FieldToJsonResolve(jdata["opType"], decoded_value.opType, options);
        FieldToJsonResolve(jdata["argCount"], decoded_value.argCount, options);
        FieldToJsonResolve(jdata["argData"], meta_struct.argData, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureWriteInstanceDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["transform"], meta_struct.transform, options);
        FieldToJsonResolve(jdata["explicitAABB"], &meta_struct.explicitAABB, options);
        FieldToJsonResolve(jdata["instanceID"], decoded_value.instanceID, options);
        FieldToJsonResolve(jdata["instanceMask"], decoded_value.instanceMask, options);
        FieldToJsonResolve(jdata["instanceContributionToHitGroupIndex"], decoded_value.instanceContributionToHitGroupIndex, options);
        FieldToJson(VkPartitionedAccelerationStructureInstanceFlagsNV_t(),jdata["instanceFlags"], decoded_value.instanceFlags, options);
        FieldToJsonResolve(jdata["instanceIndex"], decoded_value.instanceIndex, options);
        FieldToJsonResolve(jdata["partitionIndex"], decoded_value.partitionIndex, options);
        FieldToJsonResolve(jdata["accelerationStructure"], to_hex_variable_width(decoded_value.accelerationStructure), options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureUpdateInstanceDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["instanceIndex"], decoded_value.instanceIndex, options);
        FieldToJsonResolve(jdata["instanceContributionToHitGroupIndex"], decoded_value.instanceContributionToHitGroupIndex, options);
        FieldToJsonResolve(jdata["accelerationStructure"], to_hex_variable_width(decoded_value.accelerationStructure), options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV& meta_struct = *data;

        FieldToJsonResolve(jdata["partitionIndex"], decoded_value.partitionIndex, options);
        FieldToJsonResolve(jdata["partitionTranslation"], &meta_struct.partitionTranslation, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetPartitionedAccelerationStructureNV& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["accelerationStructureCount"], decoded_value.accelerationStructureCount, options);
        FieldToJsonResolve(jdata["pAccelerationStructures"], meta_struct.pAccelerationStructures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureInstancesInputNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureInstancesInputNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPartitionedAccelerationStructureInstancesInputNV& decoded_value = *data->decoded_value;
        const Decoded_VkPartitionedAccelerationStructureInstancesInputNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkBuildAccelerationStructureFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["instanceCount"], decoded_value.instanceCount, options);
        FieldToJsonResolve(jdata["maxInstancePerPartitionCount"], decoded_value.maxInstancePerPartitionCount, options);
        FieldToJsonResolve(jdata["partitionCount"], decoded_value.partitionCount, options);
        FieldToJsonResolve(jdata["maxInstanceInGlobalPartitionCount"], decoded_value.maxInstanceInGlobalPartitionCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPartitionedAccelerationStructureInstancesInputNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPartitionedAccelerationStructureInstancesInputNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBuildPartitionedAccelerationStructureInfoNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBuildPartitionedAccelerationStructureInfoNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBuildPartitionedAccelerationStructureInfoNV& decoded_value = *data->decoded_value;
        const Decoded_VkBuildPartitionedAccelerationStructureInfoNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["input"], meta_struct.input, options);
        FieldToJsonResolve(jdata["srcAccelerationStructureData"], to_hex_variable_width(decoded_value.srcAccelerationStructureData), options);
        FieldToJsonResolve(jdata["dstAccelerationStructureData"], to_hex_variable_width(decoded_value.dstAccelerationStructureData), options);
        FieldToJsonResolve(jdata["scratchData"], to_hex_variable_width(decoded_value.scratchData), options);
        FieldToJsonResolve(jdata["srcInfos"], to_hex_variable_width(decoded_value.srcInfos), options);
        FieldToJsonResolve(jdata["srcInfosCount"], to_hex_variable_width(decoded_value.srcInfosCount), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBuildPartitionedAccelerationStructureInfoNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBuildPartitionedAccelerationStructureInfoNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureBuildSizesInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildSizesInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildSizesInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildSizesInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["accelerationStructureSize"], decoded_value.accelerationStructureSize, options);
        FieldToJsonResolve(jdata["updateScratchSize"], decoded_value.updateScratchSize, options);
        FieldToJsonResolve(jdata["buildScratchSize"], decoded_value.buildScratchSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildSizesInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureBuildSizesInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["deviceGeneratedCommands"] = static_cast<bool>(decoded_value.deviceGeneratedCommands);
        jdata["dynamicGeneratedPipelineLayout"] = static_cast<bool>(decoded_value.dynamicGeneratedPipelineLayout);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxIndirectPipelineCount"], decoded_value.maxIndirectPipelineCount, options);
        FieldToJsonResolve(jdata["maxIndirectShaderObjectCount"], decoded_value.maxIndirectShaderObjectCount, options);
        FieldToJsonResolve(jdata["maxIndirectSequenceCount"], decoded_value.maxIndirectSequenceCount, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsTokenCount"], decoded_value.maxIndirectCommandsTokenCount, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsTokenOffset"], decoded_value.maxIndirectCommandsTokenOffset, options);
        FieldToJsonResolve(jdata["maxIndirectCommandsIndirectStride"], decoded_value.maxIndirectCommandsIndirectStride, options);
        FieldToJson(VkIndirectCommandsInputModeFlagsEXT_t(),jdata["supportedIndirectCommandsInputModes"], decoded_value.supportedIndirectCommandsInputModes, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["supportedIndirectCommandsShaderStages"], decoded_value.supportedIndirectCommandsShaderStages, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["supportedIndirectCommandsShaderStagesPipelineBinding"], decoded_value.supportedIndirectCommandsShaderStagesPipelineBinding, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["supportedIndirectCommandsShaderStagesShaderBinding"], decoded_value.supportedIndirectCommandsShaderStagesShaderBinding, options);
        jdata["deviceGeneratedCommandsTransformFeedback"] = static_cast<bool>(decoded_value.deviceGeneratedCommandsTransformFeedback);
        jdata["deviceGeneratedCommandsMultiDrawIndirectCount"] = static_cast<bool>(decoded_value.deviceGeneratedCommandsMultiDrawIndirectCount);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsMemoryRequirementsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["indirectExecutionSet"], meta_struct.indirectExecutionSet, options);
        HandleToJson(jdata["indirectCommandsLayout"], meta_struct.indirectCommandsLayout, options);
        FieldToJsonResolve(jdata["maxSequenceCount"], decoded_value.maxSequenceCount, options);
        FieldToJsonResolve(jdata["maxDrawCount"], decoded_value.maxDrawCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectExecutionSetPipelineInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetPipelineInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetPipelineInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetPipelineInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["initialPipeline"], meta_struct.initialPipeline, options);
        FieldToJsonResolve(jdata["maxPipelineCount"], decoded_value.maxPipelineCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetPipelineInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectExecutionSetPipelineInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetShaderLayoutInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["setLayoutCount"], decoded_value.setLayoutCount, options);
        HandleToJson(jdata["pSetLayouts"], &meta_struct.pSetLayouts, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectExecutionSetShaderInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetShaderInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectExecutionSetShaderInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectExecutionSetShaderInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderCount"], decoded_value.shaderCount, options);
        HandleToJson(jdata["pInitialShaders"], &meta_struct.pInitialShaders, options);
        FieldToJsonResolve(jdata["pSetLayoutInfos"], meta_struct.pSetLayoutInfos, options);
        FieldToJsonResolve(jdata["maxShaderCount"], decoded_value.maxShaderCount, options);
        FieldToJsonResolve(jdata["pushConstantRangeCount"], decoded_value.pushConstantRangeCount, options);
        FieldToJsonResolve(jdata["pPushConstantRanges"], meta_struct.pPushConstantRanges, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectExecutionSetShaderInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectExecutionSetShaderInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["shaderStages"], decoded_value.shaderStages, options);
        HandleToJson(jdata["indirectExecutionSet"], meta_struct.indirectExecutionSet, options);
        HandleToJson(jdata["indirectCommandsLayout"], meta_struct.indirectCommandsLayout, options);
        FieldToJsonResolve(jdata["indirectAddress"], to_hex_variable_width(decoded_value.indirectAddress), options);
        FieldToJsonResolve(jdata["indirectAddressSize"], decoded_value.indirectAddressSize, options);
        FieldToJsonResolve(jdata["preprocessAddress"], to_hex_variable_width(decoded_value.preprocessAddress), options);
        FieldToJsonResolve(jdata["preprocessSize"], decoded_value.preprocessSize, options);
        FieldToJsonResolve(jdata["maxSequenceCount"], decoded_value.maxSequenceCount, options);
        FieldToJsonResolve(jdata["sequenceCountAddress"], to_hex_variable_width(decoded_value.sequenceCountAddress), options);
        FieldToJsonResolve(jdata["maxDrawCount"], decoded_value.maxDrawCount, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteIndirectExecutionSetPipelineEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteIndirectExecutionSetPipelineEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteIndirectExecutionSetPipelineEXT& decoded_value = *data->decoded_value;
        const Decoded_VkWriteIndirectExecutionSetPipelineEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["index"], decoded_value.index, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteIndirectExecutionSetPipelineEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteIndirectExecutionSetPipelineEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsPushConstantTokenEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsPushConstantTokenEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsPushConstantTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsPushConstantTokenEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["updateRange"], meta_struct.updateRange, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsPushConstantTokenEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsPushConstantTokenEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsVertexBufferTokenEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsVertexBufferTokenEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsVertexBufferTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsVertexBufferTokenEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["vertexBindingUnit"], decoded_value.vertexBindingUnit, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsVertexBufferTokenEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsVertexBufferTokenEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsIndexBufferTokenEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsIndexBufferTokenEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsIndexBufferTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsIndexBufferTokenEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsIndexBufferTokenEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsIndexBufferTokenEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsExecutionSetTokenEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsExecutionSetTokenEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsExecutionSetTokenEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsExecutionSetTokenEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["shaderStages"], decoded_value.shaderStages, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsExecutionSetTokenEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsExecutionSetTokenEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkIndirectCommandsLayoutCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkIndirectCommandsLayoutCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkIndirectCommandsLayoutUsageFlagsEXT_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJson(VkShaderStageFlags_t(),jdata["shaderStages"], decoded_value.shaderStages, options);
        FieldToJsonResolve(jdata["indirectStride"], decoded_value.indirectStride, options);
        HandleToJson(jdata["pipelineLayout"], meta_struct.pipelineLayout, options);
        FieldToJsonResolve(jdata["tokenCount"], decoded_value.tokenCount, options);
        FieldToJsonResolve(jdata["pTokens"], meta_struct.pTokens, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkIndirectCommandsLayoutCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkIndirectCommandsLayoutCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrawIndirectCountIndirectCommandEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndirectCountIndirectCommandEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrawIndirectCountIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrawIndirectCountIndirectCommandEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferAddress"], to_hex_variable_width(decoded_value.bufferAddress), options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["commandCount"], decoded_value.commandCount, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrawIndirectCountIndirectCommandEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrawIndirectCountIndirectCommandEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindVertexBufferIndirectCommandEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindVertexBufferIndirectCommandEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindVertexBufferIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindVertexBufferIndirectCommandEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferAddress"], to_hex_variable_width(decoded_value.bufferAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindVertexBufferIndirectCommandEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindVertexBufferIndirectCommandEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkBindIndexBufferIndirectCommandEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkBindIndexBufferIndirectCommandEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkBindIndexBufferIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkBindIndexBufferIndirectCommandEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["bufferAddress"], to_hex_variable_width(decoded_value.bufferAddress), options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkBindIndexBufferIndirectCommandEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkBindIndexBufferIndirectCommandEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsPipelineInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsPipelineInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsPipelineInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsPipelineInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["pipeline"], meta_struct.pipeline, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsPipelineInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsPipelineInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkGeneratedCommandsShaderInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsShaderInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkGeneratedCommandsShaderInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkGeneratedCommandsShaderInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderCount"], decoded_value.shaderCount, options);
        HandleToJson(jdata["pShaders"], &meta_struct.pShaders, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkGeneratedCommandsShaderInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkGeneratedCommandsShaderInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteIndirectExecutionSetShaderEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteIndirectExecutionSetShaderEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteIndirectExecutionSetShaderEXT& decoded_value = *data->decoded_value;
        const Decoded_VkWriteIndirectExecutionSetShaderEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["index"], decoded_value.index, options);
        HandleToJson(jdata["shader"], meta_struct.shader, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteIndirectExecutionSetShaderEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteIndirectExecutionSetShaderEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageAlignmentControlFeaturesMESA& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["imageAlignmentControl"] = static_cast<bool>(decoded_value.imageAlignmentControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceImageAlignmentControlPropertiesMESA& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["supportedImageAlignmentMask"], decoded_value.supportedImageAlignmentMask, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImageAlignmentControlCreateInfoMESA>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImageAlignmentControlCreateInfoMESA* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImageAlignmentControlCreateInfoMESA& decoded_value = *data->decoded_value;
        const Decoded_VkImageAlignmentControlCreateInfoMESA& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maximumRequestedAlignment"], decoded_value.maximumRequestedAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImageAlignmentControlCreateInfoMESA* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImageAlignmentControlCreateInfoMESA>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceDepthClampControlFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["depthClampControl"] = static_cast<bool>(decoded_value.depthClampControl);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineViewportDepthClampControlCreateInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["depthClampMode"], decoded_value.depthClampMode, options);
        FieldToJsonResolve(jdata["pDepthClampRange"], meta_struct.pDepthClampRange, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceHdrVividFeaturesHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["hdrVivid"] = static_cast<bool>(decoded_value.hdrVivid);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkHdrVividDynamicMetadataHUAWEI>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkHdrVividDynamicMetadataHUAWEI* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkHdrVividDynamicMetadataHUAWEI& decoded_value = *data->decoded_value;
        const Decoded_VkHdrVividDynamicMetadataHUAWEI& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["dynamicMetadataSize"], decoded_value.dynamicMetadataSize, options);
        FieldToJsonResolve(jdata["pDynamicMetadata"], meta_struct.pDynamicMetadata, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkHdrVividDynamicMetadataHUAWEI* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkHdrVividDynamicMetadataHUAWEI>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCooperativeMatrixFlexibleDimensionsPropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["MGranularity"], decoded_value.MGranularity, options);
        FieldToJsonResolve(jdata["NGranularity"], decoded_value.NGranularity, options);
        FieldToJsonResolve(jdata["KGranularity"], decoded_value.KGranularity, options);
        FieldToJsonResolve(jdata["AType"], decoded_value.AType, options);
        FieldToJsonResolve(jdata["BType"], decoded_value.BType, options);
        FieldToJsonResolve(jdata["CType"], decoded_value.CType, options);
        FieldToJsonResolve(jdata["ResultType"], decoded_value.ResultType, options);
        jdata["saturatingAccumulation"] = static_cast<bool>(decoded_value.saturatingAccumulation);
        FieldToJsonResolve(jdata["scope"], decoded_value.scope, options);
        FieldToJsonResolve(jdata["workgroupInvocations"], decoded_value.workgroupInvocations, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrix2FeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["cooperativeMatrixWorkgroupScope"] = static_cast<bool>(decoded_value.cooperativeMatrixWorkgroupScope);
        jdata["cooperativeMatrixFlexibleDimensions"] = static_cast<bool>(decoded_value.cooperativeMatrixFlexibleDimensions);
        jdata["cooperativeMatrixReductions"] = static_cast<bool>(decoded_value.cooperativeMatrixReductions);
        jdata["cooperativeMatrixConversions"] = static_cast<bool>(decoded_value.cooperativeMatrixConversions);
        jdata["cooperativeMatrixPerElementOperations"] = static_cast<bool>(decoded_value.cooperativeMatrixPerElementOperations);
        jdata["cooperativeMatrixTensorAddressing"] = static_cast<bool>(decoded_value.cooperativeMatrixTensorAddressing);
        jdata["cooperativeMatrixBlockLoads"] = static_cast<bool>(decoded_value.cooperativeMatrixBlockLoads);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceCooperativeMatrix2PropertiesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["cooperativeMatrixWorkgroupScopeMaxWorkgroupSize"], decoded_value.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize, options);
        FieldToJsonResolve(jdata["cooperativeMatrixFlexibleDimensionsMaxDimension"], decoded_value.cooperativeMatrixFlexibleDimensionsMaxDimension, options);
        FieldToJsonResolve(jdata["cooperativeMatrixWorkgroupScopeReservedSharedMemory"], decoded_value.cooperativeMatrixWorkgroupScopeReservedSharedMemory, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineOpacityMicromap"] = static_cast<bool>(decoded_value.pipelineOpacityMicromap);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkImportMemoryMetalHandleInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryMetalHandleInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkImportMemoryMetalHandleInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkImportMemoryMetalHandleInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["handle"], meta_struct.handle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkImportMemoryMetalHandleInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkImportMemoryMetalHandleInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryMetalHandlePropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMetalHandlePropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryMetalHandlePropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryMetalHandlePropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["memoryTypeBits"], decoded_value.memoryTypeBits, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryMetalHandlePropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryMetalHandlePropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkMemoryGetMetalHandleInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetMetalHandleInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkMemoryGetMetalHandleInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkMemoryGetMetalHandleInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["memory"], meta_struct.memory, options);
        FieldToJsonResolve(jdata["handleType"], decoded_value.handleType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkMemoryGetMetalHandleInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkMemoryGetMetalHandleInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["vertexAttributeRobustness"] = static_cast<bool>(decoded_value.vertexAttributeRobustness);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFormatPackFeaturesARM>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFormatPackFeaturesARM* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFormatPackFeaturesARM& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFormatPackFeaturesARM& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["formatPack"] = static_cast<bool>(decoded_value.formatPack);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFormatPackFeaturesARM* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFormatPackFeaturesARM>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["fragmentDensityMapLayered"] = static_cast<bool>(decoded_value.fragmentDensityMapLayered);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxFragmentDensityMapLayers"], decoded_value.maxFragmentDensityMapLayers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE& decoded_value = *data->decoded_value;
        const Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxFragmentDensityMapLayers"], decoded_value.maxFragmentDensityMapLayers, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkSetPresentConfigNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkSetPresentConfigNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkSetPresentConfigNV& decoded_value = *data->decoded_value;
        const Decoded_VkSetPresentConfigNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["numFramesPerBatch"], decoded_value.numFramesPerBatch, options);
        FieldToJsonResolve(jdata["presentConfigFeedback"], decoded_value.presentConfigFeedback, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkSetPresentConfigNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkSetPresentConfigNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePresentMeteringFeaturesNV>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePresentMeteringFeaturesNV& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["presentMetering"] = static_cast<bool>(decoded_value.presentMetering);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePresentMeteringFeaturesNV>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRenderingEndInfoEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRenderingEndInfoEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRenderingEndInfoEXT& decoded_value = *data->decoded_value;
        const Decoded_VkRenderingEndInfoEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRenderingEndInfoEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRenderingEndInfoEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["zeroInitializeDeviceMemory"] = static_cast<bool>(decoded_value.zeroInitializeDeviceMemory);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["pipelineCacheIncrementalMode"] = static_cast<bool>(decoded_value.pipelineCacheIncrementalMode);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureBuildRangeInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildRangeInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildRangeInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildRangeInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["primitiveCount"], decoded_value.primitiveCount, options);
        FieldToJsonResolve(jdata["primitiveOffset"], decoded_value.primitiveOffset, options);
        FieldToJsonResolve(jdata["firstVertex"], decoded_value.firstVertex, options);
        FieldToJsonResolve(jdata["transformOffset"], decoded_value.transformOffset, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildRangeInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureBuildRangeInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryTrianglesDataKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryTrianglesDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryTrianglesDataKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["vertexFormat"], decoded_value.vertexFormat, options);
        FieldToJsonResolve(jdata["vertexData"], meta_struct.vertexData, options);
        FieldToJsonResolve(jdata["vertexStride"], decoded_value.vertexStride, options);
        FieldToJsonResolve(jdata["maxVertex"], decoded_value.maxVertex, options);
        FieldToJsonResolve(jdata["indexType"], decoded_value.indexType, options);
        FieldToJsonResolve(jdata["indexData"], meta_struct.indexData, options);
        FieldToJsonResolve(jdata["transformData"], meta_struct.transformData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryTrianglesDataKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryAabbsDataKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryAabbsDataKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryAabbsDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryAabbsDataKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["data"], meta_struct.data, options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryAabbsDataKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryAabbsDataKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryInstancesDataKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryInstancesDataKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureGeometryInstancesDataKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureGeometryInstancesDataKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["arrayOfPointers"] = static_cast<bool>(decoded_value.arrayOfPointers);
        FieldToJsonResolve(jdata["data"], meta_struct.data, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureGeometryInstancesDataKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureGeometryInstancesDataKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureBuildGeometryInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildGeometryInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureBuildGeometryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureBuildGeometryInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJson(VkBuildAccelerationStructureFlagsKHR_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        HandleToJson(jdata["srcAccelerationStructure"], meta_struct.srcAccelerationStructure, options);
        HandleToJson(jdata["dstAccelerationStructure"], meta_struct.dstAccelerationStructure, options);
        FieldToJsonResolve(jdata["geometryCount"], decoded_value.geometryCount, options);
        FieldToJsonResolve(jdata["pGeometries"], meta_struct.pGeometries, options);
        FieldToJsonResolve(jdata["ppGeometries"], meta_struct.ppGeometries, options);
        FieldToJsonResolve(jdata["scratchData"], meta_struct.scratchData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureBuildGeometryInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureBuildGeometryInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkAccelerationStructureCreateFlagsKHR_t(),jdata["createFlags"], decoded_value.createFlags, options);
        HandleToJson(jdata["buffer"], meta_struct.buffer, options);
        FieldToJsonResolve(jdata["offset"], decoded_value.offset, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkWriteDescriptorSetAccelerationStructureKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetAccelerationStructureKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkWriteDescriptorSetAccelerationStructureKHR& decoded_value = *data->decoded_value;
        const Decoded_VkWriteDescriptorSetAccelerationStructureKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["accelerationStructureCount"], decoded_value.accelerationStructureCount, options);
        HandleToJson(jdata["pAccelerationStructures"], &meta_struct.pAccelerationStructures, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkWriteDescriptorSetAccelerationStructureKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkWriteDescriptorSetAccelerationStructureKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAccelerationStructureFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["accelerationStructure"] = static_cast<bool>(decoded_value.accelerationStructure);
        jdata["accelerationStructureCaptureReplay"] = static_cast<bool>(decoded_value.accelerationStructureCaptureReplay);
        jdata["accelerationStructureIndirectBuild"] = static_cast<bool>(decoded_value.accelerationStructureIndirectBuild);
        jdata["accelerationStructureHostCommands"] = static_cast<bool>(decoded_value.accelerationStructureHostCommands);
        jdata["descriptorBindingAccelerationStructureUpdateAfterBind"] = static_cast<bool>(decoded_value.descriptorBindingAccelerationStructureUpdateAfterBind);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceAccelerationStructurePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxGeometryCount"], decoded_value.maxGeometryCount, options);
        FieldToJsonResolve(jdata["maxInstanceCount"], decoded_value.maxInstanceCount, options);
        FieldToJsonResolve(jdata["maxPrimitiveCount"], decoded_value.maxPrimitiveCount, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorAccelerationStructures"], decoded_value.maxPerStageDescriptorAccelerationStructures, options);
        FieldToJsonResolve(jdata["maxPerStageDescriptorUpdateAfterBindAccelerationStructures"], decoded_value.maxPerStageDescriptorUpdateAfterBindAccelerationStructures, options);
        FieldToJsonResolve(jdata["maxDescriptorSetAccelerationStructures"], decoded_value.maxDescriptorSetAccelerationStructures, options);
        FieldToJsonResolve(jdata["maxDescriptorSetUpdateAfterBindAccelerationStructures"], decoded_value.maxDescriptorSetUpdateAfterBindAccelerationStructures, options);
        FieldToJsonResolve(jdata["minAccelerationStructureScratchOffsetAlignment"], decoded_value.minAccelerationStructureScratchOffsetAlignment, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureDeviceAddressInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureDeviceAddressInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureDeviceAddressInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureDeviceAddressInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["accelerationStructure"], meta_struct.accelerationStructure, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureDeviceAddressInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureDeviceAddressInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkAccelerationStructureVersionInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureVersionInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkAccelerationStructureVersionInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkAccelerationStructureVersionInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["pVersionData"], meta_struct.pVersionData, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkAccelerationStructureVersionInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkAccelerationStructureVersionInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyAccelerationStructureToMemoryInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyAccelerationStructureToMemoryInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyAccelerationStructureToMemoryInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["src"], meta_struct.src, options);
        FieldToJsonResolve(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyAccelerationStructureToMemoryInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyMemoryToAccelerationStructureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyMemoryToAccelerationStructureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyMemoryToAccelerationStructureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["src"], meta_struct.src, options);
        HandleToJson(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyMemoryToAccelerationStructureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkCopyAccelerationStructureInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkCopyAccelerationStructureInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkCopyAccelerationStructureInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkCopyAccelerationStructureInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        HandleToJson(jdata["src"], meta_struct.src, options);
        HandleToJson(jdata["dst"], meta_struct.dst, options);
        FieldToJsonResolve(jdata["mode"], decoded_value.mode, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkCopyAccelerationStructureInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkCopyAccelerationStructureInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRayTracingShaderGroupCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingShaderGroupCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingShaderGroupCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingShaderGroupCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["type"], decoded_value.type, options);
        FieldToJsonResolve(jdata["generalShader"], decoded_value.generalShader, options);
        FieldToJsonResolve(jdata["closestHitShader"], decoded_value.closestHitShader, options);
        FieldToJsonResolve(jdata["anyHitShader"], decoded_value.anyHitShader, options);
        FieldToJsonResolve(jdata["intersectionShader"], decoded_value.intersectionShader, options);
        FieldToJsonResolve(jdata["pShaderGroupCaptureReplayHandle"], meta_struct.pShaderGroupCaptureReplayHandle, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingShaderGroupCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRayTracingShaderGroupCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineInterfaceCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxPipelineRayPayloadSize"], decoded_value.maxPipelineRayPayloadSize, options);
        FieldToJsonResolve(jdata["maxPipelineRayHitAttributeSize"], decoded_value.maxPipelineRayHitAttributeSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkRayTracingPipelineCreateInfoKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineCreateInfoKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkRayTracingPipelineCreateInfoKHR& decoded_value = *data->decoded_value;
        const Decoded_VkRayTracingPipelineCreateInfoKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJson(VkPipelineCreateFlags_t(),jdata["flags"], decoded_value.flags, options);
        FieldToJsonResolve(jdata["stageCount"], decoded_value.stageCount, options);
        FieldToJsonResolve(jdata["pStages"], meta_struct.pStages, options);
        FieldToJsonResolve(jdata["groupCount"], decoded_value.groupCount, options);
        FieldToJsonResolve(jdata["pGroups"], meta_struct.pGroups, options);
        FieldToJsonResolve(jdata["maxPipelineRayRecursionDepth"], decoded_value.maxPipelineRayRecursionDepth, options);
        FieldToJsonResolve(jdata["pLibraryInfo"], meta_struct.pLibraryInfo, options);
        FieldToJsonResolve(jdata["pLibraryInterface"], meta_struct.pLibraryInterface, options);
        FieldToJsonResolve(jdata["pDynamicState"], meta_struct.pDynamicState, options);
        HandleToJson(jdata["layout"], meta_struct.layout, options);
        HandleToJson(jdata["basePipelineHandle"], meta_struct.basePipelineHandle, options);
        FieldToJsonResolve(jdata["basePipelineIndex"], decoded_value.basePipelineIndex, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkRayTracingPipelineCreateInfoKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkRayTracingPipelineCreateInfoKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPipelineFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayTracingPipeline"] = static_cast<bool>(decoded_value.rayTracingPipeline);
        jdata["rayTracingPipelineShaderGroupHandleCaptureReplay"] = static_cast<bool>(decoded_value.rayTracingPipelineShaderGroupHandleCaptureReplay);
        jdata["rayTracingPipelineShaderGroupHandleCaptureReplayMixed"] = static_cast<bool>(decoded_value.rayTracingPipelineShaderGroupHandleCaptureReplayMixed);
        jdata["rayTracingPipelineTraceRaysIndirect"] = static_cast<bool>(decoded_value.rayTracingPipelineTraceRaysIndirect);
        jdata["rayTraversalPrimitiveCulling"] = static_cast<bool>(decoded_value.rayTraversalPrimitiveCulling);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayTracingPipelinePropertiesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["shaderGroupHandleSize"], decoded_value.shaderGroupHandleSize, options);
        FieldToJsonResolve(jdata["maxRayRecursionDepth"], decoded_value.maxRayRecursionDepth, options);
        FieldToJsonResolve(jdata["maxShaderGroupStride"], decoded_value.maxShaderGroupStride, options);
        FieldToJsonResolve(jdata["shaderGroupBaseAlignment"], decoded_value.shaderGroupBaseAlignment, options);
        FieldToJsonResolve(jdata["shaderGroupHandleCaptureReplaySize"], decoded_value.shaderGroupHandleCaptureReplaySize, options);
        FieldToJsonResolve(jdata["maxRayDispatchInvocationCount"], decoded_value.maxRayDispatchInvocationCount, options);
        FieldToJsonResolve(jdata["shaderGroupHandleAlignment"], decoded_value.shaderGroupHandleAlignment, options);
        FieldToJsonResolve(jdata["maxRayHitAttributeSize"], decoded_value.maxRayHitAttributeSize, options);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkStridedDeviceAddressRegionKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkStridedDeviceAddressRegionKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkStridedDeviceAddressRegionKHR& decoded_value = *data->decoded_value;
        const Decoded_VkStridedDeviceAddressRegionKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["deviceAddress"], to_hex_variable_width(decoded_value.deviceAddress), options);
        FieldToJsonResolve(jdata["stride"], decoded_value.stride, options);
        FieldToJsonResolve(jdata["size"], decoded_value.size, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkStridedDeviceAddressRegionKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkStridedDeviceAddressRegionKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkTraceRaysIndirectCommandKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkTraceRaysIndirectCommandKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkTraceRaysIndirectCommandKHR& decoded_value = *data->decoded_value;
        const Decoded_VkTraceRaysIndirectCommandKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["width"], decoded_value.width, options);
        FieldToJsonResolve(jdata["height"], decoded_value.height, options);
        FieldToJsonResolve(jdata["depth"], decoded_value.depth, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkTraceRaysIndirectCommandKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkTraceRaysIndirectCommandKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceRayQueryFeaturesKHR>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceRayQueryFeaturesKHR& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["rayQuery"] = static_cast<bool>(decoded_value.rayQuery);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceRayQueryFeaturesKHR>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderFeaturesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        jdata["taskShader"] = static_cast<bool>(decoded_value.taskShader);
        jdata["meshShader"] = static_cast<bool>(decoded_value.meshShader);
        jdata["multiviewMeshShader"] = static_cast<bool>(decoded_value.multiviewMeshShader);
        jdata["primitiveFragmentShadingRateMeshShader"] = static_cast<bool>(decoded_value.primitiveFragmentShadingRateMeshShader);
        jdata["meshShaderQueries"] = static_cast<bool>(decoded_value.meshShaderQueries);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkPhysicalDeviceMeshShaderPropertiesEXT& decoded_value = *data->decoded_value;
        const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["sType"], decoded_value.sType, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupTotalCount"], decoded_value.maxTaskWorkGroupTotalCount, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupCount"], &meta_struct.maxTaskWorkGroupCount, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupInvocations"], decoded_value.maxTaskWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxTaskWorkGroupSize"], &meta_struct.maxTaskWorkGroupSize, options);
        FieldToJsonResolve(jdata["maxTaskPayloadSize"], decoded_value.maxTaskPayloadSize, options);
        FieldToJsonResolve(jdata["maxTaskSharedMemorySize"], decoded_value.maxTaskSharedMemorySize, options);
        FieldToJsonResolve(jdata["maxTaskPayloadAndSharedMemorySize"], decoded_value.maxTaskPayloadAndSharedMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupTotalCount"], decoded_value.maxMeshWorkGroupTotalCount, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupCount"], &meta_struct.maxMeshWorkGroupCount, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupInvocations"], decoded_value.maxMeshWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxMeshWorkGroupSize"], &meta_struct.maxMeshWorkGroupSize, options);
        FieldToJsonResolve(jdata["maxMeshSharedMemorySize"], decoded_value.maxMeshSharedMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshPayloadAndSharedMemorySize"], decoded_value.maxMeshPayloadAndSharedMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshOutputMemorySize"], decoded_value.maxMeshOutputMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshPayloadAndOutputMemorySize"], decoded_value.maxMeshPayloadAndOutputMemorySize, options);
        FieldToJsonResolve(jdata["maxMeshOutputComponents"], decoded_value.maxMeshOutputComponents, options);
        FieldToJsonResolve(jdata["maxMeshOutputVertices"], decoded_value.maxMeshOutputVertices, options);
        FieldToJsonResolve(jdata["maxMeshOutputPrimitives"], decoded_value.maxMeshOutputPrimitives, options);
        FieldToJsonResolve(jdata["maxMeshOutputLayers"], decoded_value.maxMeshOutputLayers, options);
        FieldToJsonResolve(jdata["maxMeshMultiviewViewCount"], decoded_value.maxMeshMultiviewViewCount, options);
        FieldToJsonResolve(jdata["meshOutputPerVertexGranularity"], decoded_value.meshOutputPerVertexGranularity, options);
        FieldToJsonResolve(jdata["meshOutputPerPrimitiveGranularity"], decoded_value.meshOutputPerPrimitiveGranularity, options);
        FieldToJsonResolve(jdata["maxPreferredTaskWorkGroupInvocations"], decoded_value.maxPreferredTaskWorkGroupInvocations, options);
        FieldToJsonResolve(jdata["maxPreferredMeshWorkGroupInvocations"], decoded_value.maxPreferredMeshWorkGroupInvocations, options);
        jdata["prefersLocalInvocationVertexOutput"] = static_cast<bool>(decoded_value.prefersLocalInvocationVertexOutput);
        jdata["prefersLocalInvocationPrimitiveOutput"] = static_cast<bool>(decoded_value.prefersLocalInvocationPrimitiveOutput);
        jdata["prefersCompactVertexOutput"] = static_cast<bool>(decoded_value.prefersCompactVertexOutput);
        jdata["prefersCompactPrimitiveOutput"] = static_cast<bool>(decoded_value.prefersCompactPrimitiveOutput);
        FieldToJsonResolve(jdata["pNext"], meta_struct.pNext, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT>::invoke(jdata, data, options);
                    }
                

template<>
void FieldToJsonStruct<Decoded_VkDrawMeshTasksIndirectCommandEXT>::invoke(nlohmann::ordered_json& jdata, const Decoded_VkDrawMeshTasksIndirectCommandEXT* data, const JsonOptions& options)
{
    if (data && data->decoded_value)
    {
        const VkDrawMeshTasksIndirectCommandEXT& decoded_value = *data->decoded_value;
        const Decoded_VkDrawMeshTasksIndirectCommandEXT& meta_struct = *data;

        FieldToJsonResolve(jdata["groupCountX"], decoded_value.groupCountX, options);
        FieldToJsonResolve(jdata["groupCountY"], decoded_value.groupCountY, options);
        FieldToJsonResolve(jdata["groupCountZ"], decoded_value.groupCountZ, options);
    }
}

                    void FieldToJson(nlohmann::ordered_json& jdata, const Decoded_VkDrawMeshTasksIndirectCommandEXT* data, const JsonOptions& options) {
                        FieldToJsonStruct<Decoded_VkDrawMeshTasksIndirectCommandEXT>::invoke(jdata, data, options);
                    }
                

void FieldToJson(nlohmann::ordered_json& jdata, const PNextNode* data, const JsonOptions& options)
{
    if (data && data->GetPointer())
    {
        const auto s_type = reinterpret_cast<const VkBaseInStructure*>(data->GetPointer())->sType;
        switch (s_type)
        {
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureGeometrySpheresDataNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureMotionInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAmigoProfilingSubmitInfoSEC*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAndroidHardwareBufferUsageANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentDescriptionStencilLayout*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentFeedbackLoopInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentReferenceStencilLayout*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkAttachmentSampleCountInfoAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindBufferMemoryDeviceGroupInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImageMemoryDeviceGroupInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImageMemorySwapchainInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindImagePlaneMemoryInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBindMemoryStatus*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBlitImageCubicWeightsInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferDeviceAddressCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferOpaqueCaptureAddressCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkBufferUsageFlags2CreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceRenderingInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCommandBufferInheritanceViewportScissorInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkComputePipelineIndirectBufferInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkCopyCommandTransformInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkD3D12FenceSubmitInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugReportCallbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugUtilsMessengerCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDebugUtilsObjectNameInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationBufferCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationImageCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDedicatedAllocationMemoryAllocateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDepthBiasRepresentationInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceAddressBindingCallbackDataEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceDiagnosticsConfigCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupBindSparseInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupCommandBufferBeginInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupDeviceCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupPresentInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupRenderPassBeginInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupSubmitInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceGroupSwapchainCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceMemoryOverallocationCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDevicePipelineBinaryInternalCacheControlKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDevicePrivateDataCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceQueueGlobalPriorityCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDirectDriverLoadingListLUNARG*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayModeStereoPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplayPresentInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDisplaySurfaceStereoCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesList2EXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkDrmFormatModifierPropertiesListEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportFenceCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportFenceWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryAllocateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryAllocateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportMemoryWin32HandleInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportSemaphoreCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExportSemaphoreWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalFormatANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalImageFormatProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryAcquireUnmodifiedEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryBufferCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkExternalMemoryImageCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFormatProperties3*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFragmentShadingRateAttachmentInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFrameBoundaryEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkFramebufferAttachmentsCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGeneratedCommandsPipelineInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGeneratedCommandsShaderInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGraphicsPipelineLibraryCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkHdrVividDynamicMetadataHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkHostImageCopyDevicePerformanceQuery*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageAlignmentControlCreateInfoMESA*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageCompressionControlEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageCompressionPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageDrmFormatModifierListCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageFormatListCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImagePlaneMemoryRequirementsInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageStencilUsageCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageSwapchainCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewASTCDecodeModeEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewMinLodCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewSampleWeightCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewSlicedCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImageViewUsageCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportAndroidHardwareBufferInfoANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryFdInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryHostPointerInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryMetalHandleInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryWin32HandleInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkImportMemoryZirconHandleInfoFUCHSIA*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLatencySubmissionPresentIdNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLatencySurfaceCapabilitiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkLayerSettingsCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryAllocateFlagsInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryBarrier2*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryBarrierAccessFlags3KHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryDedicatedAllocateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryDedicatedRequirements*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryMapPlacedInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMemoryPriorityAllocateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultisampledRenderToSingleSampledInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultiviewPerViewAttributesInfoNVX*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkMutableDescriptorTypeCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkOpticalFlowImageFormatInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPartitionedAccelerationStructureFlagsNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPerformanceQuerySubmitInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice16BitStorageFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice4444FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevice8BitStorageFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAntiLagFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDepthStencilResolveProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorIndexingProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDriverProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDrmPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalImageFormatInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFaultFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFeatures2*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFloatControlsProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFormatPackFeaturesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostImageCopyFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostImageCopyProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceHostQueryResetFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceIDProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageRobustnessFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceImagelessFramebufferFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceIndexTypeUint8Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInlineUniformBlockProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLineRasterizationProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance3Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance4Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance4Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance5Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance5Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance6Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance6Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMeshShaderPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMultiviewProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineRobustnessFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePipelineRobustnessProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePointClippingProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentBarrierFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentId2FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentIdFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentMeteringFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentWait2FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePresentWaitFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePrivateDataFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProtectedMemoryProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDevicePushDescriptorProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayQueryFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRobustness2FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceRobustness2PropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderAtomicInt64Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderClockFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCoreProperties2AMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderCorePropertiesARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderDrawParametersFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloat16Int8Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderFloatControls2Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubgroupSizeControlProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceSynchronization2Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTimelineSemaphoreProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVariablePointersFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVideoMaintenance2FeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan11Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan11Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan12Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan12Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan13Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan13Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan14Features*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkan14Properties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineBinaryInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineColorWriteCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCompilerControlCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageModulationStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageReductionStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCoverageToColorStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCreateFlags2CreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineCreationFeedbackCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineLayoutCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineLibraryCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationLineStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationStateRasterizationOrderAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRenderingCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineRobustnessCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineSampleLocationsStateCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineTessellationDomainOriginStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineVertexInputDivisorStateCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportSwizzleStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPipelineViewportWScalingStateCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentFrameTokenGGP*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentId2KHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentIdKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentRegionsKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkPresentTimesInfoGOOGLE*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkProtectedSubmitInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryLowLatencySupportNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolPerformanceCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyCheckpointProperties2NV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyCheckpointPropertiesNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyGlobalPriorityProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkQueueFamilyVideoPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassAttachmentBeginInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassCreationControlEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassCreationFeedbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassInputAttachmentAspectCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassMultiviewCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassSampleLocationsBeginInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassStripeBeginInfoARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassStripeSubmitInfoARM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassTileShadingCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderPassTransformBeginInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingAttachmentLocationInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkRenderingInputAttachmentIndexInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSampleLocationsInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerCubicWeightsCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerCustomBorderColorCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerReductionModeCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionImageFormatProperties*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSemaphoreTypeCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSetPresentConfigNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkShaderModuleCreateInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkShaderModuleValidationCacheCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSharedPresentSurfaceCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubpassDescriptionDepthStencilResolve*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubpassResolvePerformanceQueryEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSubresourceHostMemcpySize*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesPresentBarrierNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesPresentId2KHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceCapabilitiesPresentWait2KHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentModeCompatibilityKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentModeKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfacePresentScalingCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSurfaceProtectedCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainCounterCreateInfoEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainLatencyCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentBarrierCreateInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentFenceInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentModeInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentModesCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkSwapchainPresentScalingCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTextureLODGatherFormatPropertiesAMD*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTileMemoryBindInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTileMemoryRequirementsQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTileMemorySizeInfoQCOM*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkTimelineSemaphoreSubmitInfo*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkValidationFeaturesEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkValidationFlagsEXT*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265InlineSessionParametersInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeUsageInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeVP9CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeVP9PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoDecodeVP9ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265CapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265DpbSlotInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265GopRemainingFrameInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265PictureInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265ProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265QualityLevelPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265RateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265RateControlLayerInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersAddInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeH265SessionParametersGetInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeIntraRefreshInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQualityLevelInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeRateControlInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoEncodeUsageInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoFormatQuantizationMapPropertiesKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoInlineQueryInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoProfileInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoProfileListInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkVideoReferenceIntraRefreshInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureKHR*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetAccelerationStructureNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetInlineUniformBlock*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV:
            {
                const auto* pnext = reinterpret_cast<const Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV*>(data->GetMetaStructPointer());
                FieldToJsonResolve(jdata, pnext, options);
                break;
            }

            default:
            {
                GFXRECON_LOG_WARNING("Unknown pnext node type: %u.", (unsigned) s_type);
            }
        }
    }
}

GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
