/*
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

#include "tool_tip_summaries.h"
#include <unordered_map>

const std::unordered_map<std::string, const char*>& GetVulkanCommandToolTipSummaries()
{
    // Brief descriptions of Vulkan API commands used for tooltips in the UI. These current as of
    // 10/6/2025 and are collected from https://github.com/KhronosGroup/Vulkan-Docs.git (Commit
    // 7fe2b62)
    static const std::unordered_map<std::string, const char*> vulkan_command_tool_tip_summaries = {
        { "vkAcquireDrmDisplayEXT", "Acquire access to a VkDisplayKHR using DRM" },
        { "vkAcquireFullScreenExclusiveModeEXT",
          "Acquire full-screen exclusive mode for a swapchain" },
        { "vkAcquireNextImage2KHR", "Retrieve the index of the next available presentable image" },
        { "vkAcquireNextImageKHR", "Retrieve the index of the next available presentable image" },
        { "vkAcquirePerformanceConfigurationINTEL", "Acquire the performance query capability" },
        { "vkAcquireProfilingLockKHR", "Acquires the profiling lock" },
        { "vkAcquireWinrtDisplayNV", "Acquire access to a VkDisplayKHR" },
        { "vkAcquireXlibDisplayEXT", "Acquire access to a VkDisplayKHR using Xlib" },
        { "vkAllocateCommandBuffers", "Allocate command buffers from an existing command pool" },
        { "vkAllocateDescriptorSets", "Allocate one or more descriptor sets" },
        { "vkAllocateMemory", "Allocate device memory" },
        { "vkAntiLagUpdateAMD", "Provide information to reduce latency" },
        { "vkBeginCommandBuffer", "Start recording a command buffer" },
        { "vkBindAccelerationStructureMemoryNV", "Bind acceleration structure memory" },
        { "vkBindBufferMemory", "Bind device memory to a buffer object" },
        { "vkBindBufferMemory2", "Bind device memory to buffer objects" },
        { "vkBindDataGraphPipelineSessionMemoryARM",
          "Bind device memory to a data graph pipeline session object" },
        { "vkBindImageMemory", "Bind device memory to an image object" },
        { "vkBindImageMemory2", "Bind device memory to image objects" },
        { "vkBindOpticalFlowSessionImageNV", "Bind image to an optical flow session" },
        { "vkBindTensorMemoryARM", "Bind device memory to tensor objects" },
        { "vkBindVideoSessionMemoryKHR", "Bind Video Memory" },
        { "vkBuildAccelerationStructuresKHR", "Build an acceleration structure on the host" },
        { "vkBuildMicromapsEXT", "Build a micromap on the host" },
        { "vkCmdBeginConditionalRenderingEXT",
          "Define the beginning of a conditional rendering block" },
        { "vkCmdBeginDebugUtilsLabelEXT", "Open a command buffer debug label region" },
        { "vkCmdBeginPerTileExecutionQCOM", "Begin per-tile execution mode" },
        { "vkCmdBeginQuery", "Begin a query" },
        { "vkCmdBeginQueryIndexedEXT", "Begin an indexed query" },
        { "vkCmdBeginRenderPass", "Begin a new render pass" },
        { "vkCmdBeginRenderPass2", "Begin a new render pass" },
        { "vkCmdBeginRenderPass2KHR", "Begin a new render pass" },
        { "vkCmdBeginRendering", "Begin a dynamic render pass instance" },
        { "vkCmdBeginRenderingKHR", "Begin a dynamic render pass instance" },
        { "vkCmdBeginTransformFeedbackEXT",
          "Make transform feedback active in the command buffer" },
        { "vkCmdBeginVideoCodingKHR", "Begin video coding scope" },
        { "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT",
          "Setting embedded immutable samplers offsets in a command buffer" },
        { "vkCmdBindDescriptorBufferEmbeddedSamplersEXT",
          "Setting embedded immutable samplers offsets in a command buffer" },
        { "vkCmdBindDescriptorBuffersEXT", "Binding descriptor buffers to a command buffer" },
        { "vkCmdBindDescriptorSets", "Binds descriptor sets to a command buffer" },
        { "vkCmdBindDescriptorSets2", "Binds descriptor sets to a command buffer" },
        { "vkCmdBindDescriptorSets2KHR", "Binds descriptor sets to a command buffer" },
        { "vkCmdBindIndexBuffer", "Bind an index buffer to a command buffer" },
        { "vkCmdBindIndexBuffer2", "Bind an index buffer to a command buffer" },
        { "vkCmdBindIndexBuffer2KHR", "Bind an index buffer to a command buffer" },
        { "vkCmdBindInvocationMaskHUAWEI", "Bind an invocation mask image on a command buffer" },
        { "vkCmdBindPipeline", "Bind a pipeline object to a command buffer" },
        { "vkCmdBindPipelineShaderGroupNV",
          "Bind a pipeline object's shader group to a command buffer" },
        { "vkCmdBindShadersEXT", "Bind shader objects to a command buffer" },
        { "vkCmdBindShadingRateImageNV", "Bind a shading rate image on a command buffer" },
        { "vkCmdBindTileMemoryQCOM", "Bind tile memory to a command buffer" },
        { "vkCmdBindTransformFeedbackBuffersEXT",
          "Bind transform feedback buffers to a command buffer" },
        { "vkCmdBindVertexBuffers", "Bind vertex buffers to a command buffer" },
        { "vkCmdBindVertexBuffers2",
          "Bind vertex buffers to a command buffer and dynamically set strides" },
        { "vkCmdBindVertexBuffers2EXT",
          "Bind vertex buffers to a command buffer and dynamically set strides" },
        { "vkCmdBlitImage", "Copy regions of an image, potentially performing format conversion," },
        { "vkCmdBlitImage2",
          "Copy regions of an image, potentially performing format conversion," },
        { "vkCmdBlitImage2KHR",
          "Copy regions of an image, potentially performing format conversion," },
        { "vkCmdBuildAccelerationStructureNV", "Build an acceleration structure" },
        { "vkCmdBuildAccelerationStructuresIndirectKHR",
          "Build an acceleration structure with some parameters provided on the device" },
        { "vkCmdBuildAccelerationStructuresKHR", "Build an acceleration structure" },
        { "vkCmdBuildClusterAccelerationStructureIndirectNV",
          "Build or move cluster acceleration structures" },
        { "vkCmdBuildMicromapsEXT", "Build a micromap" },
        { "vkCmdBuildPartitionedAccelerationStructuresNV", "Command for building a PTLAS" },
        { "vkCmdClearAttachments", "Clear regions within bound framebuffer attachments" },
        { "vkCmdClearColorImage", "Clear regions of a color image" },
        { "vkCmdClearDepthStencilImage", "Fill regions of a combined depth/stencil image" },
        { "vkCmdControlVideoCodingKHR", "Control video coding parameters" },
        { "vkCmdConvertCooperativeVectorMatrixNV",
          "Convert a cooperative vector matrix from one layout and type to another" },
        { "vkCmdCopyAccelerationStructureKHR", "Copy an acceleration structure" },
        { "vkCmdCopyAccelerationStructureNV", "Copy an acceleration structure" },
        { "vkCmdCopyAccelerationStructureToMemoryKHR",
          "Copy an acceleration structure to device memory" },
        { "vkCmdCopyBuffer", "Copy data between buffer regions" },
        { "vkCmdCopyBuffer2", "Copy data between buffer regions" },
        { "vkCmdCopyBuffer2KHR", "Copy data between buffer regions" },
        { "vkCmdCopyBufferToImage", "Copy data from a buffer into an image" },
        { "vkCmdCopyBufferToImage2", "Copy data from a buffer into an image" },
        { "vkCmdCopyBufferToImage2KHR", "Copy data from a buffer into an image" },
        { "vkCmdCopyImage", "Copy data between images" },
        { "vkCmdCopyImage2", "Copy data between images" },
        { "vkCmdCopyImage2KHR", "Copy data between images" },
        { "vkCmdCopyImageToBuffer", "Copy image data into a buffer" },
        { "vkCmdCopyImageToBuffer2", "Copy image data into a buffer" },
        { "vkCmdCopyImageToBuffer2KHR", "Copy image data into a buffer" },
        { "vkCmdCopyMemoryIndirectKHR", "Copy data between memory regions" },
        { "vkCmdCopyMemoryIndirectNV", "Copy data between memory regions" },
        { "vkCmdCopyMemoryToAccelerationStructureKHR",
          "Copy device memory to an acceleration structure" },
        { "vkCmdCopyMemoryToImageIndirectKHR",
          "Copy data from a memory region to an image object" },
        { "vkCmdCopyMemoryToImageIndirectNV", "Copy data from a memory region to an image object" },
        { "vkCmdCopyMemoryToMicromapEXT", "Copy device memory to a micromap" },
        { "vkCmdCopyMicromapEXT", "Copy a micromap" },
        { "vkCmdCopyMicromapToMemoryEXT", "Copy a micromap to device memory" },
        { "vkCmdCopyQueryPoolResults",
          "Copy the results of queries in a query pool to a buffer object" },
        { "vkCmdCopyTensorARM", "Copy data between tensors" },
        { "vkCmdCudaLaunchKernelNV", "Dispatch compute work items" },
        { "vkCmdDebugMarkerBeginEXT", "Open a command buffer marker region" },
        { "vkCmdDebugMarkerEndEXT", "Close a command buffer marker region" },
        { "vkCmdDebugMarkerInsertEXT", "Insert a marker label into a command buffer" },
        { "vkCmdDecodeVideoKHR", "Launch a video decode operation" },
        { "vkCmdDecompressMemoryIndirectCountNV",
          "Indirect decompress data between memory regions" },
        { "vkCmdDecompressMemoryNV", "Decompress data between memory regions" },
        { "vkCmdDispatch", "Dispatch compute work items" },
        { "vkCmdDispatchBase",
          "Dispatch compute work items with non-zero base values for the workgroup IDs" },
        { "vkCmdDispatchDataGraphARM", "Dispatch a data graph pipeline within a session" },
        { "vkCmdDispatchGraphAMDX", "Dispatch an execution graph" },
        { "vkCmdDispatchGraphIndirectAMDX",
          "Dispatch an execution graph with node and payload parameters read on the device" },
        { "vkCmdDispatchGraphIndirectCountAMDX",
          "Dispatch an execution graph with all parameters read on the device" },
        { "vkCmdDispatchIndirect", "Dispatch compute work items with indirect parameters" },
        { "vkCmdDispatchTileQCOM", "Dispatch per-tile work items" },
        { "vkCmdDraw", "Draw primitives" },
        { "vkCmdDrawClusterHUAWEI", "Draw cluster culling work items" },
        { "vkCmdDrawClusterIndirectHUAWEI",
          "Issue an indirect cluster culling draw into a command buffer" },
        { "vkCmdDrawIndexed", "Draw primitives with indexed vertices" },
        { "vkCmdDrawIndexedIndirect",
          "Draw primitives with indirect parameters and indexed vertices" },
        { "vkCmdDrawIndexedIndirectCount",
          "Draw parameters with indirect parameters, indexed vertices, and draw count" },
        { "vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountAMD",
          "Draw parameters with indirect parameters, indexed vertices, and draw count" },
        { "vkCmdDrawIndirect", "Draw primitives with indirect parameters" },
        { "vkCmdDrawIndirectByteCountEXT",
          "Draw primitives where the vertex count is derived from the counter byte value in the "
          "counter buffer" },
        { "vkCmdDrawIndirectCount", "Draw primitives with indirect parameters and draw count" },
        { "vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountAMD",
          "Draw primitives with indirect parameters and draw count" },
        { "vkCmdDrawMeshTasksEXT", "Draw mesh task work items" },
        { "vkCmdDrawMeshTasksIndirectCountEXT",
          "Perform an indirect mesh tasks draw with the draw count sourced from a buffer" },
        { "vkCmdDrawMeshTasksIndirectCountNV",
          "Perform an indirect mesh tasks draw with the draw count sourced from a buffer" },
        { "vkCmdDrawMeshTasksIndirectEXT",
          "Issue an indirect mesh tasks draw into a command buffer" },
        { "vkCmdDrawMeshTasksIndirectNV",
          "Issue an indirect mesh tasks draw into a command buffer" },
        { "vkCmdDrawMeshTasksNV", "Draw mesh task work items" },
        { "vkCmdDrawMultiEXT", "Draw primitives" },
        { "vkCmdDrawMultiIndexedEXT", "Draw primitives" },
        { "vkCmdEncodeVideoKHR", "Launch video encode operations" },
        { "vkCmdEndConditionalRenderingEXT", "Define the end of a conditional rendering block" },
        { "vkCmdEndDebugUtilsLabelEXT", "Close a command buffer label region" },
        { "vkCmdEndPerTileExecutionQCOM", "End per-tile execution mode" },
        { "vkCmdEndQuery", "Ends a query" },
        { "vkCmdEndQueryIndexedEXT", "Ends a query" },
        { "vkCmdEndRenderPass", "End the current render pass" },
        { "vkCmdEndRenderPass2", "End the current render pass" },
        { "vkCmdEndRenderPass2KHR", "End the current render pass" },
        { "vkCmdEndRendering", "End a dynamic render pass instance" },
        { "vkCmdEndRendering2EXT", "End a dynamic render pass instance" },
        { "vkCmdEndRenderingKHR", "End a dynamic render pass instance" },
        { "vkCmdEndTransformFeedbackEXT",
          "Make transform feedback inactive in the command buffer" },
        { "vkCmdEndVideoCodingKHR", "End video coding scope" },
        { "vkCmdExecuteCommands",
          "Execute a secondary command buffer from a primary command buffer" },
        { "vkCmdExecuteGeneratedCommandsEXT", "Generate and execute commands on the device" },
        { "vkCmdExecuteGeneratedCommandsNV", "Generate and execute commands on the device" },
        { "vkCmdFillBuffer", "Fill a region of a buffer with a fixed value" },
        { "vkCmdInitializeGraphScratchMemoryAMDX",
          "Initialize scratch memory for an execution graph" },
        { "vkCmdInsertDebugUtilsLabelEXT", "Insert a label into a command buffer" },
        { "vkCmdNextSubpass", "Transition to the next subpass of a render pass" },
        { "vkCmdNextSubpass2", "Transition to the next subpass of a render pass" },
        { "vkCmdNextSubpass2KHR", "Transition to the next subpass of a render pass" },
        { "vkCmdOpticalFlowExecuteNV", "Calculate optical flow vectors" },
        { "vkCmdPipelineBarrier", "Insert a memory dependency" },
        { "vkCmdPipelineBarrier2", "Insert a memory dependency" },
        { "vkCmdPipelineBarrier2KHR", "Insert a memory dependency" },
        { "vkCmdPreprocessGeneratedCommandsEXT", "Performs preprocessing for generated commands" },
        { "vkCmdPreprocessGeneratedCommandsNV", "Performs preprocessing for generated commands" },
        { "vkCmdPushConstants", "Update the values of push constants" },
        { "vkCmdPushConstants2", "Update the values of push constants" },
        { "vkCmdPushConstants2KHR", "Update the values of push constants" },
        { "vkCmdPushDescriptorSet", "Pushes descriptor updates into a command buffer" },
        { "vkCmdPushDescriptorSet2", "Pushes descriptor updates into a command buffer" },
        { "vkCmdPushDescriptorSet2KHR", "Pushes descriptor updates into a command buffer" },
        { "vkCmdPushDescriptorSetKHR", "Pushes descriptor updates into a command buffer" },
        { "vkCmdPushDescriptorSetWithTemplate",
          "Pushes descriptor updates into a command buffer using a descriptor update template" },
        { "vkCmdPushDescriptorSetWithTemplate2",
          "Pushes descriptor updates into a command buffer using a descriptor update template" },
        { "vkCmdPushDescriptorSetWithTemplate2KHR",
          "Pushes descriptor updates into a command buffer using a descriptor update template" },
        { "vkCmdPushDescriptorSetWithTemplateKHR",
          "Pushes descriptor updates into a command buffer using a descriptor update template" },
        { "vkCmdRefreshObjectsKHR", "Execute a pipelined refresh of a list of objects" },
        { "vkCmdResetEvent", "Reset an event object to non-signaled state" },
        { "vkCmdResetEvent2", "Reset an event object to non-signaled state" },
        { "vkCmdResetEvent2KHR", "Reset an event object to non-signaled state" },
        { "vkCmdResetQueryPool", "Reset queries in a query pool" },
        { "vkCmdResolveImage", "Resolve regions of an image" },
        { "vkCmdResolveImage2", "Resolve regions of an image" },
        { "vkCmdResolveImage2KHR", "Resolve regions of an image" },
        { "vkCmdSetAlphaToCoverageEnableEXT",
          "Specify the alpha to coverage enable state dynamically for a command buffer" },
        { "vkCmdSetAlphaToOneEnableEXT",
          "Specify the alpha to one enable state dynamically for a command buffer" },
        { "vkCmdSetAttachmentFeedbackLoopEnableEXT",
          "Specify whether attachment feedback loops are enabled dynamically on a command buffer" },
        { "vkCmdSetBlendConstants", "Set the values of blend constants" },
        { "vkCmdSetCheckpointNV", "Insert diagnostic checkpoint in command stream" },
        { "vkCmdSetCoarseSampleOrderNV",
          "Set order of coverage samples for coarse fragments dynamically for a command buffer" },
        { "vkCmdSetColorBlendAdvancedEXT",
          "Specify the advanced color blend state dynamically for a command buffer" },
        { "vkCmdSetColorBlendEnableEXT",
          "Specify the pname,blendEnable for each attachment dynamically for a command buffer" },
        { "vkCmdSetColorBlendEquationEXT",
          "Specify the blend factors and operations dynamically for a command buffer" },
        { "vkCmdSetColorWriteEnableEXT",
          "Enable or disable writes to a color attachment dynamically for a command buffer" },
        { "vkCmdSetColorWriteMaskEXT",
          "Specify the color write masks for each attachment dynamically for a command buffer" },
        { "vkCmdSetConservativeRasterizationModeEXT",
          "Specify the conservative rasterization mode dynamically for a command buffer" },
        { "vkCmdSetCoverageModulationModeNV",
          "Specify the coverage modulation mode dynamically for a command buffer" },
        { "vkCmdSetCoverageModulationTableEnableNV",
          "Specify the coverage modulation table enable state dynamically for a command buffer" },
        { "vkCmdSetCoverageModulationTableNV",
          "Specify the coverage modulation table dynamically for a command buffer" },
        { "vkCmdSetCoverageReductionModeNV",
          "Specify the coverage reduction mode dynamically for a command buffer" },
        { "vkCmdSetCoverageToColorEnableNV",
          "Specify the coverage to color enable state dynamically for a command buffer" },
        { "vkCmdSetCoverageToColorLocationNV",
          "Specify the coverage to color location dynamically for a command buffer" },
        { "vkCmdSetCullMode", "Set cull mode dynamically for a command buffer" },
        { "vkCmdSetCullModeEXT", "Set cull mode dynamically for a command buffer" },
        { "vkCmdSetDepthBias",
          "Set depth bias factors and clamp dynamically for a command buffer" },
        { "vkCmdSetDepthBias2EXT",
          "Set depth bias factors and clamp dynamically for a command buffer" },
        { "vkCmdSetDepthBiasEnable",
          "Control whether to bias fragment depth values dynamically for a command buffer" },
        { "vkCmdSetDepthBiasEnableEXT",
          "Control whether to bias fragment depth values dynamically for a command buffer" },
        { "vkCmdSetDepthBounds", "Set depth bounds range dynamically for a command buffer" },
        { "vkCmdSetDepthBoundsTestEnable",
          "Set depth bounds test enable dynamically for a command buffer" },
        { "vkCmdSetDepthBoundsTestEnableEXT",
          "Set depth bounds test enable dynamically for a command buffer" },
        { "vkCmdSetDepthClampEnableEXT",
          "Specify dynamically whether depth clamping is enabled in the command buffer" },
        { "vkCmdSetDepthClampRangeEXT",
          "Set the viewport depth clamp range dynamically for a command buffer" },
        { "vkCmdSetDepthClipEnableEXT",
          "Specify dynamically whether depth clipping is enabled in the command buffer" },
        { "vkCmdSetDepthClipNegativeOneToOneEXT",
          "Specify the negative one to one depth clip mode dynamically for a command buffer" },
        { "vkCmdSetDepthCompareOp",
          "Set depth comparison operator dynamically for a command buffer" },
        { "vkCmdSetDepthCompareOpEXT",
          "Set depth comparison operator dynamically for a command buffer" },
        { "vkCmdSetDepthTestEnable", "Set depth test enable dynamically for a command buffer" },
        { "vkCmdSetDepthTestEnableEXT", "Set depth test enable dynamically for a command buffer" },
        { "vkCmdSetDepthWriteEnable", "Set depth write enable dynamically for a command buffer" },
        { "vkCmdSetDepthWriteEnableEXT",
          "Set depth write enable dynamically for a command buffer" },
        { "vkCmdSetDescriptorBufferOffsets2EXT",
          "Setting descriptor buffer offsets in a command buffer" },
        { "vkCmdSetDescriptorBufferOffsetsEXT",
          "Setting descriptor buffer offsets in a command buffer" },
        { "vkCmdSetDeviceMask", "Modify device mask of a command buffer" },
        { "vkCmdSetDiscardRectangleEXT",
          "Set discard rectangles dynamically for a command buffer" },
        { "vkCmdSetDiscardRectangleEnableEXT",
          "Enable discard rectangles dynamically for a command buffer" },
        { "vkCmdSetDiscardRectangleModeEXT",
          "Sets the discard rectangle mode dynamically for a command buffer" },
        { "vkCmdSetEvent", "Set an event object to signaled state" },
        { "vkCmdSetEvent2", "Set an event object to signaled state" },
        { "vkCmdSetEvent2KHR", "Set an event object to signaled state" },
        { "vkCmdSetExclusiveScissorEnableNV",
          "Dynamically enable each exclusive scissor for a command buffer" },
        { "vkCmdSetExclusiveScissorNV",
          "Set exclusive scissor rectangles dynamically for a command buffer" },
        { "vkCmdSetExtraPrimitiveOverestimationSizeEXT",
          "Specify the conservative rasterization extra primitive overestimation size dynamically "
          "for a command buffer" },
        { "vkCmdSetFragmentShadingRateEnumNV",
          "Set pipeline fragment shading rate dynamically for a command buffer using enums" },
        { "vkCmdSetFragmentShadingRateKHR",
          "Set pipeline fragment shading rate and combiner operation dynamically for a command "
          "buffer" },
        { "vkCmdSetFrontFace", "Set front face orientation dynamically for a command buffer" },
        { "vkCmdSetFrontFaceEXT", "Set front face orientation dynamically for a command buffer" },
        { "vkCmdSetLineRasterizationModeEXT",
          "Specify the line rasterization mode dynamically for a command buffer" },
        { "vkCmdSetLineStipple", "Set line stipple dynamically for a command buffer" },
        { "vkCmdSetLineStippleEnableEXT",
          "Specify the line stipple enable dynamically for a command buffer" },
        { "vkCmdSetLineStippleKHR vkCmdSetLineStippleEXT",
          "Set line stipple dynamically for a command buffer" },
        { "vkCmdSetLineWidth", "Set line width dynamically for a command buffer" },
        { "vkCmdSetLogicOpEXT",
          "Select which logical operation to apply for blend state dynamically for a command "
          "buffer" },
        { "vkCmdSetLogicOpEnableEXT",
          "Specify dynamically whether logical operations are enabled for a command buffer" },
        { "vkCmdSetPatchControlPointsEXT",
          "Specify the number of control points per patch dynamically for a command buffer" },
        { "vkCmdSetPerformanceMarkerINTEL", "Markers" },
        { "vkCmdSetPerformanceOverrideINTEL", "Performance override settings" },
        { "vkCmdSetPerformanceStreamMarkerINTEL", "Markers" },
        { "vkCmdSetPolygonModeEXT", "Specify polygon mode dynamically for a command buffer" },
        { "vkCmdSetPrimitiveRestartEnable",
          "Set primitive assembly restart state dynamically for a command buffer" },
        { "vkCmdSetPrimitiveRestartEnableEXT",
          "Set primitive assembly restart state dynamically for a command buffer" },
        { "vkCmdSetPrimitiveTopology",
          "Set primitive topology state dynamically for a command buffer" },
        { "vkCmdSetPrimitiveTopologyEXT",
          "Set primitive topology state dynamically for a command buffer" },
        { "vkCmdSetProvokingVertexModeEXT",
          "Specify the provoking vertex mode dynamically for a command buffer" },
        { "vkCmdSetRasterizationSamplesEXT",
          "Specify the rasterization samples dynamically for a command buffer" },
        { "vkCmdSetRasterizationStreamEXT",
          "Specify the rasterization stream dynamically for a command buffer" },
        { "vkCmdSetRasterizerDiscardEnable",
          "Control whether primitives are discarded before the rasterization stage dynamically for "
          "a command buffer" },
        { "vkCmdSetRasterizerDiscardEnableEXT",
          "Control whether primitives are discarded before the rasterization stage dynamically for "
          "a command buffer" },
        { "vkCmdSetRayTracingPipelineStackSizeKHR",
          "Set the stack size dynamically for a ray tracing pipeline" },
        { "vkCmdSetRenderingAttachmentLocations",
          "Set color attachment location mappings for a command buffer" },
        { "vkCmdSetRenderingAttachmentLocationsKHR",
          "Set color attachment location mappings for a command buffer" },
        { "vkCmdSetRenderingInputAttachmentIndices",
          "Set input attachment index mappings for a command buffer" },
        { "vkCmdSetRenderingInputAttachmentIndicesKHR",
          "Set input attachment index mappings for a command buffer" },
        { "vkCmdSetRepresentativeFragmentTestEnableNV",
          "Specify the representative fragment test enable dynamically for a command buffer" },
        { "vkCmdSetSampleLocationsEXT", "Set sample locations dynamically for a command buffer" },
        { "vkCmdSetSampleLocationsEnableEXT",
          "Specify the samples locations enable state dynamically for a command buffer" },
        { "vkCmdSetSampleMaskEXT", "Specify the sample mask dynamically for a command buffer" },
        { "vkCmdSetScissor", "Set scissor rectangles dynamically for a command buffer" },
        { "vkCmdSetScissorWithCount",
          "Set the scissor count and scissor rectangular bounds dynamically for a command buffer" },
        { "vkCmdSetScissorWithCountEXT",
          "Set the scissor count and scissor rectangular bounds dynamically for a command buffer" },
        { "vkCmdSetShadingRateImageEnableNV",
          "Specify the shading rate image enable state dynamically for a command buffer" },
        { "vkCmdSetStencilCompareMask",
          "Set stencil compare mask dynamically for a command buffer" },
        { "vkCmdSetStencilOp", "Set stencil operation dynamically for a command buffer" },
        { "vkCmdSetStencilOpEXT", "Set stencil operation dynamically for a command buffer" },
        { "vkCmdSetStencilReference",
          "Set stencil reference value dynamically for a command buffer" },
        { "vkCmdSetStencilTestEnable", "Set stencil test enable dynamically for a command buffer" },
        { "vkCmdSetStencilTestEnableEXT",
          "Set stencil test enable dynamically for a command buffer" },
        { "vkCmdSetStencilWriteMask", "Set stencil write mask dynamically for a command buffer" },
        { "vkCmdSetTessellationDomainOriginEXT",
          "Specify the origin of the tessellation domain space dynamically for a command buffer" },
        { "vkCmdSetVertexInputEXT", "Set the vertex input state dynamically for a command buffer" },
        { "vkCmdSetViewport", "Set the viewport dynamically for a command buffer" },
        { "vkCmdSetViewportShadingRatePaletteNV",
          "Set shading rate image palettes dynamically for a command buffer" },
        { "vkCmdSetViewportSwizzleNV",
          "Specify the viewport swizzle state dynamically for a command buffer" },
        { "vkCmdSetViewportWScalingEnableNV",
          "Specify the viewport W scaling enable state dynamically for a command buffer" },
        { "vkCmdSetViewportWScalingNV",
          "Set the viewport W scaling dynamically for a command buffer" },
        { "vkCmdSetViewportWithCount",
          "Set the viewport count and viewports dynamically for a command buffer" },
        { "vkCmdSetViewportWithCountEXT",
          "Set the viewport count and viewports dynamically for a command buffer" },
        { "vkCmdSubpassShadingHUAWEI", "Dispatch compute work items" },
        { "vkCmdTraceRaysIndirect2KHR",
          "Initialize an indirect ray tracing dispatch with indirect shader binding tables" },
        { "vkCmdTraceRaysIndirectKHR", "Initialize an indirect ray tracing dispatch" },
        { "vkCmdTraceRaysKHR", "Initialize a ray tracing dispatch" },
        { "vkCmdTraceRaysNV", "Initialize a ray tracing dispatch" },
        { "vkCmdUpdateBuffer", "Update a buffer\'s contents from host memory" },
        { "vkCmdUpdatePipelineIndirectBufferNV",
          "Update the indirect compute pipeline\'s metadata" },
        { "vkCmdWaitEvents", "Wait for one or more events and insert a set of memory" },
        { "vkCmdWaitEvents2", "Wait for one or more events" },
        { "vkCmdWaitEvents2KHR", "Wait for one or more events" },
        { "vkCmdWriteAccelerationStructuresPropertiesKHR",
          "Write acceleration structure result parameters to query results." },
        { "vkCmdWriteAccelerationStructuresPropertiesNV",
          "Write acceleration structure result parameters to query results." },
        { "vkCmdWriteBufferMarker2AMD",
          "Execute a pipelined write of a marker value into a buffer" },
        { "vkCmdWriteBufferMarkerAMD",
          "Execute a pipelined write of a marker value into a buffer" },
        { "vkCmdWriteMicromapsPropertiesEXT",
          "Write micromap result parameters to query results." },
        { "vkCmdWriteTimestamp", "Write a device timestamp into a query object" },
        { "vkCmdWriteTimestamp2", "Write a device timestamp into a query object" },
        { "vkCmdWriteTimestamp2KHR", "Write a device timestamp into a query object" },
        { "vkCompileDeferredNV", "Deferred compilation of shaders" },
        { "vkConvertCooperativeVectorMatrixNV",
          "Convert a cooperative vector matrix from one layout and type to another" },
        { "vkCopyAccelerationStructureKHR", "Copy an acceleration structure on the host" },
        { "vkCopyAccelerationStructureToMemoryKHR",
          "Serialize an acceleration structure on the host" },
        { "vkCopyImageToImage", "Copy image data using the host" },
        { "vkCopyImageToImageEXT", "Copy image data using the host" },
        { "vkCopyImageToMemory", "Copy image data into host memory" },
        { "vkCopyImageToMemoryEXT", "Copy image data into host memory" },
        { "vkCopyMemoryToAccelerationStructureKHR",
          "Deserialize an acceleration structure on the host" },
        { "vkCopyMemoryToImage", "Copy data from host memory into an image" },
        { "vkCopyMemoryToImageEXT", "Copy data from host memory into an image" },
        { "vkCopyMemoryToMicromapEXT", "Deserialize a micromap on the host" },
        { "vkCopyMicromapEXT", "Copy a micromap on the host" },
        { "vkCopyMicromapToMemoryEXT", "Serialize a micromap on the host" },
        { "vkCreateAccelerationStructureKHR", "Create a new acceleration structure object" },
        { "vkCreateAccelerationStructureNV", "Create a new acceleration structure object" },
        { "vkCreateAndroidSurfaceKHR",
          "Create a slink,VkSurfaceKHR object for an Android native window" },
        { "vkCreateBuffer", "Create a new buffer object" },
        { "vkCreateBufferCollectionFUCHSIA", "Create a new buffer collection" },
        { "vkCreateBufferView", "Create a new buffer view object" },
        { "vkCreateCommandPool", "Create a new command pool object" },
        { "vkCreateComputePipelines", "Creates a new compute pipeline object" },
        { "vkCreateCudaFunctionNV", "Creates a new CUDA function object" },
        { "vkCreateCudaModuleNV", "Creates a new CUDA module object" },
        { "vkCreateDataGraphPipelineSessionARM", "Create a data graph pipeline session" },
        { "vkCreateDataGraphPipelinesARM", "Create data graph pipeline objects" },
        { "vkCreateDebugReportCallbackEXT", "Create a debug report callback object" },
        { "vkCreateDebugUtilsMessengerEXT", "Create a debug messenger object" },
        { "vkCreateDeferredOperationKHR", "Create a deferred operation handle" },
        { "vkCreateDescriptorPool", "Creates a descriptor pool object" },
        { "vkCreateDescriptorSetLayout", "Create a new descriptor set layout" },
        { "vkCreateDescriptorUpdateTemplate", "Create a new descriptor update template" },
        { "vkCreateDevice", "Create a new device instance" },
        { "vkCreateDirectFBSurfaceEXT",
          "Create a slink,VkSurfaceKHR object for a DirectFB surface" },
        { "vkCreateDisplayModeKHR", "Create a display mode" },
        { "vkCreateDisplayPlaneSurfaceKHR",
          "Create a slink,VkSurfaceKHR structure representing a display plane and mode" },
        { "vkCreateEvent", "Create a new event object" },
        { "vkCreateExecutionGraphPipelinesAMDX", "Creates a new execution graph pipeline object" },
        { "vkCreateExternalComputeQueueNV",
          "Create an external compute queue for use by a compatible external API." },
        { "vkCreateFence", "Create a new fence object" },
        { "vkCreateFramebuffer", "Create a new framebuffer object" },
        { "vkCreateGraphicsPipelines", "Create graphics pipelines" },
        { "vkCreateHeadlessSurfaceEXT", "Create a headless slink,VkSurfaceKHR object" },
        { "vkCreateIOSSurfaceMVK", "Create a VkSurfaceKHR object for an iOS UIView" },
        { "vkCreateImage", "Create a new image object" },
        { "vkCreateImagePipeSurfaceFUCHSIA",
          "Create a slink,VkSurfaceKHR object for a Fuchsia ImagePipe" },
        { "vkCreateImageView", "Create an image view from an existing image" },
        { "vkCreateIndirectCommandsLayoutEXT", "Create an indirect command layout object" },
        { "vkCreateIndirectCommandsLayoutNV", "Create an indirect command layout object" },
        { "vkCreateIndirectExecutionSetEXT", "Create an indirect execution set" },
        { "vkCreateInstance", "Create a new Vulkan instance" },
        { "vkCreateMacOSSurfaceMVK", "Create a VkSurfaceKHR object for a macOS NSView" },
        { "vkCreateMetalSurfaceEXT", "Create a VkSurfaceKHR object for CAMetalLayer" },
        { "vkCreateMicromapEXT", "Create a new micromap object" },
        { "vkCreateOpticalFlowSessionNV", "Creates an optical flow session object" },
        { "vkCreatePipelineBinariesKHR",
          "Create pipeline binaries from a pipeline or previously retrieved data" },
        { "vkCreatePipelineCache", "Creates a new pipeline cache" },
        { "vkCreatePipelineLayout", "Creates a new pipeline layout object" },
        { "vkCreatePrivateDataSlot", "Create a slot for private data storage" },
        { "vkCreatePrivateDataSlotEXT", "Create a slot for private data storage" },
        { "vkCreateQueryPool", "Create a new query pool object" },
        { "vkCreateRayTracingPipelinesKHR", "Creates a new ray tracing pipeline object" },
        { "vkCreateRayTracingPipelinesNV", "Creates a new ray tracing pipeline object" },
        { "vkCreateRenderPass", "Create a new render pass object" },
        { "vkCreateRenderPass2", "Create a new render pass object" },
        { "vkCreateRenderPass2KHR", "Create a new render pass object" },
        { "vkCreateSampler", "Create a new sampler object" },
        { "vkCreateSamplerYcbcrConversion", "Create a new {YCbCr} conversion" },
        { "vkCreateScreenSurfaceQNX",
          "Create a slink,VkSurfaceKHR object for a QNX Screen window" },
        { "vkCreateSemaphore", "Create a new queue semaphore object" },
        { "vkCreateSemaphoreSciSyncPoolNV", "Create a slink,VkSemaphoreSciSyncPoolNV object" },
        { "vkCreateShaderModule", "Creates a new shader module object" },
        { "vkCreateShadersEXT", "Create one or more new shaders" },
        { "vkCreateSharedSwapchainsKHR",
          "Create multiple swapchains that share presentable images" },
        { "vkCreateStreamDescriptorSurfaceGGP",
          "Create a slink,VkSurfaceKHR object for a Google Games Platform stream" },
        { "vkCreateSurfaceOHOS",
          "Create a slink,VkSurfaceKHR object for an Open Harmony OS native window" },
        { "vkCreateSwapchainKHR", "Create a swapchain" },
        { "vkCreateTensorARM", "Create a new tensor object" },
        { "vkCreateTensorViewARM", "Create an tensor view from an existing tensor" },
        { "vkCreateValidationCacheEXT", "Creates a new validation cache" },
        { "vkCreateViSurfaceNN", "Create a slink,VkSurfaceKHR object for a VI layer" },
        { "vkCreateVideoSessionKHR", "Creates a video session object" },
        { "vkCreateVideoSessionParametersKHR", "Creates video session parameters object" },
        { "vkCreateWaylandSurfaceKHR", "Create a slink,VkSurfaceKHR object for a Wayland window" },
        { "vkCreateWin32SurfaceKHR", "Create a VkSurfaceKHR object for a Win32 native window" },
        { "vkCreateXcbSurfaceKHR",
          "Create a slink,VkSurfaceKHR object for a X11 window, using the XCB client-side "
          "library" },
        { "vkCreateXlibSurfaceKHR",
          "Create a slink,VkSurfaceKHR object for an X11 window, using the Xlib client-side "
          "library" },
        { "vkDebugMarkerSetObjectNameEXT", "Give an application-defined name to an object" },
        { "vkDebugMarkerSetObjectTagEXT", "Attach arbitrary data to an object" },
        { "vkDebugReportMessageEXT", "Inject a message into a debug stream" },
        { "vkDeferredOperationJoinKHR", "Assign a thread to a deferred operation" },
        { "vkDestroyAccelerationStructureKHR", "Destroy an acceleration structure object" },
        { "vkDestroyAccelerationStructureNV", "Destroy an acceleration structure object" },
        { "vkDestroyBuffer", "Destroy a buffer object" },
        { "vkDestroyBufferCollectionFUCHSIA", "Destroy a buffer collection" },
        { "vkDestroyBufferView", "Destroy a buffer view object" },
        { "vkDestroyCommandPool", "Destroy a command pool object" },
        { "vkDestroyCudaFunctionNV", "Destroy a CUDA function" },
        { "vkDestroyCudaModuleNV", "Destroy a CUDA module" },
        { "vkDestroyDataGraphPipelineSessionARM", "Destroy a data graph pipeline session object" },
        { "vkDestroyDebugReportCallbackEXT", "Destroy a debug report callback object" },
        { "vkDestroyDebugUtilsMessengerEXT", "Destroy a debug messenger object" },
        { "vkDestroyDeferredOperationKHR", "Destroy a deferred operation handle" },
        { "vkDestroyDescriptorPool", "Destroy a descriptor pool object" },
        { "vkDestroyDescriptorSetLayout", "Destroy a descriptor set layout object" },
        { "vkDestroyDescriptorUpdateTemplate", "Destroy a descriptor update template object" },
        { "vkDestroyDevice", "Destroy a logical device" },
        { "vkDestroyEvent", "Destroy an event object" },
        { "vkDestroyExternalComputeQueueNV", "Destroys an external queue." },
        { "vkDestroyFence", "Destroy a fence object" },
        { "vkDestroyFramebuffer", "Destroy a framebuffer object" },
        { "vkDestroyImage", "Destroy an image object" },
        { "vkDestroyImageView", "Destroy an image view object" },
        { "vkDestroyIndirectCommandsLayoutEXT", "Destroy an indirect commands layout" },
        { "vkDestroyIndirectCommandsLayoutNV", "Destroy an indirect commands layout" },
        { "vkDestroyIndirectExecutionSetEXT", "Destroy an indirect execution set" },
        { "vkDestroyInstance", "Destroy an instance of Vulkan" },
        { "vkDestroyMicromapEXT", "Destroy a micromap object" },
        { "vkDestroyOpticalFlowSessionNV", "Destroy optical flow session object" },
        { "vkDestroyPipeline", "Destroy a pipeline object" },
        { "vkDestroyPipelineBinaryKHR", "Destroy a pipeline binary" },
        { "vkDestroyPipelineCache", "Destroy a pipeline cache object" },
        { "vkDestroyPipelineLayout", "Destroy a pipeline layout object" },
        { "vkDestroyPrivateDataSlot", "Destroy a private data slot" },
        { "vkDestroyPrivateDataSlotEXT", "Destroy a private data slot" },
        { "vkDestroyQueryPool", "Destroy a query pool object" },
        { "vkDestroyRenderPass", "Destroy a render pass object" },
        { "vkDestroySampler", "Destroy a sampler object" },
        { "vkDestroySamplerYcbcrConversion", "Destroy a created {YCbCr} conversion" },
        { "vkDestroySemaphore", "Destroy a semaphore object" },
        { "vkDestroySemaphoreSciSyncPoolNV", "Destroy a slink,VkSemaphoreSciSyncPoolNV object" },
        { "vkDestroyShaderEXT", "Destroy a shader object" },
        { "vkDestroyShaderModule", "Destroy a shader module" },
        { "vkDestroySurfaceKHR", "Destroy a VkSurfaceKHR object" },
        { "vkDestroySwapchainKHR", "Destroy a swapchain object" },
        { "vkDestroyTensorARM", "Destroy a tensor object" },
        { "vkDestroyTensorViewARM", "Destroy a tensor view object" },
        { "vkDestroyValidationCacheEXT", "Destroy a validation cache object" },
        { "vkDestroyVideoSessionKHR", "Destroy video session object" },
        { "vkDestroyVideoSessionParametersKHR", "Destroy video session parameters object" },
        { "vkDeviceWaitIdle", "Wait for a device to become idle" },
        { "vkDisplayPowerControlEXT", "Set the power state of a display" },
        { "vkEndCommandBuffer", "Finish recording a command buffer" },
        { "vkEnumerateDeviceExtensionProperties",
          "Returns properties of available physical device extensions" },
        { "vkEnumerateDeviceLayerProperties",
          "Returns properties of available physical device layers" },
        { "vkEnumerateInstanceExtensionProperties",
          "Returns up to requested number of global extension properties" },
        { "vkEnumerateInstanceLayerProperties",
          "Returns up to requested number of global layer properties" },
        { "vkEnumerateInstanceVersion", "Query instance-level version before instance creation" },
        { "vkEnumeratePhysicalDeviceGroups",
          "Enumerates groups of physical devices that can be used to create a single logical "
          "device" },
        { "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR",
          "Reports properties of the performance query counters available on a queue family of a "
          "device" },
        { "vkEnumeratePhysicalDevices",
          "Enumerates the physical devices accessible to a Vulkan instance" },
        { "vkExportMetalObjectsEXT", "Export Metal objects from the corresponding Vulkan objects" },
        { "vkFlushMappedMemoryRanges", "Flush mapped memory ranges" },
        { "vkFreeCommandBuffers", "Free command buffers" },
        { "vkFreeDescriptorSets", "Free one or more descriptor sets" },
        { "vkFreeMemory", "Free device memory" },
        { "vkGetAccelerationStructureBuildSizesKHR",
          "Retrieve the required size for an acceleration structure" },
        { "vkGetAccelerationStructureDeviceAddressKHR",
          "Query an address of an acceleration structure" },
        { "vkGetAccelerationStructureHandleNV", "Get opaque acceleration structure handle" },
        { "vkGetAccelerationStructureMemoryRequirementsNV",
          "Get acceleration structure memory requirements" },
        { "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT",
          "Get acceleration structure opaque capture descriptor data" },
        { "vkGetAndroidHardwareBufferPropertiesANDROID",
          "Get Properties of External Memory Android Hardware Buffers" },
        { "vkGetBufferCollectionPropertiesFUCHSIA",
          "Retrieve properties from a buffer collection" },
        { "vkGetBufferDeviceAddress", "Query an address of a buffer" },
        { "vkGetBufferDeviceAddressKHR", "Query an address of a buffer" },
        { "vkGetBufferMemoryRequirements",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetBufferMemoryRequirements2",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetBufferOpaqueCaptureAddress", "Query an opaque capture address of a buffer" },
        { "vkGetBufferOpaqueCaptureAddressKHR", "Query an opaque capture address of a buffer" },
        { "vkGetBufferOpaqueCaptureDescriptorDataEXT",
          "Get buffer opaque capture descriptor data" },
        { "vkGetCalibratedTimestampsEXT", "Query calibrated timestamps" },
        { "vkGetCalibratedTimestampsKHR", "Query calibrated timestamps" },
        { "vkGetClusterAccelerationStructureBuildSizesNV",
          "Retrieve the buffer allocation requirements for cluster geometry command" },
        { "vkGetCommandPoolMemoryConsumption",
          "Get memory usage information for a command pool object" },
        { "vkGetCudaModuleCacheNV", "Get CUDA module cache" },
        { "vkGetDataGraphPipelineAvailablePropertiesARM",
          "Query available properties of a data graph pipeline" },
        { "vkGetDataGraphPipelinePropertiesARM", "Query properties of a data graph pipeline" },
        { "vkGetDataGraphPipelineSessionBindPointRequirementsARM",
          "Get the bind point requirements of a data graph pipeline session" },
        { "vkGetDataGraphPipelineSessionMemoryRequirementsARM",
          "Get the memory requirements of a data graph pipeline session" },
        { "vkGetDeferredOperationMaxConcurrencyKHR",
          "Query the maximum concurrency on a deferred operation" },
        { "vkGetDeferredOperationResultKHR", "Query the result of a deferred operation" },
        { "vkGetDescriptorEXT", "To get a descriptor to place in a buffer" },
        { "vkGetDescriptorSetLayoutBindingOffsetEXT",
          "Get the offset of a binding within a descriptor set layout" },
        { "vkGetDescriptorSetLayoutSizeEXT", "Get the size of a descriptor set layout in memory" },
        { "vkGetDescriptorSetLayoutSupport",
          "Query whether a descriptor set layout can be created" },
        { "vkGetDeviceAccelerationStructureCompatibilityKHR",
          "Check if a serialized acceleration structure is compatible with the current device" },
        { "vkGetDeviceBufferMemoryRequirements",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetDeviceBufferMemoryRequirementsKHR",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetDeviceFaultInfoEXT",
          "Reports diagnostic fault information on the specified logical device" },
        { "vkGetDeviceGroupPeerMemoryFeatures",
          "Query supported peer memory features of a device" },
        { "vkGetDeviceGroupPresentCapabilitiesKHR",
          "Query present capabilities from other physical devices" },
        { "vkGetDeviceGroupSurfacePresentModes2EXT",
          "Query device group present capabilities for a surface" },
        { "vkGetDeviceGroupSurfacePresentModesKHR", "Query present capabilities for a surface" },
        { "vkGetDeviceImageMemoryRequirements",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetDeviceImageMemoryRequirementsKHR",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetDeviceImageSparseMemoryRequirements",
          "Query the memory requirements for a sparse image" },
        { "vkGetDeviceImageSparseMemoryRequirementsKHR",
          "Query the memory requirements for a sparse image" },
        { "vkGetDeviceImageSubresourceLayout",
          "Retrieve information about an image subresource without an image object" },
        { "vkGetDeviceImageSubresourceLayoutKHR",
          "Retrieve information about an image subresource without an image object" },
        { "vkGetDeviceMemoryCommitment", "Query the current commitment for a VkDeviceMemory" },
        { "vkGetDeviceMemoryOpaqueCaptureAddress",
          "Query an opaque capture address of a memory object" },
        { "vkGetDeviceMemoryOpaqueCaptureAddressKHR",
          "Query an opaque capture address of a memory object" },
        { "vkGetDeviceMicromapCompatibilityEXT",
          "Check if a serialized micromap is compatible with the current device" },
        { "vkGetDeviceProcAddr", "Return a function pointer for a command" },
        { "vkGetDeviceQueue", "Get a queue handle from a device" },
        { "vkGetDeviceQueue2", "Get a queue handle from a device" },
        { "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI",
          "Query maximum supported subpass shading workgroup size for a give render pass" },
        { "vkGetDeviceTensorMemoryRequirementsARM",
          "Returns the memory requirements for specified tensor creation infos" },
        { "vkGetDisplayModeProperties2KHR",
          "Query information about the available display modes." },
        { "vkGetDisplayModePropertiesKHR",
          "Query the set of mode properties supported by the display" },
        { "vkGetDisplayPlaneCapabilities2KHR",
          "Query capabilities of a mode and plane combination" },
        { "vkGetDisplayPlaneCapabilitiesKHR",
          "Query capabilities of a mode and plane combination" },
        { "vkGetDisplayPlaneSupportedDisplaysKHR", "Query the list of displays a plane supports" },
        { "vkGetDrmDisplayEXT", "Query the VkDisplayKHR corresponding to a DRM connector ID" },
        { "vkGetDynamicRenderingTilePropertiesQCOM",
          "Get the properties when using dynamic rendering" },
        { "vkGetEncodedVideoSessionParametersKHR",
          "Get encoded parameter sets from a video session parameters object" },
        { "vkGetEventStatus", "Retrieve the status of an event object" },
        { "vkGetExecutionGraphPipelineNodeIndexAMDX",
          "Query internal id of a node in an execution graph" },
        { "vkGetExecutionGraphPipelineScratchSizeAMDX",
          "Query scratch space required to dispatch an execution graph" },
        { "vkGetExternalComputeQueueDataNV",
          "Retrieves data necessary for compatible external API initialization" },
        { "vkGetFaultData", "Query fault information" },
        { "vkGetFenceFdKHR", "Get a POSIX file descriptor handle for a fence" },
        { "vkGetFenceSciSyncFenceNV", "Get a stext,NvSciSyncFence handle for a fence" },
        { "vkGetFenceSciSyncObjNV", "Get a stext,NvSciSyncObj handle for a fence" },
        { "vkGetFenceStatus", "Return the status of a fence" },
        { "vkGetFenceWin32HandleKHR", "Get a Windows HANDLE for a fence" },
        { "vkGetFramebufferTilePropertiesQCOM",
          "Get tile properties from the attachments in framebuffer" },
        { "vkGetGeneratedCommandsMemoryRequirementsEXT",
          "Retrieve the buffer allocation requirements for generated commands" },
        { "vkGetGeneratedCommandsMemoryRequirementsNV",
          "Retrieve the buffer allocation requirements for generated commands" },
        { "vkGetImageDrmFormatModifierPropertiesEXT", "Returns an image\'s DRM format modifier" },
        { "vkGetImageMemoryRequirements",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetImageMemoryRequirements2",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetImageOpaqueCaptureDescriptorDataEXT", "Get image opaque capture descriptor data" },
        { "vkGetImageSparseMemoryRequirements",
          "Query the memory requirements for a sparse image" },
        { "vkGetImageSparseMemoryRequirements2",
          "Query the memory requirements for a sparse image" },
        { "vkGetImageSubresourceLayout", "Retrieve information about an image subresource" },
        { "vkGetImageSubresourceLayout2", "Retrieve information about an image subresource" },
        { "vkGetImageSubresourceLayout2KHR vkGetImageSubresourceLayout2EXT",
          "Retrieve information about an image subresource" },
        { "vkGetImageViewAddressNVX", "Get the device address of an image view" },
        { "vkGetImageViewHandle64NVX",
          "Get the 64-bit handle for an image view for a specific descriptor type" },
        { "vkGetImageViewHandleNVX",
          "Get the handle for an image view for a specific descriptor type" },
        { "vkGetImageViewOpaqueCaptureDescriptorDataEXT",
          "Get image view opaque capture descriptor data" },
        { "vkGetInstanceProcAddr", "Return a function pointer for a command" },
        { "vkGetLatencyTimingsNV", "Get latency marker results" },
        { "vkGetMemoryAndroidHardwareBufferANDROID",
          "Get an Android hardware buffer for a memory object" },
        { "vkGetMemoryFdKHR", "Get a POSIX file descriptor for a memory object" },
        { "vkGetMemoryFdPropertiesKHR", "Get Properties of External Memory File Descriptors" },
        { "vkGetMemoryHostPointerPropertiesEXT", "Get properties of external memory host pointer" },
        { "vkGetMemoryMetalHandleEXT", "Get a Metal handle for a memory object" },
        { "vkGetMemoryMetalHandlePropertiesEXT",
          "Get Properties of External Memory Metal Handles" },
        { "vkGetMemoryRemoteAddressNV",
          "Get an address for a memory object accessible by remote devices" },
        { "vkGetMemorySciBufNV", "Get a stext,NvSciBufObj handle for a memory object" },
        { "vkGetMemoryWin32HandleKHR", "Get a Windows HANDLE for a memory object" },
        { "vkGetMemoryWin32HandleNV", "Retrieve Win32 handle to a device memory object" },
        { "vkGetMemoryWin32HandlePropertiesKHR",
          "Get Properties of External Memory Win32 Handles" },
        { "vkGetMemoryZirconHandleFUCHSIA", "Get a Zircon handle for an external memory object" },
        { "vkGetMemoryZirconHandlePropertiesFUCHSIA",
          "Get a Zircon handle properties for an external memory object" },
        { "vkGetMicromapBuildSizesEXT", "Retrieve the required size for a micromap" },
        { "vkGetPartitionedAccelerationStructuresBuildSizesNV",
          "Retrieve the buffer allocation requirements for partitioned acceleration structure "
          "command" },
        { "vkGetPastPresentationTimingGOOGLE", "Obtain timing of a previously-presented image" },
        { "vkGetPerformanceParameterINTEL", "Query performance capabilities of the device" },
        { "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", "Query calibrateable time domains" },
        { "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", "Query calibrateable time domains" },
        { "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV",
          "Returns properties describing what cooperative matrix types are supported" },
        { "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR",
          "Returns properties describing what cooperative matrix types are supported" },
        { "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV",
          "Returns properties describing what cooperative matrix types are supported" },
        { "vkGetPhysicalDeviceCooperativeVectorPropertiesNV",
          "Returns properties describing what cooperative vector types are supported" },
        { "vkGetPhysicalDeviceDirectFBPresentationSupportEXT",
          "Query physical device for presentation with DirectFB" },
        { "vkGetPhysicalDeviceDisplayPlaneProperties2KHR",
          "Query information about the available display planes." },
        { "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", "Query the plane properties" },
        { "vkGetPhysicalDeviceDisplayProperties2KHR",
          "Query information about the available displays" },
        { "vkGetPhysicalDeviceDisplayPropertiesKHR",
          "Query information about the available displays" },
        { "vkGetPhysicalDeviceExternalBufferProperties",
          "Query external handle types supported by buffers" },
        { "vkGetPhysicalDeviceExternalFenceProperties",
          "Function for querying external fence handle capabilities." },
        { "vkGetPhysicalDeviceExternalImageFormatPropertiesNV",
          "Determine image capabilities compatible with external memory handle types" },
        { "vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV",
          "Get physical device properties of External Memory stext,NvSciBufObj Handles" },
        { "vkGetPhysicalDeviceExternalSemaphoreProperties",
          "Function for querying external semaphore handle capabilities." },
        { "vkGetPhysicalDeviceExternalTensorPropertiesARM",
          "Function for querying external tensor handle capabilities." },
        { "vkGetPhysicalDeviceFeatures", "Reports capabilities of a physical device" },
        { "vkGetPhysicalDeviceFeatures2", "Reports capabilities of a physical device" },
        { "vkGetPhysicalDeviceFormatProperties", "Lists physical device\'s format capabilities" },
        { "vkGetPhysicalDeviceFormatProperties2", "Lists physical device\'s format capabilities" },
        { "vkGetPhysicalDeviceFragmentShadingRatesKHR",
          "Get available shading rates for a physical device" },
        { "vkGetPhysicalDeviceImageFormatProperties",
          "Lists physical device\'s image format capabilities" },
        { "vkGetPhysicalDeviceImageFormatProperties2",
          "Lists physical device\'s image format capabilities" },
        { "vkGetPhysicalDeviceMemoryProperties",
          "Reports memory information for the specified physical device" },
        { "vkGetPhysicalDeviceMemoryProperties2",
          "Reports memory information for the specified physical device" },
        { "vkGetPhysicalDeviceMultisamplePropertiesEXT",
          "Report sample count specific multisampling capabilities of a physical device" },
        { "vkGetPhysicalDeviceOpticalFlowImageFormatsNV", "Query image formats for optical flow" },
        { "vkGetPhysicalDevicePresentRectanglesKHR",
          "Query present rectangles for a surface on a physical device" },
        { "vkGetPhysicalDeviceProperties", "Returns properties of a physical device" },
        { "vkGetPhysicalDeviceProperties2", "Returns properties of a physical device" },
        { "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM",
          "Query the properties of a data graph processing engine for a specific queue family of a "
          "physical device" },
        { "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM",
          "Query the data processing engines and the operations they support for a given queue "
          "family of a physical device" },
        { "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR",
          "Reports the number of passes require for a performance query pool type" },
        { "vkGetPhysicalDeviceQueueFamilyProperties",
          "Reports properties of the queues of the specified physical device" },
        { "vkGetPhysicalDeviceQueueFamilyProperties2",
          "Reports properties of the queues of the specified physical device" },
        { "vkGetPhysicalDeviceRefreshableObjectTypesKHR", "Query refreshable objects" },
        { "vkGetPhysicalDeviceSciBufAttributesNV",
          "Fill the private attributes of the stext,NvSciBufAttrList struct" },
        { "vkGetPhysicalDeviceSciSyncAttributesNV",
          "Get the implementation-specific NvSciSync attributes" },
        { "vkGetPhysicalDeviceScreenPresentationSupportQNX",
          "Query physical device for presentation to QNX Screen" },
        { "vkGetPhysicalDeviceSparseImageFormatProperties",
          "Retrieve properties of an image format applied to sparse images" },
        { "vkGetPhysicalDeviceSparseImageFormatProperties2",
          "Retrieve properties of an image format applied to sparse images" },
        { "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV",
          "Query supported sample count combinations" },
        { "vkGetPhysicalDeviceSurfaceCapabilities2EXT", "Query surface capabilities" },
        { "vkGetPhysicalDeviceSurfaceCapabilities2KHR",
          "Reports capabilities of a surface on a physical device" },
        { "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "Query surface capabilities" },
        { "vkGetPhysicalDeviceSurfaceFormats2KHR", "Query color formats supported by surface" },
        { "vkGetPhysicalDeviceSurfaceFormatsKHR", "Query color formats supported by surface" },
        { "vkGetPhysicalDeviceSurfacePresentModes2EXT", "Query supported presentation modes" },
        { "vkGetPhysicalDeviceSurfacePresentModesKHR", "Query supported presentation modes" },
        { "vkGetPhysicalDeviceSurfaceSupportKHR", "Query if presentation is supported" },
        { "vkGetPhysicalDeviceToolProperties",
          "Reports properties of tools active on the specified physical device" },
        { "vkGetPhysicalDeviceToolPropertiesEXT",
          "Reports properties of tools active on the specified physical device" },
        { "vkGetPhysicalDeviceVideoCapabilitiesKHR", "Query video coding capabilities" },
        { "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR",
          "Query video encode quality level properties" },
        { "vkGetPhysicalDeviceVideoFormatPropertiesKHR",
          "Query supported video decode and encode image formats and capabilities" },
        { "vkGetPhysicalDeviceWaylandPresentationSupportKHR",
          "Query physical device for presentation to Wayland" },
        { "vkGetPhysicalDeviceWin32PresentationSupportKHR",
          "Query queue family support for presentation on a Win32 display" },
        { "vkGetPhysicalDeviceXcbPresentationSupportKHR",
          "Query physical device for presentation to X11 server using XCB" },
        { "vkGetPhysicalDeviceXlibPresentationSupportKHR",
          "Query physical device for presentation to X11 server using Xlib" },
        { "vkGetPipelineBinaryDataKHR", "Get the data store from a pipeline binary" },
        { "vkGetPipelineCacheData", "Get the data store from a pipeline cache" },
        { "vkGetPipelineExecutableInternalRepresentationsKHR",
          "Get internal representations of the pipeline executable" },
        { "vkGetPipelineExecutablePropertiesKHR",
          "Get the executables associated with a pipeline" },
        { "vkGetPipelineExecutableStatisticsKHR",
          "Get compile time statistics associated with a pipeline executable" },
        { "vkGetPipelineIndirectDeviceAddressNV", "Get pipeline\'s 64-bit device address" },
        { "vkGetPipelineIndirectMemoryRequirementsNV",
          "Get the memory requirements for the compute indirect pipeline" },
        { "vkGetPipelineKeyKHR", "Generate the pipeline key from pipeline creation info" },
        { "vkGetPipelinePropertiesEXT", "Query pipeline properties" },
        { "vkGetPrivateData", "Retrieve data associated with a Vulkan object" },
        { "vkGetPrivateDataEXT", "Retrieve data associated with a Vulkan object" },
        { "vkGetQueryPoolResults",
          "Copy results of queries in a query pool to a host memory region" },
        { "vkGetQueueCheckpointData2NV", "Retrieve diagnostic checkpoint data" },
        { "vkGetQueueCheckpointDataNV", "Retrieve diagnostic checkpoint data" },
        { "vkGetRandROutputDisplayEXT",
          "Query the VkDisplayKHR corresponding to an X11 RandR Output" },
        { "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR",
          "Query opaque capture replay data for pipeline shader group handles" },
        { "vkGetRayTracingShaderGroupHandlesKHR",
          "Query ray tracing pipeline shader group handles" },
        { "vkGetRayTracingShaderGroupHandlesNV",
          "Query ray tracing pipeline shader group handles" },
        { "vkGetRayTracingShaderGroupStackSizeKHR",
          "Query ray tracing pipeline shader group shader stack size" },
        { "vkGetRefreshCycleDurationGOOGLE", "Obtain the RC duration of the PE\'s display" },
        { "vkGetRenderAreaGranularity", "Returns the granularity for optimal render area" },
        { "vkGetRenderingAreaGranularity",
          "Returns the granularity for dynamic rendering optimal render area" },
        { "vkGetRenderingAreaGranularityKHR",
          "Returns the granularity for dynamic rendering optimal render area" },
        { "vkGetSamplerOpaqueCaptureDescriptorDataEXT",
          "Get sampler opaque capture descriptor data" },
        { "vkGetScreenBufferPropertiesQNX",
          "Get Properties of External Memory QNX Screen Buffers" },
        { "vkGetSemaphoreCounterValue", "Query the current state of a timeline semaphore" },
        { "vkGetSemaphoreCounterValueKHR", "Query the current state of a timeline semaphore" },
        { "vkGetSemaphoreFdKHR", "Get a POSIX file descriptor handle for a semaphore" },
        { "vkGetSemaphoreSciSyncObjNV", "Get a stext,NvSciSyncObj handle for a semaphore" },
        { "vkGetSemaphoreWin32HandleKHR", "Get a Windows HANDLE for a semaphore" },
        { "vkGetSemaphoreZirconHandleFUCHSIA", "Get a Zircon event handle for a semaphore" },
        { "vkGetShaderBinaryDataEXT", "Get the binary shader code from a shader object" },
        { "vkGetShaderInfoAMD", "Get information about a shader in a pipeline" },
        { "vkGetShaderModuleCreateInfoIdentifierEXT",
          "Query a unique identifier for a shader module create info" },
        { "vkGetShaderModuleIdentifierEXT", "Query a unique identifier for a shader module" },
        { "vkGetSwapchainCounterEXT", "Query the current value of a surface counter" },
        { "vkGetSwapchainImagesKHR",
          "Obtain the array of presentable images associated with a swapchain" },
        { "vkGetSwapchainStatusKHR", "Get a swapchain\'s status" },
        { "vkGetTensorMemoryRequirementsARM",
          "Returns the memory requirements for specified Vulkan object" },
        { "vkGetTensorOpaqueCaptureDescriptorDataARM",
          "Get tensor opaque capture descriptor data" },
        { "vkGetTensorViewOpaqueCaptureDescriptorDataARM",
          "Get tensor view opaque capture descriptor data" },
        { "vkGetValidationCacheDataEXT", "Get the data store from a validation cache" },
        { "vkGetVideoSessionMemoryRequirementsKHR",
          "Get the memory requirements for a video session" },
        { "vkGetWinrtDisplayNV", "Query the VkDisplayKHR corresponding to a WinRT DisplayTarget" },
        { "vkImportFenceFdKHR", "Import a fence from a POSIX file descriptor" },
        { "vkImportFenceSciSyncFenceNV", "Import a fence from a stext,NvSciSyncFence handle" },
        { "vkImportFenceSciSyncObjNV", "Import a fence from a stext,NvSciSyncObj handle" },
        { "vkImportFenceWin32HandleKHR", "Import a fence from a Windows HANDLE" },
        { "vkImportSemaphoreFdKHR", "Import a semaphore from a POSIX file descriptor" },
        { "vkImportSemaphoreSciSyncObjNV", "Import a semaphore from a SciSync handle" },
        { "vkImportSemaphoreWin32HandleKHR", "Import a semaphore from a Windows HANDLE" },
        { "vkImportSemaphoreZirconHandleFUCHSIA", "Import a semaphore from a Zircon event handle" },
        { "vkInitializePerformanceApiINTEL", "Initialize a device for performance queries" },
        { "vkInvalidateMappedMemoryRanges", "Invalidate ranges of mapped memory objects" },
        { "vkLatencySleepNV", "Trigger low latency mode Sleep" },
        { "vkMapMemory", "Map a memory object into application address space" },
        { "vkMapMemory2", "Map a memory object into application address space" },
        { "vkMapMemory2KHR", "Map a memory object into application address space" },
        { "vkMergePipelineCaches", "Combine the data stores of pipeline caches" },
        { "vkMergeValidationCachesEXT", "Combine the data stores of validation caches" },
        { "vkQueueBeginDebugUtilsLabelEXT", "Open a queue debug label region" },
        { "vkQueueBindSparse", "Bind device memory to a sparse resource object" },
        { "vkQueueEndDebugUtilsLabelEXT", "Close a queue debug label region" },
        { "vkQueueInsertDebugUtilsLabelEXT", "Insert a label into a queue" },
        { "vkQueueNotifyOutOfBandNV", "Notify out of band queue" },
        { "vkQueuePresentKHR", "Queue an image for presentation" },
        { "vkQueueSetPerformanceConfigurationINTEL", "Set a performance query" },
        { "vkQueueSubmit", "Submits a sequence of semaphores or command buffers to a queue" },
        { "vkQueueSubmit2", "Submits command buffers to a queue" },
        { "vkQueueSubmit2KHR", "Submits command buffers to a queue" },
        { "vkQueueWaitIdle", "Wait for a queue to become idle" },
        { "vkRegisterDeviceEventEXT", "Signal a fence when a device event occurs" },
        { "vkRegisterDisplayEventEXT", "Signal a fence when a display event occurs" },
        { "vkReleaseCapturedPipelineDataKHR", "Release captured pipeline binary data" },
        { "vkReleaseDisplayEXT", "Release access to an acquired VkDisplayKHR" },
        { "vkReleaseFullScreenExclusiveModeEXT",
          "Release full-screen exclusive mode from a swapchain" },
        { "vkReleasePerformanceConfigurationINTEL",
          "Release a configuration to capture performance data" },
        { "vkReleaseProfilingLockKHR", "Releases the profiling lock" },
        { "vkReleaseSwapchainImagesEXT", "Release previously acquired but unused images" },
        { "vkReleaseSwapchainImagesKHR", "Release previously acquired but unused images" },
        { "vkResetCommandBuffer", "Reset a command buffer to the initial state" },
        { "vkResetCommandPool", "Reset a command pool" },
        { "vkResetDescriptorPool", "Resets a descriptor pool object" },
        { "vkResetEvent", "Reset an event to non-signaled state" },
        { "vkResetFences", "Resets one or more fence objects" },
        { "vkResetQueryPool", "Reset queries in a query pool" },
        { "vkResetQueryPoolEXT", "Reset queries in a query pool" },
        { "vkSetBufferCollectionBufferConstraintsFUCHSIA",
          "Set buffer-based constraints for a buffer collection" },
        { "vkSetBufferCollectionImageConstraintsFUCHSIA",
          "Set image-based constraints for a buffer collection" },
        { "vkSetDebugUtilsObjectNameEXT", "Give an application-defined name to an object" },
        { "vkSetDebugUtilsObjectTagEXT", "Attach arbitrary data to an object" },
        { "vkSetDeviceMemoryPriorityEXT", "Change a memory allocation priority" },
        { "vkSetEvent", "Set an event to signaled state" },
        { "vkSetHdrMetadataEXT", "Set HDR metadata" },
        { "vkSetLatencyMarkerNV", "Pass in marker for timing info" },
        { "vkSetLatencySleepModeNV", "Enable or Disable low latency mode on a swapchain" },
        { "vkSetLocalDimmingAMD", "Set Local Dimming" },
        { "vkSetPrivateData", "Associate data with a Vulkan object" },
        { "vkSetPrivateDataEXT", "Associate data with a Vulkan object" },
        { "vkSignalSemaphore", "Signal a timeline semaphore on the host" },
        { "vkSignalSemaphoreKHR", "Signal a timeline semaphore on the host" },
        { "vkSubmitDebugUtilsMessageEXT", "Inject a message into a debug stream" },
        { "vkTransitionImageLayout", "Perform an image layout transition on the host" },
        { "vkTransitionImageLayoutEXT", "Perform an image layout transition on the host" },
        { "vkTrimCommandPool", "Trim a command pool" },
        { "vkUninitializePerformanceApiINTEL", "Uninitialize a device for performance queries" },
        { "vkUnmapMemory", "Unmap a previously mapped memory object" },
        { "vkUnmapMemory2", "Unmap a previously mapped memory object" },
        { "vkUnmapMemory2KHR", "Unmap a previously mapped memory object" },
        { "vkUpdateDescriptorSetWithTemplate",
          "Update the contents of a descriptor set object using an update template" },
        { "vkUpdateDescriptorSets", "Update the contents of a descriptor set object" },
        { "vkUpdateIndirectExecutionSetPipelineEXT",
          "Update the contents of an indirect execution set" },
        { "vkUpdateIndirectExecutionSetShaderEXT",
          "Update the contents of an indirect execution set" },
        { "vkUpdateVideoSessionParametersKHR", "Update video session parameters object" },
        { "vkWaitForFences", "Wait for one or more fences to become signaled" },
        { "vkWaitForPresent2KHR", "Wait for presentation" },
        { "vkWaitForPresentKHR", "Wait for presentation" },
        { "vkWaitSemaphores", "Wait for timeline semaphores on the host" },
        { "vkWaitSemaphoresKHR", "Wait for timeline semaphores on the host" },
        { "vkWriteAccelerationStructuresPropertiesKHR",
          "Query acceleration structure meta-data on the host" },
        { "vkWriteMicromapsPropertiesEXT", "Query micromap meta-data on the host" },
    };

    return vulkan_command_tool_tip_summaries;
}
